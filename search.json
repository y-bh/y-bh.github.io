[{"title":"常用类","date":"2021-07-29T16:00:00.000Z","url":"/2021/07/30/2021730-%E5%B8%B8%E7%94%A8%E7%B1%BB/","tags":[["包装类","/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/"],["String","/tags/String/"],["Date","/tags/Date/"]],"categories":[["Java","/categories/Java/"]],"content":"包装类针对八种基本数据类型相应的引用类型—包装类 基本数据类型 包装类 boolean Boolean char Character byte Byte short Short int Integer long Long float Float double Double jdk5之前的手动装箱和拆箱方式： jdk5之后可以自动装箱和自动拆箱 包装类型和String类型的相互转换包装类型→String类型 String类型→包装类型 String类 String对象用于保存字符串，也就是一组字符序列 字符串常量对象使用双引号括起的字符序列 字符串的字符使用Unicode编码，一个字符(不区分字母还是汉字)占两个字节 String类有很多构造器，构造器的重载 String类实现了接口Serializable[String可以串行化：可以在网络传输]和Comparable[String对象可以比较大小] String是final类，不能被其他的类继承 String有属性 private final char value[] 用于存放字符串内容 一定要注意：value是一个final类型，不可以修改(指引用地址，单个字符内容可以改变) 创建String对象方式一：直接赋值String s=”xxx”; 先从常量池查看是否有”xxx”数据空间，如果有,直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址 方式二：调用构造器String s2=new String(“xxx”); 先在堆中创建空间，里面维护了value属性，指向常量池的xxx空间。如果常量池没有”xxx”,重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址 StringBuffer类 java.lang.StringBuffer类代表可变的字符序列，可以对字符串内容进行增删 很多方法与String相同，但StringBuffer是可变长度 StringBuffer是一个容器 StringBuffer的直接父类是AbstractStringBuffer StringBuffer实现了Serializable，即StringBuffer的对象可以串行化 在父类中 AbstractStringBuffer有属性 char[] value,不是final。该value数组存放字符串的内容，因此存放在堆中的 StringBuffer是一个final类，不能被继承 因为StringBuffer字符内容是存在char[] value，所以在变化(增加/删除)时，不用每次都更换地址(即不是每次都创建新的对象),所以效率高于String 构造器 构造方法摘要 StringBuffer() 构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符 StringBuffer(CharSequence seq) 构造一个字符串缓冲区，它包含与指定的CharSequence相同的字符 StringBuffer(int capacity) 构造一个不带字符，但具有指定初始容量的字符串缓冲区。即对char[]大小进行指定 StringBuffer(String str) 构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容 String→StringBuffer方式一：使用构造器 方式二：使用append方法 StringBuffer→String方式一：使用StringBuffer提供的toString方法 方式二：使用构造器 StringBuilder类 一个可变的字符序列。此类提供一个与StringBuilder兼容的API，但不保证同步。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快 在StringBuilder上的主要操作是append和insert方法,可重载这些方法，以接受任意类型的数据。 StringBuilder类继承AbstractStringBuilder 实现了Serializable，说明StringBuilder对象是可以串行化的 StringBuilder是final类，不能被继承 StringBuilder对象字符序列仍然是存放在其父类中的 char[] value;。因此，字符序列是在堆中 StringBuilder的方法，没有做互斥的处理，即没有synchronized关键字，因此在单线程的情况下使用 String、StringBuffer、StringBuilder的比较 StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样 String：不可变字符序列，效率低，但是复用率高 StringBuffer：可变字符序列、效率较高(增删)、线程安全 StringBuilder：可变字符序列、效率最高、线程不安全 String使用注意说明： string a=”a”;//创建了一个字符串 s+=”b”;//实际上原来的“a”字符串对象已经丢弃了，现在又产生了一个字符串s+=”b”(也就是”ab”)。如果多次执行这些多次改变串内容的操作，会导致大量副本字符串对象留在内存中，降低效率。这样的操作放到循环中，会极大影响程序性能。 结论：如果要对String做大量修改，不要使用String 效率：StringBuilder&gt;StringBuffer&gt;String String、StringBuffer、StringBuilder的选择 如果字符串存在大量的修改操作，一般用StringBuffer或StringBuilder 如果字符串存在大量的修改操作,并在单线程的情况，使用StringBuilder 如果字符串存在大量的修改操作,并存在多线程的情况，使用StringBuffer 如果字符串很少修改，被多个对象引用，使用String,比如配置信息等 "},{"title":"面向对象编程(OOP)","date":"2021-07-21T16:00:00.000Z","url":"/2021/07/22/2021722-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(OOP)/","tags":[["Java基础","/tags/Java%E5%9F%BA%E7%A1%80/"],["OOP","/tags/OOP/"]],"categories":[["Java","/categories/Java/"]],"content":"基本概念面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装。 优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 缺点： 性能比面向过程差 三大特性 封装 隐藏对象的属性和实现细节，仅对外提供公共访问方式，将便于隔离，便于使用，提高复用性和安全性 继承 提高代码复用性；继承是多态的前提 多态 父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性 五大基本原则 单一职责原则SRP（Single Responsibility Principle） 类的功能要单一，不能包罗万象，跟杂货铺似的 开放封闭原则OCP(Open－Close Principle) 一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意 里氏替换原则LSP(the Liskov Substitution Principle LSP) 子类可以替换父类出现在父类能够出现的任何地方 依赖倒置原则DIP(the Dependency Inversion Principle DIP) 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象 接口分离原则ISP(the Interface Segregation Principle ISP) 设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好 创建对象 访问属性对象名.属性名 类和对象的内存分配机制 p2.age是多少？画出内存图 Java内存结构分析 栈：一般存放基本数据类型（局部变量） 堆：存放对象(Cat cat，数组等) 方法区：常量池（常量，比如字符串），类加载信息 创建对象流程： 先加载类信息（属性和方法信息，只会加载一次） 在堆中分配空间，进行默认初始化 把地址赋给对象名，对象名指向对象 成员方法方法调用机制原理 成员方法的好处： 提高代码复用性 可以将实现的细节封装起来，然后供其他用户来调用 使用细节 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数 方法不能嵌套定义 一个方法最多有一个返回值 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象) 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值，而且要求返回值类型必须和 return 的值类型一致或兼容 如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return; 基本数据类型的传参机制基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参 引用数据类型的传参机制引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参 方法递归 执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 方法的局部变量是独立的，不会相互影响，比如n变量 如果方法中使用的是引用类型变量(比如数组，对象)，就会共享该引用类型的数据 递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕 方法重载（OverLoad）java 中允许同一个类中，多个同名方法的存在，但要求形参列表不一致 好处：减轻起名、记名的麻烦 使用细节 方法名：必须相同 形参列表：必须不同(形参类型或个数或顺序，至少有一样不同，参数名无要求) 返回类型：无要求 可变参数基本概念java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。 就可以通过可变参数实现 基本语法访问修饰符 返回类型 方法名(数据类型… 形参名) { } 注意事项和使用细节 可变参数的形参可以为0个或任意多个 可变参数的实参可以为数组 可变参数的本质就是数组 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后 一个形参列表中只能出现一个可变参数 作用域 在java编程中，主要的变量就是属性(成员变量)和局部变量 我们说的局部变量一般是指在成员方法中定义的变量 java中作用域的分类 全局变量：也就是属性，作用域为整个类体 局部变量：也就是除了属性之外的其他变量，作用域为定义他的代码块中 全局变量(属性)可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值。 使用细节 属性和局部变量可以重名，访问时遵循就近原则 在同一个作用域中，例如在同一个成员方法中，两个局部变量不能重名 属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中 作用域范围不同 全局变量/属性：可以被本类使用，或其他类使用(通过对象调用) 局部变量：只能在本类中对应的方法中使用 修饰符不同 全局变量/属性：可以被本类使用，或其他类使用(通过对象调用) 局部变量：只能在本类中对应的方法中使用 修饰符不同 全局变量/属性可以加修饰符 局部变量不可以加修饰符 构造方法/构造器基本语法[修饰符] 方法名(形参列表){ 方法体; } 使用细节 构造器的修饰符没有限制 构造器没有返回值 方法名和类名字必须一样 参数列表和成员方法一样的规则 构造器的调用，由系统完成 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化 一个类可以定义多个不同的构造器，即构造器重载 构造器是完成对象初始化，并不是创建对象 如果没有手动定义构造器，系统会自动生成一个默认无参构造器 一旦定义自己的构造器，默认构造器就会被覆盖，就不能再使用，除非显式定义一下。 对象创建流程分析 加载类信息，只会加载一次 在堆中分配空间(地址) 完成对象初始化 默认初始化——&gt;显式初始化——&gt;构造器初始化 把对象在堆中的地址，返回给p(p是对象名，也可以理解成是对象的引用) this关键字java虚拟机会给每个对象分配this，代表当前对象。 哪个对象调用，this就代表哪个对象 使用细节 this 关键字可以用来访问本类的属性、方法、构造器 this 用于区分当前类的属性和局部变量 访问成员方法的语法：this.方法名(参数列表); 访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句) this 不能在类定义的外部使用，只能在类定义的方法中使用 访问修饰符 修饰符 同类 同包 子类 不同包 private √ × × × default √ √ × × protected √ √ √ × public √ √ √ √ 注意事项 修饰符可以用来修饰类中的属性，成员方法以及类 只有默认的和public才能修饰类，并且遵循上述访问权限的特点 成员方法的访问规则和属性相同 面向对象编程三大特征封装封装就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作 优点 隐藏实现细节：方法(连接数据库)⬅调用(传入参数) 可以对数据进行验证，保证安全合理 步骤 将属性进行私有化private[不能直接修改属性] 提供一个公共的set方法，用于对属性判断并赋值 提供一个公共的get方法，用于获取属性的值 继承继承可以解决代码复用.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来 声明继承父类即可 子类会自动拥有父类定义的属性和方法 父类又叫超类，基类 子类又叫派生类 优点 代码的复用性提高了 代码的扩展性和维护性提高了 细节问题 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问 子类必须调用父类的构造器， 完成父类的初始化 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无 参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过 如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表) super 在使用时，必须放在构造器第一行(super 只能在构造器中使用) super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器 java 所有类都是 Object 类的子类, Object 是所有类的基类 父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类) 子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系 super关键字super 代表父类的引用，用于访问父类的属性、方法、构造器 访问父类的属性，但不能访问父类的private属性：super.属性名 访问父类的方法，但不能访问父类的private方法：super.方法名 访问父类的构造器：super(参数列表)（只能放在构造器的第一句，只能出现一次） 优点 分工明确，父类属性由父类初始化，子类的属性由子类初始化 当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果 super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员，如果多个基类中都有同名的成员，使用super访问遵循就近原则。当然也要遵循访问权限的相关规则 super 和 this 的比较 No. 区别 this super 1 访问属性 访问本类中的属性，如果本类没有此属性则从父类中继续查找 从父类开始查找属性 2 调用方法 访问本类中的方法，如果本类没有此方法则从父类继续查找 从父类开始查找方法 3 调用构造器 调用本类构造器，必须放在构造器的首行 调用父类构造器，必须放在子类构造器的首行 4 特殊 表示当前对象 子类中访问父类对象 多态方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的 具体体现方法的多态重载中传入不同的参数，就会调用不同sum方法。 重写中不同对象调用同一方法，就会执行不同的内容 对象的多态 一个对象的编译类型和运行类型可以不一致 编译类型在确认对象时，就确定了，不能改变 运行类型是可以变化的 编译类型看定义时=号的左边，运行类型看=号的右边 例如 Animal是Dog的父类 表示animal编译类型是Animal，运行类型是Dog 注意事项 多态的前提是：两个对象存在继承关系 多态的向上转型 本质：父类的引用指向了子类的对象 语法：父类类型 引用名=new 子类类型(); 特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员(需遵守访问权限)，不能调用子类中特有成员（因为在编译阶段，能调用哪些成员，是由编译类型来决定的）；最终运行效果看子类的具体实现（即调用方法时，按照从子类(运行类型)开始查找方法） 多态向下转型 语法：子类类型 引用名=(子类类型) 父类引用; 只能强转父类的引用，不能强转父类的对象 要求父类的引用必须指向的是当前目标类型的对象 当向下转型后，可以调用子类类型中所有的成员 属性不能重写，属性的值看编译类型 instanceOf 比较操作符：用于判断对象的运行类型是否为xx类型或xx类型的子类型 动态绑定机制 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用 多态数组数组的定义类型为父类类型，里面保存的实际元素类型为子类类型 多态参数方法定义的形参类型为父类类型，实参类型允许为子类类型 方法重写/覆盖当子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么子类方法会覆盖父类方法 使用细节 子类的形参列表、方法名称要和父类的完全一样 子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类 子类方法不能缩小父类方法的访问权限 重写与重载 名称 发生范围 方法名 形参列表 返回类型 修饰符 重载(overload) 本类 必须一样 类型、个数、顺序至少有一个不同 无要求 无要求 重写(override) 子父类 必须一样 相同 子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类 子类方法不能缩小父类方法的访问范围 Object类详解equals方法&amp;====是一个比较运算符 既可以判断基本类型，又可以判断引用类型 判断基本类型判断的实质的值是否相等 判断引用类型判断的是地址是否相等，即判定是不是同一个对象 equals是Object类中的方法，只能判断引用类型。默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等，例如String、Integer hashcode方法 提高具有哈希结构的容器的效率 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的 两个引用，如果指向的是不同对象，则哈希值是不一样的 哈希值主要根据地址号来的，不能完全将哈希值等价于地址 toString方法 默认返回：全类名+@+哈希值的16进制，子类往往重写toString方法，用于返回对象的属性信息 重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式 当直接输出一个对象时，toString会被默认的调用 finalize方法 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法 垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制 类变量和类方法类变量类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量 定义语法： 访问修饰符 static 数据类型 变量名； static 访问修饰符 数据类型 变量名； 访问类变量： 类名.类变量名 或者 对象名.类变量名 使用细节 当需要让类中的所有对象都共享同一个变量时，就可以考虑使用类变量 类变量与实例变量区别：类变量是该类的所有对象共享的，实例变量是每个对象独享的 实例变量不能通过 类名.类变量名 方式访问 类变量是在类加载时初始化，即使没有创建对象，只要类加载了，就可以使用类变量了 类变量的生命周期是随类的加载开始，随着类的消亡销毁 类方法类方法也叫静态方法 格式： 访问修饰符 static 返回类型 方法名(){} static 访问修饰符 返回类型 方法名(){} 调用： 类名.类方法名 对象名.类方法名 使用场景当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率 例如：工具类中的方法 utils(Math类、Arrays类) 使用细节 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区 类方法中无this参数，普通方法中隐含着this的参数 类方法可以通过类名调用，也可以通过对象名调用 普通方法和对象有关，需要通过对象名调用，不能通过类名调用 类方法中不能使用和对象有关的关键字比如this、super 类方法中只能访问静态变量或静态方法 普通成员方法既可以访问非静态成员，也可以访问静态成员 mian方法解释mian方法的形式：public static void main(String[] args){} main方法时虚拟机调用 java虚拟机调用类的mian()方法,所以该方法的访问权限必须是public 虚拟机在执行mian()方法时不必创建对象，所以该方法必须使static 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数 注意： 在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性 不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员 代码块代码块又称为初始化块，属于类中的成员[即，是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来 但和方法不同，没有方法名，没有返回值，没有参数，只有方法体，而且不用通过对象或类的显式调用，而是加载类时，或创建对象时隐式调用 格式[修饰符]{代码}; 说明注意： 修饰符可选，只能写static 代码块分为两类，使用static修饰的叫静态代码块，否则为普通代码块 逻辑语句可以为任何逻辑语句 ;号可以写也可以省略 理解 相当于另一种形式的构造器(对构造器的补充机制)，可以做初始化的操作 场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性 使用细节 static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行 类什么时候加载 创建对象实例时(new) 创建子类对象实例，父类也会被加载 使用类的静态成员时(静态属性、静态方法) 普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行 创建一个对象时，在一个类的调用顺序： 调用静态代码块和静态属性初始化 调用普通代码块和普通属性初始化 调用构造方法 构造器的最前面其实隐含了super()和调用普通代码块 当创建一个子类对象时(继承关系)，他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序 父类的静态代码块和静态属性(优先级一样，按定义顺序执行) 子类的静态代码块和静态属性(优先级一样，按定义顺序执行) 父类的普通代码块和普通属性(优先级一样，按定义顺序执行) 父类的构造方法 子类的普通代码块和普通属性(优先级一样，按定义顺序执行) 子类的构造方法 静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任意成员 final关键字final可以修饰类、属性、方法和局部变量 使用final场合： 当不希望类被继承时 当不希望父类的某个方法被子类覆盖/重写时 当不希望类的某个属性的值被修改 当不希望某个局部变量被修改 使用细节 final修饰的属性又叫常量，一般用XX_XX_XX来命名 final修饰的属性在定义时,必须赋初值，并且以后不能再修改，可以赋初值的位置： 定义时 在构造器中 代码块中 如果final修饰的属性是静态的，则初始化的位置只能是定义时或静态代码块中 final类不能继承，但是可以实例化对象 如果类不是final，但是含有final方法，则该方法虽然不能重写，但是可以被继承 一般来说，如果已经是final类，就没必要再将方法修饰成final方法 final不能修饰构造方法 final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理 包装类和String,都是final类 抽象类当父类的某些方法需要声明，但又不确定如何实现的时候，可以将其声明为抽象方法，那么这个类就是抽象类 用abstract关键字来修饰一个类的时候，这个类就叫做抽象类，修饰方法的时候就叫抽象方法 抽象类的价值更多作用是在于设计，是设计者设置好后，让子类继承并实现抽象类() 使用细节 抽象类不能被实例化 抽象类不一定要包含abstract方法 一旦类包含了abstract方法，那这个类必须声明为抽象类 abstract只能修饰类和方法，不能修饰属性和其他的 抽象类可以有任意成员[抽象类本质还是类]，比如：非抽象方法、构造器、静态属性等等 抽象方法不能有主体，即不能实现 如果一个类继承了抽象类，则必须实现所有抽象类的所有抽象方法，除非他自己也声明为abstract类 抽象方法不能使用private、final、static来修饰，因为这些关键词都是和重写相违背的 接口接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法实现出来 interface 接口名{} class 类名 implements 接口{必须实现接口的方法} 接口是更加抽象的抽象的类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体【jdk7】。接口体现了程序设计的多态和高内聚低耦合的设计思想 注意：jdk8后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现 使用细节 接口不能被实例化 接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰 一个普通类实现接口，就必须将该接口的所有方法实现 抽象类实现接口，可以不用实现接口的方法 一个类可以实现多个接口 接口中的属性只能是final的，而且是public static final修饰符，必须初始化（比如：int a=1实际上是public static final int a=1） 接口中属性访问形式：接口名.属性名 接口不能继承其他的类，但是可以继承多个其他接口 接口的修饰符只能是public和默认，这点和类的修饰符是一样的 接口和继承继承的价值在于：解决代码的复用性和可维护性 接口的价值主要在于：设计好各种规范(方法)，让其他类去实现这些方法。即，更加的灵活 接口比继承更加灵活，继承是满足is-a的关系，接口是满足like-a的关系 接口在一定程度上实现代码解耦【即：接口规范性+动态绑定机制】 内部类一个类的内部又完整的嵌套了另一个类结构。被嵌套的类被称为内部类，嵌套其他类的类称为外部类，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系 如果定义在局部位置(方法中/代码块):局部内部类（有类名）&amp;匿名内部类（没有类名） 定义在成员的位置:成员内部类（没用static修饰）&amp;静态内部类（使用static修饰） 局部内部类局部内部类是定义在外部类的局部位置，比如方法中，并且有类名。 可以直接访问外部类的所有成员，包含私有的 不能添加访问修饰符，因为它是一个局部变量，局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量可以使用final 作用域：仅仅在定义它的方法或代码块中 局部内部类访问外部类的成员[访问方式：直接访问] 外部类访问局部内部类的成员[访问方式：创建对象，再访问（注意：必须在作用域中）] 外部其他类不能访问局部内部类(因为局部内部类地位是一个局部变量) 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员则可以使用（外部类名.this.成员）去访问 匿名内部类匿名内部类既是一个类的定义，也是一个对象。 匿名内部类只会加载一次， 成员内部类成员内部类是定义在外部类的成员位置，并且没有static修饰 可以直接访问外部类的所有成员，包含私有的 可以添加任意访问修饰符 作用域和外部其他成员一样，为整个类体 成员内部类访问外部类[直接访问] 外部类访问成员内部类[先创建对象，再访问] 静态内部类静态内部类是定义在外部类的成员位置，并且有static修饰 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员 可以添加任意访问修饰符，因为他的地位就是一个成员 作用域：同其他成员，为整个类体 静态内部类访问外部类[直接访问所有静态成员] 外部类访问静态内部类[创建对象再访问] "},{"title":"七大设计原则","date":"2021-07-14T16:00:00.000Z","url":"/2021/07/15/2021715-%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","tags":[["设计原则","/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"]],"categories":[["设计模式","/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"content":"设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据) 单一职责原则对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。 当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2 实例例如：建立一个Vehicle类，实现run方法 飞机不能在公路运行，因此可以建三个不同的交通工具类，来满足需求 改进后 注意事项和细节 降低类的复杂度，一个类只负责一项职责 提高类的可读性，可维护性 降低变更引起的风险 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违 反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则 接口隔离原则客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上 按隔离原则应当这样处理： 将接口Interface1拆分为独立的几个接口， 类A和类C分别与他们需要的接口建立依赖 关系。也就是采用接口隔离原则 改进后： 依赖倒转原则 高层模块不应该依赖于底层模块，二者都应该依赖其抽象 抽象不应该依赖细节，细节应该依赖于抽象 依赖倒转(倒置)的中心思想是面向接口编程 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定 多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成 例如：完成Person接收消息的功能 改进后： 依赖关系传递的三种方式 主方法 注意事项和细节 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在 一个缓冲层，利于程序扩展和优化 继承时遵循里氏替换原则 里氏替换原则面向对象中的继承性的思考和说明 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契 约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实 现的方法任意修改，就会对整个继承体系造成破坏 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵 入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承， 则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子 类的功能都有可能产生故障 问题提出：在编程中，如何正确的使用继承? =&gt; 里氏替换原则 里氏替换原则内容 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序 P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可 以通过聚合，组合，依赖来解决问题 在实际编程中，我们常常会通过重写父类的方法完 成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运 行多态比较频繁的时候。通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉， 采用依赖，聚合，组合等关系代替 例如： 开闭原则 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用 方)。用抽象构建框架，用实现扩展细节。 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已 有的代码来实现变化。 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则 根据此类图设计一段代码 优点：比较好理解，简单易操作 缺点：违反了设计模式的ocp原则，即对扩展开放(提供方)，对修改关闭(使用方)。 即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码 改进思路： 把创建Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可， 这样我们有新的图形种类时，只需要让新的图形类继承Shape，并实现draw方法即可。使用方的代码就不需要改动，满足了开闭原则 迪米特原则 一个对象应该对其他对象保持最少的了解 类与类的关系越密切，耦合度越大 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的 越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内 部。对外除了提供的public 方法，不对外泄露任何信息 迪米特法则还有个更简单的定义：只与直接的朋友通信 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系， 我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而 出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部 实例 有一个学校，下属有各个学院和 总部，现要求打印出学校总部员 工ID和学院员工的id 改进： 前面设计的问题在于SchoolManager中，CollegeEmployee类并不是 SchoolManager类的直接朋友 (分析) 按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合 注意事项和细节 迪米特法则的核心是降低类之间的耦合 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低 类间(对象间)耦合关系， 并不是要求完全没有依赖关系 合成复用原则原则是尽量使用合成/聚合的方式，而不是使用继承 核心思想 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代 码混在一起。 针对接口编程，而不是针对实现编程。 为了交互对象之间的松耦合设计而努力 "},{"title":"二叉平衡树(AVL树)","date":"2021-06-28T16:00:00.000Z","url":"/2021/06/29/2021-6-29-%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91(AVL%E6%A0%91)/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"平衡二叉树 问题分析 左子树全部为空，从形式上看，更像一个单链表 插入速度没有影响 查询速度明显降低(因为需要依次比较), 不能发挥BST 的优势，因为每次还需要比较左子树，其查询速度比 单链表还慢 解决方案-平衡二叉树(AVL) 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高 具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等 左旋转要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8} 步骤 创建一个新的节点，值等于当前根结点的值 把新节点的左子树设置成当前节点的左子树 把新结点的右子树，设置成当前节点的右子树的左子树 吧当前节点的值，换成右子节点的值 把当前节点的右子树设置成右子树的右子树 把当前节点的左子树设置为新节点 右旋转要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6} 步骤： 创建一个新的节点，值等于当前根结点的值 把新节点的右子树设置为当前节点的右子树 把新节点的左子树设置成当前节点的左子树的右子树 把当前节点的值换为左子节点的值 把当前节点的左子树设置成左子树的左子树 把当前节点的右子树设置成新节点 双旋转有时，单旋转并不能完成平衡二叉树的转换 步骤 当符合右旋转的条件时 如果它的左子树的右子树的高度大于它的左子树的高度 先对当前这个节点的左节点进行左旋转 再对当前节点进行右旋转的操作即可 "},{"title":"图","date":"2021-06-28T16:00:00.000Z","url":"/2021/06/29/2021-6-29-%E5%9B%BE/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"图线性表局限于一个直接前驱和一个直接后继的关系，树也只能有一个直接前驱，也就是父节点。当需要表示多对多的关系时，就会用到图 图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点 图包括：顶点、边、路径 图分为：无向图、有向图(顶点之间的连接有方向)、带权图(边带权值) 图的表示方式分为：二维数组表示（邻接矩阵）；链表表示（邻接表） 邻接矩阵邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的行和列表示的是1….n个点 邻接表邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成 实例用代码实现以下结构 思路分析 存储顶点String使用ArrayList 保存矩阵：int[][] edges 代码实现 深度优先遍历基本思想深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点 这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问 深度优先搜索是一个递归的过程 步骤以同一个图为例： 访问初始结点v，并标记结点v为已访问 查找结点v的第一个邻接结点w 若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123） 查找结点v的w邻接结点的下一个邻接结点，转到步骤3 广度优先遍历基本思想图的广度优先搜索(Broad First Search) 。 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点 步骤 访问初始结点v并标记结点v为已访问 结点v入队列 当队列非空时，继续执行，否则算法结束 出队列，取得队头结点u 查找结点u的第一个邻接结点w 若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤 若结点w尚未被访问，则访问结点w并标记为已访问 结点w入队列 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6 "},{"title":"二叉排序树","date":"2021-06-28T16:00:00.000Z","url":"/2021/06/29/2021-6-29-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"二叉排序树对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右节点的值比当前节点大（如果有相同的值，可以将该节点放在左子节点或右子节点） 应用实例一个数组{7，3，10，12，5，1，9}创建成对应的二叉排序树，并进行中序遍历二叉排序树 添加、遍历节点添加Node节点 创建二叉排序树 测试 删除节点有三种情况 删除叶子节点(比如：2，5，9，12) 删除只有一颗子树的节点(比如：1) 删除有两棵子树的节点(比如：7，3，10) 删除叶子节点思路分析 找到要删除的节点targetNode 找到targetNode的父节点parent 确定targetNode是parent的左子节点还是右子节点 根据第三步的情况对应删除 左子节点 parent.left=null; 右子节点 parent.right=null; 删除只有一棵子树的节点思路分析 找到要删除的节点targetNode 找到targetNode的父节点parent 确定targetNode的子节点是左子节点还是右子节点 targetNode是parent的左子节点还是右子节点 如果targetNode有左子节点 如果targetNode是parent的左子节点:parent.left=targetNode.left 如果targetNode是parent的右子节点:parent.right=targetNode.left 如果targetNode有右子节点 如果targetNode是parent的左子节点:parent.left=targetNode.right 如果targetNode是parent的右子节点:parent.right=targetNode.right 删除有两棵子树的节点思路分析 找到要删除的节点targetNode 找到targetNode的父节点parent 从targetNode的右子树找到最小节点 用一个临时变量temp将最小节点的值保存 删除该最小节点 targetNode.value=temp; 代码实现 node类中添加方法 在BinarySortTree中添加 测试 "},{"title":"多路查找树","date":"2021-06-28T16:00:00.000Z","url":"/2021/06/29/2021-6-29-%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"多路查找树二叉树问题分析二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如1亿)， 就存在如下问题： 构建二叉树时，需要多次进行i/o操作(海量数据存在数据库或文件中),节点海量构建二叉树时，速度有影响 节点海量，会造成二叉树高度很大，会降低操作速度 多叉树 在二叉树中，每个节点有数据项，最多有两个子节点。如果每个节点可以有更多的数据项和更多的子节点，就是多叉树 2-3树，2-3-4树都属于多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化 B树B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入 将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中 B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4 B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据 搜索有可能在非叶子结点结束 其搜索性能等价于在关键字全集内做一次二分查找 2-3树 2-3树所有的叶子节点都在同一层(只要是B树都满足这个条件) 有2个子节点的节点叫2节点，2节点要么没有子节点，要么有2个子节点 有3个子节点的节点叫3节点，3节点要么没有子节点，要么有3个子节点 2-3树是由2节点和3节点狗=构成的树 B+树B+树是B树的变体，也是一种多路搜索树 B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的 不可能在非叶子结点命中 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层 更适合文件索引系统 B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然 B*树B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针 B树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2 从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高 "},{"title":"10大常用算法","date":"2021-06-28T16:00:00.000Z","url":"/2021/06/29/2021-06-29-10%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"二分查找算法(非递归) 前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 1)二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 &lt; 100 &lt; 2^7) 代码实现数组 {1,3, 8, 10, 11, 67, 100}, 编程实现二分查找， 要求使用非递归的方式完成 分治算法 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)…… 分治算法可以求解的一些经典问题： 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔 基本步骤分治法在每一层递归上都有三个步骤 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 合并：将各个子问题的解合并为原问题的解 汉诺塔汉诺塔游戏的演示和思路分析 如果是有一个盘， A-&gt;C 如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘 先把 最上面的盘 A-&gt;B 把最下边的盘 A-&gt;C 把B塔的所有盘 从 B-&gt;C 代码实现 动态规划算法动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 ) 动态规划可以通过填表的方式来逐步推进，得到最优解 背包问题 要求达到的目标为装入的背包的总价值最大，并且重量不超出 要求装入的物品不能重复 思路分析背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用) 这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包 算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i] [j]表示在前i个物品中能够装入容量为j的背包中的最大价值 KMP算法 KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法 Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法 KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间 字符串匹配问题有一个字符串 str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2=”ABCDABD” 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 要求：使用KMP算法完成判断，不能使用简单的暴力匹配算法 KMP算法相关文章链接 贪心算法贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果 集合覆盖问题假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号 思路分析目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合： 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） 将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉 重复第1步直到覆盖了全部的地区 普利姆算法最小生成树（MST） 给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 N个顶点，一定有N-1条边 包含全部顶点 N-1条边都在图中 主要应用于普利姆算法&amp;克鲁斯卡尔算法 普利姆算法介绍普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图 步骤 设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1 若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1 重复步骤2，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边 修路问题 有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里 如何修路保证各个村庄都能连通，并且总的修建公路总里程最短? 克鲁斯卡尔算法 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法 基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路 具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止 图解： 假设，用数组R保存最小生成树结果 克鲁斯卡尔算法需解决的问题： 问题一 对图的所有边按照权值大小进行排序。 问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路 问题一，使用排序算法即可解决 问题二，处理方式是：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路 城市公交站问题 新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通 各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短? "},{"title":"哈夫曼树","date":"2021-06-21T16:00:00.000Z","url":"/2021/06/22/2021-6-22-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"哈夫曼树给定n个权值作为n个叶子节点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree) 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1 结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树 WPL最小的就是赫夫曼树 实例将数列[13，7，8，3，29，6，1]，转成一颗哈夫曼树 思路分析 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树 取出根节点权值最小的两颗二叉树 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树 哈夫曼编码哈夫曼编码是哈夫曼树在电讯通信中的经典应用之一 哈夫曼编码广泛的用于数据文件压缩。其压缩率通常在20%-90%之间 哈夫曼码是可变字长编码(VLC)的一种Huffman于1952年提出一种编码方法，称之为最佳编码 通信领域中信息的处理方式-定长编码 将字符转换为ASCII码二进制形式来传递信息 通信领域中信息的处理方式-变长编码 统计各字符对应的个数，按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小 比如一串字符中出现了：d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 “ ”:9 ，那么每个字符对应的编码为：0=“ ” , 1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d 字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码 通信领域中信息的处理方式-赫夫曼编码 d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 “ ”:9 按照上面字符出现的次数构建一颗哈夫曼树，次数作为权值 注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的, 比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为： "},{"title":"哈希表","date":"2021-06-08T16:00:00.000Z","url":"/2021/06/09/202169-%E5%93%88%E5%B8%8C%E8%A1%A8/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"哈希表散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 实例有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的id时,要求查找到该员工的所有信息. 要求： 不使用数据库,速度越快越好=&gt;哈希表(散列) 添加时，保证按照id从低到高插入 使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息]。实现增删改查。 代码实现"},{"title":"二叉树","date":"2021-06-08T16:00:00.000Z","url":"/2021/06/09/202169-%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"二叉树数组存储方式优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低 链式存储方式优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好) 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 树存储方式能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度 树的常用术语 节点 根节点 父节点 子节点 叶子节点(没有子节点的节点) 节点的权(节点值) 路径(从root节点找到该节点的路线) 层 子树 树的高度(最大层数) 森林：多颗子树构成森林 二叉树概念树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树 二叉树的子节点分为左节点和右节点 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树 二叉树遍历步骤前序遍历: 先输出当前节点(初始的时候就是root节点) 如果左子节点不为空，则递归继续前序遍历 如果右子节点不为空，则递归继续前序遍历 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树 如果当前节点的左子节点不为空，则递归中序遍历 输出当前节点 如果当前节点的右子节点不为空，则递归中序遍历 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点 如果当前节点的左子节点不为空，则递归后序遍历 如果当前节点的右子节点不为空，则递归后序遍历 输出当前节点 代码实现 二叉树查找思路分析前序查找 先判断当前节点的no是否等于要查找的 如果相等则返回该节点 如果不等，则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找 如果左递归前序查找，找到节点，则返回，否则继续判断，当前的节点的右子节点是否为空，如果不为空则继续向右递归前序查找 中序查找 判断当前节点的左子节点是否为空，如果不为空，则递归中序查找 如果找到，则返回，如果没有找到，就和当前节点比较，如果是则返回当前节点，否则继续进行右递归的中序查找 如果右递归中序查找，找到就返回，否则返回null 后序查找 判断当前节点的左子节点是否为空，如果不为空，则递归后序查找 如果找到就返回，如果没有找到，就判断当前节点的右子节点是否为空，如果不为空，则右递归进行后序查找，如果找到就返回 和当前节点进行比较，如果是则返回，否则返回null 代码实现 二叉树删除 如果删除的节点是叶子节点，则删除该节点 如果删除的节点是非叶子节点，则删除该子树 代码实现 顺序存储二叉树从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换为树，树也可以转换成数组。 特点： 顺序二叉树通常只考虑完全二叉树 第n个元素的左子节点为n*2+1 第n个元素的右子节点为n*2+2 第n个元素的父节点为(n-1)/2 n：表示二叉树中的第几个元素(按0开始编号) 实例给出一个数组[1,2,3,4,5,6,7],要求以二叉树前序遍历形式进行遍历。 前序遍历的结果应当为[1,2,4,5,6,7] 代码实现 线索化二叉树基本介绍 当对此二叉树进行中序遍历时，数列为[8,3,10,1,6,14]。但是，6、8、10、14这几个节点的左右指针，并没有完全的利用上 可以利用线索化二叉树来让各个节点指向自己的前后节点 n个节点的二叉链表中含有n+1【公式2n-（n-）=n+】个空指针域。利用二叉链表中的空指针域，存放指向该节点在某种遍历次序下的前驱和后继节点的指针(附加的指针称为线索) 这种加上了线索的二叉树表称为线索链表，相应的二叉树称为线索二叉树。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后续线索二叉树三种 一个节点的前一个节点，称为前驱节点 一个结点的后一个节点，称为后继节点、 应用实例将图片的二叉树进行中序线索二叉树。中序遍历的数列为[8,3,10,1,14,6] 当线索化二叉树后，Node节点的 属性 left 和 right ，有如下情况 left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点 right指向的是右子树，也可能是指向后继节点，比如 ① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点 代码实现 遍历线索化二叉树代码实现 堆排序堆排序是利用“堆”这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O（nlogn）,它也是不稳定排序。 堆是具有以下性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值，成为大顶堆。反之，称为小顶堆 大顶堆 我们对堆中的结点按层进行编号，映射到数组中 小顶堆与之相反 一般升序用大顶堆，降序用小顶堆 基本思想 将待排序序列构造成一个大顶堆 此时，整个序列的最大值就是堆顶的根节点 将其与末尾元素进行交换，此时末尾就是最大值 将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行 实例将数组[4,6,8,5,9]使用堆排序法，将数组升序排序 "},{"title":"查找算法","date":"2021-06-03T16:00:00.000Z","url":"/2021/06/04/202164-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"线性查找算法从给定的数组中逐个查找，直到找到目标，返回该数值下标 代码实现 二分查找算法代码实现 插值查找算法插值查找算法原理介绍插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找 将折半查找中的求mid索引的公式，low表示左边索引，high表示右边索引，key就是需要查找的值‘findVal’ 将 改成 代码实现 注意： 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快 关键字分布不均匀的情况下，该方法不一定比折半查找要好 斐波那契查找算法（黄金分割法）黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比 斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618 斐波那契原理斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1（F代表斐波那契数列） 对F(k-1)-1的理解由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1** 。该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如上图所示。从而中间位置为mid=low+F(k-1)-1 类似的，每一子段也可以用相同的方式分割 但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可 代码实现请对一个有序数组进行斐波那契查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标 "},{"title":"递归","date":"2021-06-01T16:00:00.000Z","url":"/2021/06/02/202162-%E9%80%92%E5%BD%92/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"递归概念简单地说，递归就是方法自己调用自己，每次调用时传入不同的变量。 递归有助于解决复杂的问题，同时可以让代码变得简洁 递归调用机制递归调用规则 当程序执行到一个方法时，就会开辟一个独立的空间(栈) 每个空间的数据(局部变量)，是独立的 代码演示 递归可以解决的问题 各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等 将用栈解决的问题–&gt;第归代码比较简洁 递归需要遵守的规则 1)执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 方法的局部变量是独立的，不会相互影响 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError 当一个方法执行完毕，或者遇到return，就会返回。遵守谁调用就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕 迷宫问题模拟小球绕过迷宫走到终点的过程 用数组来模拟迷宫先创建一个二维数组来模拟迷宫，大小为8行7列 main方法中： 使用递归回溯给小球找路 map表示地图 i、j 表示从地图的哪个位置开始出发(1,1) 如果小球能到[6][5]位置，则说明通路找到 约定：当map[i][j]为0表示该点没有走过，为1表示墙，为2表示通路可以走，为3表示该点已经走过，但是走不通 再走迷宫时，需要指定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 主类中： 使用递归回溯找路main方法中： 八皇后问题（回溯算法）问题介绍八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 思路分析 第一个皇后先放第一行第一列 第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适 继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到 然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 代码实现说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列 定义变量 方法：将皇后摆放位置输出 方法：检测该皇后是否和前面已经摆放的皇后冲突 方法：放置皇后 main方法测试 "},{"title":"排序算法","date":"2021-06-01T16:00:00.000Z","url":"/2021/06/02/202162-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"排序算法介绍排序也称排序算法 (Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。 排序的分类 内部排序： 指将需要处理的所有数据都加载到内部存储器中进行排序 外部排序： 数据量过大，无法全部加载到内存中，需要借助外部存储进行排序 算法的时间复杂度度量一个程序(算法)执行时间的两种方法事后统计的方法这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快 事前估算的方法通过分析某个算法的时间复杂度来判断哪个算法更优 时间频度一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n) 例如： 计算1-100所有数字之和，设计两种算法 T(n)=n+1;(表示运行了n+1次) T(n)=1 计算时间复杂度 结论： 2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略1)2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略 3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略 结论： 1)2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10 1)n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20 结论： 随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明 这种情况下, 5和3可以忽略 而n^3+5n 和 6n^3+4n ，执行曲线分离，说明多少次方式关键 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度 T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。 计算时间复杂度的方法： 用常数1代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1 修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n² 去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²） 常见的时间复杂度 常数阶O(1)无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1) 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度 对数阶O(log2n) 在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n) 。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) 线性阶O(n) 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度 线性对数阶O(nlogN) 线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN) 平方阶O(n²) 平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(nn)，即 O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(mn) 立方阶O(n³)、K次方阶O(n^k)参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似 平均时间复杂度和最坏时间复杂度 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。 平均时间复杂度和最坏时间复杂度是否一致，和算法有关 算法的空间复杂度类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间 冒泡排序冒泡排序介绍冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 代码实现 冒泡排序优化因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较 选择排序选择排序介绍选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的 选择排序思想选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列 代码实现 插入排序插入排序介绍插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的 插入排序思想插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表 代码实现 希尔排序介绍简单插入排序存在的问题数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是： {2,3,4,5,6,6} {2,3,4,5,5,6} {2,3,4,4,5,6} {2,3,3,4,5,6} {2,2,3,4,5,6} {1,2,3,4,5,6} 说明当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响 希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。 希尔排序法基本思想希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 代码实现(交换式) 代码实现(移位式) 快速排序介绍快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 代码实现 归并排序介绍归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 代码实现 基数排序介绍基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法 基数排序(Radix Sort)是**桶排序**的扩展 基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较 基本思想将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列 将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序 代码实现"},{"title":"链表&栈","date":"2021-05-28T16:00:00.000Z","url":"/2021/05/29/%E9%93%BE%E8%A1%A8&%E6%A0%88/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"链表链表是有序的列表，但是在内存中储存如下 链表是以结点的方式来存储，是链式存储 每个节点包含data域，next域：指向下一个节点 链表的节点不一定是连续存储 链表分带头节点的链表和没有头节点的链表 单链表单链表（带头结点）逻辑结构示意图 应用实例使用带head头的单向链表实现 –水浒英雄排行榜管理 添加添加英雄时，直接添加到链表的尾部 先创建一个head头节点，作用就是表示单链表的头 后面每添加一个节点，就直接加入到链表的最后 遍历 通过一个辅助变量遍历，帮助遍历整个链表 代码实现 添加（优化）添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，添加失败，并给出提示) 首先找到新添加的节点的位置, 是通过辅助变量(指针), 通过遍历来解决 新的节点.next = temp.next 将temp.next = 新的节点 代码实现加入实现方法 测试 修改思路 先找到该节点，通过遍历 修改英雄的属性 temp.name=newHeroNode.name; temp nickname=newHeroNode.nickname 加入实现方法 测试 删除节点思路分析 我们先找到 需要删除的这个节点的前一个节点 temp temp.next = temp.next.next 被删除的节点，将不会有其它引用指向，会被垃圾回收机制回收 代码实现加入实现方法 测试 练习一求单链表中有效结点的个数 测试 练习二查找单链表中倒数第k个节点 测试 练习三将单链表反转 测试 练习四 逆序打印单链表 测试 双向链表管理单向列表的缺点 单向链表，查找的方向只能是一个方向，而双向链 表可以向前或者向后查找 单向链表不能自我删除，需要靠辅助节点 ，而双向 链表，则可以自我删除，所以前面我们单链表删除 时节点，总是找到temp,temp是待删除节点的前一 个节点 应用实例使用带head头的双向链表实现 –水浒英雄排行榜 代码实现 单向环形链表 约瑟夫问题Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。 提示： 用一个不带头节点的循环链表来处理Josephu问题：先构成一个有n个节点的单循环链表，然后由k节点起从1开始计数，计到m时，对应节点从链表中删除，然后再从被删除节点的下一个节点又从1开始计数，直到最后一个结点从链表中删除算法结束。 思路分析构建一个单向环形链表 先创建第一个节点, 让 first 指向该节点，并形成环形 后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可 遍历环形链表 先让一个辅助指针(变量) curBoy，指向first节点 然后通过一个while循环遍历 该环形链表即可 curBoy.next == first 结束 步骤： 需求创建一个辅助指针(变量)helper,事先应该指向环形链表的最后这个节点 取出节点前，先让 first 和 helper 移动 k - 1次 这时就可以将first 指向节点取出 first = first .next helper.next = first 原来first 指向的节点就没有任何引用，就会被回收 栈（stack）介绍 栈是一个先入后出的有序列表 栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊的线性表。允许插入和删除的一端，为变化的一端，成为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom) 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除 入栈 出栈 应用场景 子程序的调用，在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中 处理递归调用：和子程序的调用类似，只是除了存储下一个指令的地址外，也将参数、区域变量等数据存入堆栈中 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决) 二叉树的遍历 图形的深度优先(depth-first)搜索法 数组模拟栈的使用使用数组模拟栈的使用，由于栈是一种有序列表，可以使用数组的结构来存储栈的数据内容 思路分析 使用数组来模拟 定义一个top来表示栈顶，初始化为-1 入栈的操作：当有数据加入到栈时，top++;stack[top]=data; 出栈的操作：int value=stack[top];top–,return value 代码实现 链表模拟栈的使用栈实现综合计算器(中缀表达式)思路分析 通过一个 index 值（索引），来遍历我们的表达式 创建两个栈，一个存放数字，一个存放操作符. 如果我们发现是一个数字,就直接入数栈. 如果发现扫描到是一个符号, 就分如下情况: 如果发现当前的符号栈为 空，就直接入栈 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符， 就需要从数栈中pop出两个数,再从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈. 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行. 最后在数栈只有一个数字，就是表达式的结果. 代码实现 前缀、中缀、后缀表达式(逆波兰表达式)前缀表达式(波兰表达式)前缀表达式又称为逆波兰表达式，前缀表达式的操作符位于操作数之前 例如：(3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 前缀表达式的计算机求值从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 针对前缀表达式求值步骤如下: 从右至左扫描，将6、5、4、3压入堆栈 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈 最后是-运算符，计算出35-6的值，即29，由此得出最终结果 中缀表达式中缀表达式就是常见的运算表达式 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式) 后缀表达式后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后 例如：(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 – 后缀表达式的计算机求值从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 步骤： 初始化两个栈：运算符栈s1和储存中间结果的栈s2； 从左至右扫描中缀表达式； 遇到操作数时，将其压s2； 遇到运算符时，比较其与s1栈顶运算符的优先级： 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； 否则，若优先级比栈顶运算符的高，也将运算符压入s1； 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较； 遇到括号时： 如果是左括号“(”，则直接压入s1 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 重复步骤2至5，直到表达式的最右边 将s1中剩余的运算符依次弹出并压入s2 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 例如：1 + ( ( 2 + 3 )× 4) - 5转为后缀表达式 图示： 逆波兰计算器（计算后缀表达式）输入一个后缀表达式(逆波兰表达式)，使用栈(Stack)，计算其结果 支持对整数的计算 思路分析例如：(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 – 步骤： 从左至右扫描，将3和4压入堆栈； 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈； 将5入栈； 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 将6入栈； 最后是-运算符，计算出35-6的值，即29，由此得出最终结果 代码实现 逆波兰计算器(中缀转后缀表达式后计算)思路分析和后缀表达式的计算机求值步骤相同 代码实现"},{"title":"稀疏数组&队列","date":"2021-05-26T16:00:00.000Z","url":"/2021/05/27/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84&%E9%98%9F%E5%88%97/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"数据结构和算法概述关系程序=数据结构+算法 数据结构是算法的基础 实际问题五子棋程序 棋盘：二维数组=&gt;（稀疏数组）=&gt;写入文件【存档功能】 读取文件=&gt;稀疏数组=&gt;二维数组=&gt;棋盘【接上局】 约瑟夫(Josephu)问题(丢手帕问题) 问题为：设编号为1，2，3…n的·n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m的那个人出列，他的下一位又从1开始报数，数到m的那个人又出列，以此类推，直到所有人出列为止，由此产生一个出队编号的序列 提示：用一个不带头结点的循环链表来处理Josephu问题：先构成一个有n个结点的单循环链表(单向环形链表)，然后由k结点起从1开始计数，计到m时，对应节点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。 总结：完成约瑟夫问题，需要使用到单向循环链表 其他算法常见问题 修路问题=&gt;最小生成树（加权值）【数据结构】+普利姆算法 最短路径问题=&gt;图+佛洛依德算法 汉诺塔=&gt;分支算法 八皇后问题=&gt;回溯法 线性结构&amp;非线性结构数据结构包括：线性结构和非线性结构 线性结构最常用的数据结构，特点是数据元素之间存在一对一的线性关系。 线性结构有两种不同的存储结构：**顺序存储结构(数组)和链式存储结构(链表)**。 顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息 线性结构常见的有：数组、队列、链表和栈 非线性结构非线性结构包括：二维数组、多维数组、广义表、树结构、图结构 稀疏数组和队列稀疏(sparsearray)数组实际需求五子棋程序中，存盘退出和继续上盘的功能 分析问题可以将五子棋盘看成是一个二维数组来记录棋盘。但是，该二维数组中，很多棋盘上对应的位置并没有数据，因此记录了很多为没有意义的数据。 处理方法当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 记录数组一共有几行几列，有多少个不同的值 把具有不同值的元素的行列及值记录在一个小规模数组中，从而缩小程序规模 应用实例 使用稀疏数组，来保留类似前面的二维数组(棋盘，地图等等) 把稀疏数组存盘，并且可以从新恢复原来的二维数组数 思路分析二维数组转稀疏数组的思路 遍历原始的二维数组，得到有效数据的个数sum 根据sum就可以创建稀疏数组sparseArr int[sum+1] [3] 将二维数组的有效数据存入到稀疏数组 稀疏数组转原始的二维数组的思路 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 再读取稀疏数组后几行的数据，并赋给原始的二维数组即可 代码实现 队列介绍队列是一个有序列表，可以用数组或是链表来实现 遵循先入先出的原则：先存入的队列的数据，要先取出。后存入的数据要后取出 数组模拟队列思路队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下，其中MaxSize是该队列的最大容量 因为队列的输出、输入是分别从前后端来处理的，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据输入而改变 当我们将数据存入队列时称为“addQueue”,addQueue的处理需要有两个步骤： 将位置向后移：rear+1，当front==rear时，队列数据为空。 若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear==maxSize-1，表示队列数据已满 代码实现 问题分析&amp;优化问题：假溢出现象 因为队列遵从从队尾存入数据，从队头取数据，所以出队部分的空间就不能继续存入新的数据，此时队列有多余的空间，却不能存入值，这种现象就叫做假溢出现象 将这个数组使用算法，改进成一个环形队列（取模：%） 优化：数组模拟环形队列环形队列思想将普通队列想象成逻辑上的首位相连的圆环，把这个叫循环队列，在循环队列中，当队列为空时，有front=rear，而当所有队列空间全占满时，也有front=rear。为了区别这两种情况，规定循环队列最多只能有MaxSize-1个队列元素，当循环队列中只剩下一个空存储单元时，队列就已经满了。因此，队列判空的条件是front=rear，而队列判满的条件是front=(rear+1)%MaxSize。 分析思路 front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，初值为0 rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定，初值为0 队列满时条件为：(rear+1)%maxSize==front 当队列为空时：rear==front 这样分析时，队列中有效数据的个数：(rear+maxSize-front)%maxSize 这样就可以修改得到一个数组模拟的环形队列 代码实现"},{"title":"SSM整合","date":"2021-05-24T16:00:00.000Z","url":"/2021/05/25/SSM%E6%95%B4%E5%90%88/","categories":[["SSM","/categories/SSM/"]],"content":"SSM整合导包Spring SpringMVC MyBatis 其他 写配置web.xml配置 Spring配置 SpringMVC MyBatis配置整合关键配置(写在Spring.xml中) 目录结构"},{"title":"Mybatis","date":"2021-05-16T16:00:00.000Z","url":"/2021/05/17/Mybatis/","categories":[["ssm","/categories/ssm/"]],"content":"简介 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录 JDBC中，SQL夹在Java代码块里，耦合度高导致硬编码内伤。–维护不易且实际开发需求中sql是有变化，频繁修改的情况多见。 Hibernate和JPA中，长难复杂SQL，对于Hibernate而言处理也不容易。内部自动生产的SQL，不容易做特殊优化。基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。导致数据库性能下降。 对于核心开发人员而言，核心sql还是需要自己优化，sql和java代码分开，功能边界清晰，一个专注业务，一个专注数据。 环境搭建 创建一个java工程 创建测试库，测试表，以及封装数据的javaBean，和操作数据库的dao接口 用MyBatis操作数据库 导包 mybatis-3.4.1.jar mysql-connector-java-8.0.23.jar log4j-1.2.17.jar（日志包：在MyBatis关键的环节就会有日志打印，依赖类路径下的log4j.xml配置文件） 写配置 第一个配置文件：称为mybatis的全局配置文件，指导mybatis如何正确运行，比如连接向哪个数据库 第二个配置文件：编写每一个方法都如何向数据库发送sql语句，如何执行。相当于接口的实现类 将mapper的namespace属性改为接口的全类名 配置细节 此时写的dao接口实现文件，mybatis默认是不知道的，需要在全局配置文件中注册 测试 根据全局配置文件先创建一个 sqlSessionFactory中获取sqlSession对象操作数据库即可 目录结构： 全局配置文件：mybatis-config.xml；指导mybatis正确运行的一些全局设置 SQL映射文件：EmployeeDao.xml；相当于是对Dao接口的一个实现描述细节： 获取到的是接口的代理对象；mybatis自动创建的 SqlSessionFactory和SqlSession： SqlSessionFactory创建SqlSession对象，Factory只new一次就行 SqlSession：相当于connection和数据库进行交互的，和数据库的一次会话，就应该创建一个新的sqlSession 全局配置文件（Configuration配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） properties(属性)和Spring的context：property-placeholder作用相同：引用外部配置文件 resource:从类路径下开始引用 url:引用磁盘路径或者网络路径的资源 daconfig.properties中： settings(设置)settings这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为 typeAliases(类型命名)类型别名:为常用的类型（javaBean）起别名 mappers(映射器)写好的sql映射文件需要使用mappers注册进来 class:直接引用接口的全类名(需要将xml放在和dao接口同目录下，而且文件名和接口名一致)resource:在类路径下找sql映射文件url:可以从磁盘或者网络路径引用 EmployeeDao.xml class的另一种用法： EmployeeDaoAnnotation.xml 推荐配合使用， 重要的dao可以写配置简单的dao直接标注解 SQL映射文件映射文件指导着MyBatis如何进行数据库增删改查，有着非常重要的意义 映射文件中能写的所有标签： cache:命名空间的二级缓存配置 cache-ref:其他命名空间缓存配置的引用 resultMap:自定义结果集映射 parameterMap:已废弃！老式风格的参数映射 sql:抽取可重用语句块 delete、update、insert、select:增删改查 delete、update、insert属性： 参数获取自增主键若数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），则可以设置 useGeneratedKeys=”true”**，然后再把 **keyProperty 设置到目标属性上。 因为employee在new对象的时候就是null值，所以获取id时也为空值。 让MyBatis自动的将自增id赋给传入的employee对象的id属性： useGeneratedKeys=”true”：使用自动生成的主键 keyProperty=””：将刚才自增的id封装给哪个属性 获取非自增主键而对于不支持自增型主键的数据库（例如 Oracle），则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用 参数传递单个参数基本类型：#{随便写} 多个参数任意多个参数，都会被MyBatis重新包装成一个Map传入。Map的key是param1，param2，0，1…，值就是参数的值。 错误取值：#{参数名} 正确写法：0，1（参数索引）或param1,param2（第几个参数paramN…） 原因：只要传入了多个参数：myBatis会自动的将这些参数封装在一个map中，封装时使用的key就是参数的索引和参数的param优化写法：在方法参数前使用@Param(“参数名”)，为参数指定id POJO当这些参数属于我们业务POJO时，我们直接传递POJO 取值：#{pojo的属性名} Map我们也可以封装多个参数为map，直接传递 取值：#{key} #{key}：获取参数的值，预编译到SQL中。安全。 ${key}：获取参数的值，拼接到SQL中。有SQL注入问题。ORDER BY ${name}(在不支持预编译的位置要进行取值就用${key}) 参数处理#{key}取值的时候可以设置一些规则： 支持的属性：javaType、jdbcType、mode、numericScale、 resultMap、typeHandler、jdbcTypeName、expression 注：JDBC 要求，如果一个列允许使用 null 值，并且会使用值为 null 的参数，就必须要指定 JDBC 类型（jdbcType） selectSelect元素来定义查询操作。 insert、update、delete ResultMap constructor- 用于在实例化类时，注入结果到构造方法中 idArg - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能 arg - 将被注入到构造方法的一个普通结果 id – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能 result – 注入到字段或 JavaBean 属性的普通结果 association– 一个复杂类型的关联；许多结果将包装成这种类型 嵌套结果映射 – 关联可以是 resultMap 元素，或是对其它结果映射的引用 collection– 一个复杂类型的集合 嵌套结果映射 – 集合可以是 resultMap 元素，或是对其它结果映射的引用 discriminator– 使用结果值来决定使用哪个 resultMap case– 基于某些值的结果映射 嵌套结果映射 – case 也是一个结果映射，因此具有相同的结构和元素；或者引用其它的结果映射 id&amp;resultid 和 result 映射一个单独列的值到简单数据类型(字符串,整型,双精度浮点数,日期等)的属性或字段 association(关联)POJO中的属性可能会是一个对象 可以使用联合查询，并以级联属性的方式封装对象 使用association标签定义对象封装规则 嵌套结果集 分段查询 select:调用目标的方法查询当前属性的值 column:将指定列的值传入目标方法 延迟加载 Collection-集合类型&amp;嵌套结果集 分布查询 动态sqlif标签if 标签通常用于 WHERE 语句、UPDATE 语句、INSERT 语句中，通过判断参数值来决定是否使用某个查询条件、判断是否更新某一个字段、判断是否插入某个字段的值。 foreach标签foreach 标签主要用于构建 in 条件，可在 sql 中对集合进行迭代。也常用到批量删除、添加等操作中。 collection:指定要遍历的集合的key close:以什么结束 index:索引 如果遍历的是list： index:指定的变量保存了当前索引 item:保存当前遍历的元素的值 如果便利的是map: index：指定的变量就是保存了当前遍历的元素的key item：就是保存当前遍历的元素的值 item:每次遍历出的元素起一个变量名方便引用 open:以什么开始 separator:每次遍历元素的分隔符 choose标签MyBatis 提供了 choose 元素，按顺序判断 when 中的条件出否成立，如果有一个成立，则 choose 结束。当 choose 中所有 when的条件都不满则时，则执行 otherwise 中的 sql。类似于 Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。 if 是与(and)的关系，而 choose 是或（or）的关系。 set标签没有使用 if 标签时，如果有一个参数为 null，都会导致错误。当在 update 语句中使用 if 标签时，如果最后的 if 没有执行，则或导致逗号多余错误。使用 set 标签可以将动态的配置 set关键字，和剔除追加到条件末尾的任何不相关的逗号。 trim标签格式化输出，可以设置或忽略前后缀 where标签 当 name 值为 null 时，查询语句会出现 “WHERE AND” 的情况，解决该情况除了将”WHERE”改为“WHERE 1=1”之外，还可以利用 where标签。这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以 AND 或 OR 开头的，则它会剔除掉。 抽取可重用sql 在之后的方法中加入： 即可省略重复的sql语句 缓存暂时的存储一些数据；加快系统的查询速度 MyBatis缓存机制： Map；能保存查询出的一些数据； 一级缓存：线程级别的缓存；本地缓存；SqlSession级别的缓存； 二级缓存：全局范围的缓存；除过当前线程；SqlSession能用外其他也可以使用； 一级缓存MyBatis：SqlSesion级别的缓存；默认存在； 机制：只要之前查询过的数据，mybatis就会保存在一个缓存中（Map）；下次获取直接从缓存中拿； 一级缓存失效的情况： 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存 二级缓存namespace级别的缓存 一级缓存；SqlSession关闭或者提交以后，一级缓存的数据会放在二级缓存中；MyBatis默认关闭，需手动开启 配置某个dao.xml文件，让其使用二级缓存 缓存原理 全局setting的cacheEnable：配置二级缓存的开关。一级缓存一直是打开的。 select标签的useCache属性：配置这个select是否使用二级缓存。一级缓存一直是使用的 sql标签的flushCache属性：增删改默认flushCache=true。sql执行以后，会同时清空一级和二级缓存。查询默认flushCache=false。 sqlSession.clearCache()：只是用来清除一级缓存。 当在某一个作用域 (一级缓存Session/二级缓存Namespaces) 进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被clear。 整合第三方缓存整合ehcache 导包 ehcache-core-2.6.8.jar(ehcache核心包) mybatis-ehcache-1.0.3.jar(ehcache的整合包) slf4j-api-1.7.21.jar slf4j-log4j12-1.7.21.jar ehcache要工作有一个配置文件 文件名叫ehcache.xml；放在类路径的根目录下 在mapper.xml中配置使用自定义的缓存 别的dao还要用这个缓存 缓存引用cache-ref "},{"title":"SpringMVC2","date":"2021-05-15T16:00:00.000Z","url":"/2021/05/16/SpringMVC2/","categories":[["ssm","/categories/ssm/"]],"content":"数据绑定流程： Spring MVC 主框架将 ServletRequest 对象及目标方法的参数实例传递给 WebDataBinderFactory 实例，以创建 DataBinder 实例对象 DataBinder 调用装配在 Spring MVC 上下文中的 ConversionService 组件进行数据类型转换、数据格式化工作。将 Servlet 中的请求信息填充到参数对象中 调用 Validator 组件对已经绑定了请求消息的参数对象进行数据合法性校验，并最终生成数据绑定结果 BindingData 对象 Spring MVC 抽取 BindingResult 中的入参对象和校验错误对象，将它们赋给处理方法的响应参数 数据转换Spring MVC 上下文中内建了很多转换器，可完成大多数 Java 类型的转换工作 自定义类型转换器 ConversionService:是一个接口。它里面有Converter（转换器）进行工作 Converter是ConversionService中的组件 实现过程： 自定义的Converter得放进ConversionService 中 将WebDataBinder中的ConversionService设置成我们这个加了自定义类型转换器的ConversionService 步骤： 实现Converter接口，写一个自定义的类型转换器 配置出ConversionService 让SpringMVC用自定义的ConversionService 源码上WebDataBinder上的ConversionService组件就会被替换 &lt;mvc:annotation-driven /&gt; &lt;mvc:annotation-driven /&gt; 会自动注册RequestMappingHandlerMapping 、RequestMappingHandlerAdapter 与 ExceptionHandlerExceptionResolver 三个bean。 还将提供以下支持： 支持使用 ConversionService 实例对表单参数进行类型转换 支持使用 @NumberFormat annotation、@DateTimeFormat注解完成数据类型的格式化 支持使用 @Valid 注解对 JavaBean 实例进行 JSR 303 验证 支持使用 @RequestBody 和 @ResponseBody 注解 数据格式化 FormattingConversionServiceFactroyBean 内部已经注册了 : NumberFormatAnnotationFormatterFactroy：支持对数字类型的属性使用 @NumberFormat 注解 JodaDateTimeFormatAnnotationFormatterFactroy：支持对日期类型的属性使用 @DateTimeFormat 注解 装配了 FormattingConversionServiceFactroyBean 后，就可以在 Spring MVC 入参绑定及模型数据输出时使用注解驱动了&lt; mvc:annotation-driven/&gt;默认创建的ConversionService 实例即为 FormattingConversionServiceFactroyBean 例 数据校验只做前端校验是不安全的；在重要数据一定要加上后端验证 JSR303 JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 中 JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证 后端校验 导入校验框架的jar包–Hibernate Validator 有几个带el的jar不导入；tomcat中有；如果tomcat的版本是* 7.0以下；tomcat7.0以上el表达式比较强大 ，如果是7.0以下将带el的几个jar放在tomcat的lib文件夹下 只需要给javaBean的属性添加上校验注解 在SpringMVC封装对象的时候，告诉SpringMVC这个javaBean需要校验 校验结果 给需要校验的javaBean后面紧跟一个BindingResult。这个BindingResult就是封装前一个bean的校验结果 来到页面使用form:errors取出错误信息即可 Hibernate-Validator拓展 国际化定制自己的错误消息显示 编写国际化配置文件 让SpringMVC管理国际化资源文件 来到页面取值 拦截器SpringMVC提供了拦截器机制；允许运行目标方法之前进行一些拦截工作，或者目标方法运行之后进行一些其他处理。 preHandle：在目标方法运行之前调用 postHandle：在目标方法运行之后调用 afterCompletion：在请求整个完成之后 步骤： 实现HandlerInterceptor接口 配置拦截器 拦截器的运行流程 正常运行流程： 拦截器的preHandle——目标方法—–拦截器postHandle—–页面——-拦截器的afterCompletion 其他流程： 只要preHandle不放行就没有以后的流程 只要放行了，afterCompletion都会执行 多个拦截器： 正常流程： 异常流程： MySecondInterceptor不放行；但是他前面已经放行了的拦截器的afterCompletion总会执行 流程： filter的流程； 拦截器的preHandle：是按照顺序执行 拦截器的postHandle：是按照逆序执行 拦截器的afterCompletion：是按照逆序执行； 已经放行了的拦截器的afterCompletion总会执行； 异常处理默认就是这几个 HandlerExceptionResolver ExceptionHandlerExceptionResolver ResponseStatusExceptionResolver DefaultHandlerExceptionResolver 如果异常解析器都不能处理就直接抛出去 配置文件中写入 自定义异常 controller 告诉SpringMVC这个方法专门处理这个类发生的异常 给方法参数中写上一个Exception，用来接收发生的异常 要携带异常信息不能给参数位置写model 返回ModelAndView即可 如果有多个@ExceptionHandler都能处理这个异常，精确优先 SpringMVC的运行流程 所有请求，前端控制器（DispatcherServlet）收到请求，调用doDispatch进行处理 根据HandlerMapping中保存的请求映射信息找到，处理当前请求的，处理器执行链（包含拦截器） 根据当前处理器找到他的HandlerAdapter（适配器） 拦截器的preHandle先执行 适配器执行目标方法，并返回ModelAndView ModelAttribute注解标注的方法提前运行 有注解 没注解 看是否是Model、Map以及其他的 如果是自定义类型 从隐含模型中看有没有，如果有就从隐含模型中拿 如果没有，再看是否SessionAttributes标注的属性，如果是从Session中拿，如果拿不到会抛异常 都不是，就利用反射创建对象 拦截器的postHandle执行 处理结果；（页面渲染流程） 如果有异常使用异常解析器处理异常；处理完后还会返回ModelAndView 调用render进行页面渲染 视图解析器根据视图名得到视图对象 视图对象调用render方法 执行拦截器的afterCompletion SpringMVC与Spring整合SpringMVC和Spring整合的目的；分工明确 SpringMVC的配置文件就来配置和网站转发逻辑以及网站功能有关的（视图解析器，文件上传解析器，支持ajax，xxx） Spring的配置文件来配置和业务有关的（事务控制，数据源，xxx） SpringMVC和Spring使用同一个容器&lt;import resource=*”spring.xml”*/&gt;：可以合并配置文件 SpringMVC和Spring分容器web.xml中配置 spring.xml中配置 springMVC.xml中配置 Spring是一个父容器，SpringMVC是一个子容器； 子容器还可以引用父容器的组件； 父容器不能引用子容器的组件；"},{"title":"SpringMVC1","date":"2021-05-14T16:00:00.000Z","url":"/2021/05/15/SpringMVC1/","categories":[["ssm","/categories/ssm/"]],"content":"概要本文章基于Spring4.x版本的SpringMVC,源码上与Spring5会有些许不同 Spring为展现层提供的基于MVC设计理念的优秀的Web框架，是目前最主流的MVC框架之一 SpringMVC通过一套MVC注解，让POJO成为处理请求的控制器，而无需实现任何接口 采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性 mvc在b/s系统下的应用： SpringMVC原理流程图： 前端控制器 DispatcherServlet 作用：接收请求，响应，也是中央转发器处理器映射器 HandlerMapping 作用：根据url查找Handler 处理器适配器 HandlerAdapter 作用：按照特定规则去执行Handler，规则即HandlerAdapter要求的规则 注意：编写Handler时需要按HandlerAdapter要求去编写，这样适配器才可以去正确执行Handler 视图解析器 ViewResolver 作用：根据逻辑视图解析成真正的视图（view） 视图 View View 是一个接口，实现类支持不同的view类型（jsp，FreeMarker，pdf，excel…) SpringMVC-Hello World步骤： 加入jar包 commons-logging-1.1.3.jar spring-aop-4.0.0.RELEASE.jar spring-beans-4.0.0.RELEASE.jar spring-context-4.0.0.RELEASE.jar spring-core-4.0.0.RELEASE.jar spring-expression-4.0.0.RELEASE.jar spring-web-4.0.0.RELEASE.jar spring-webmvc-4.0.0.RELEASE.jar 在web.xml中配置DispatcherServlet 加入Spring MVC的配置文件 编写处理请求的处理器，并标记为处理器 编写视图 @RequestMapping映射请求 Spring MVC使用@RequestMapping注解为控制器指定可以处理哪些 URL 请求 在控制器的类定义及方法定义处都可标注 类定义处：为当前类的所有方法准备一个基准路径 方法处：提供进一步的细分映射信息。相对于类定义处的 URL。若类定义处未标注 @RequestMapping，则方法处标记的 URL 相对于 WEB 应用的根目录 DispatcherServlet 截获请求后，就通过控制器上 @RequestMapping 提供的映射信息确定请求所对应的处理方法。 映射请求参数、请求方法或请求头 @RequestMapping 除了可以使用请求 URL 映射请求外，还可以使用请求方法、请求参数及请求头映射请求 RequestMapping的其他属性method限定请求方式：GET、POST 例： params规定请求参数 params:和headers支持简单表达式 param1：表示请求必须包含名为param1的请求参数 表示发送请求的时候必须带上一个名为username的参数，否则会404报错。 ！param1:表示请求不能包含名为param1的请求参数 表示发送请求的时候不能带上一个名为username的参数 param1!=value1:表示请求包含名为param1的请求参数，但其值不能为value1 表示发送请求的时候，携带的username值必须不是123（不带username或者username的值不是value） {“param1=value1”,”param2”}:请求必须包含名为param1和param2的请求参数 表示请求参数必须满足：username不是123，必须有pwd的值，不能有age headers使用User-Agent限制浏览器访问 consumes只接受内容类型是哪种的请求，规定请求头中的Content-Type produces告诉浏览器返回的内容类型是什么，给响应头中加上Content-Type:text/html;charset=utf-8 @RequestMapping模糊匹配（Ant风格）URL地址可以写模糊的通配符 通配符 作用 ？ 能代替一个字符 * 能代替多个字符，和一层路径 ** 能代替多层路径 例： 映射请求参数请求处理方法签名 Spring MVC 通过分析处理方法的签名，将 HTTP 请求信息绑定到处理方法的相应参数中 Spring MVC 对控制器处理方法签名的限制是很宽松的，几乎可以按喜欢的任何方式对方法进行签名 必要时可以对方法及方法参数标注相应的注解（ @PathVariable 、@RequestParam、@RequestHeader 等）、Spring MVC 框架会将 HTTP 请求的信息绑定到相应的方法入参中，并根据方法的返回值类型做出相应的后续处理。 @PathVariable-映射URL绑定的占位符 带占位符的URL是Spring3.0新增的功能，该功能在SprngMVC向REST目标挺进发展过程中具有里程碑的意义 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过 @PathVariable(“xxx”) 绑定到操作方法的入参中。 例 @RequestParam-获取请求参数值在处理方法参数处使用 @RequestParam 可以把请求参数传递给请求方法 value:参数名 required:是否必须。默认为true，表示请求参数中必须包含对应的参数，若不存在，将抛出异常 defaultValue:默认值，没带参数默认为null 对于路径/book/{user}?user=admin @RequestHeader-获取请求报头的属性值 请求头包含了若干个属性，服务器可据此获知客户端的信息，通过 @RequestHeader 即可将请求头中的属性值绑定到处理方法的参数中 @CookieValue-获取请求中的Cookie值 示例 使用POJO对象获取请求参数值 Spring MVC 会按请求参数名和 POJO 属性名进行自动匹配，自动为该对象填充属性值。支持级联属性 SpringMVC会自动封装Book的属性值 提交的数据可能会乱码： 请求乱码： GET请求： 改Server.xml，在8080端口处添加：URIEncoding=”UTF-8” POST请求： 在第一次获取请求参数之前设置 request.setCharacterEncoding(“UTF-8”); 响应乱码： response.setContentType(“text.html;charset=utf-8”) 使用原生API作为参数SpringMVC可以直接在参数上写原生API HttpServletRequest HttpServletResponse HttpSession java.security.Principal Locale ：国际化有关的区域信息对象 InputStream ServletInputStream inputStream = request.getInputStream(); OutputStream ServletOutputStream outputStream = response.getOutputStream(); Reader BufferedReader reader = request.getReader(); Writer PrintWriter writer = response.getWriter(); 处理模型数据SpringMVC除了在方法上原生的request和session外还能怎么样把数据带给页面? 可以在方法处传入Map、或者Model或者ModelMap,给这些参数里面保存的所有数据都会放在域中，可以在页面获取 关系： Map,Model,ModelMap,最终都是BindingAwareModelMap在工作：相当于给BindingAwareModelMap中保存的东西都会被放在请求域中 Map属于jdk中的interface model属于spring中的interface ModelMap属于Map旗下，是继承于LinkedHashMap的Class ExtendedModelMap属于继承于ModelMap实现Model接口的Class BindingAwareModelMap继承于ExtendedModelMap的Class Spring MVC 提供了以下几种途径输出模型数据： ModelAndView: 处理方法返回值类型为 ModelAndView 时, 方法体即可通过该对象添加模型数据 Map 及 Model: 入参为 org.springframework.ui.Model、org.springframework.ui.ModelMap 或 java.uti.Map 时，处理方法返回时，Map 中的数据会自动添加到模型中。 @SessionAttributes: 将模型中的某个属性暂存到 HttpSession 中，以便多个请求之间可以共享这个属性 @ModelAttribute: 方法入参标注该注解后, 入参的对象就会放到数据模型中 ModelAndView控制器处理方法的返回值如果为 ModelAndView, 则其既包含视图信息，也包含模型数据信息。 添加模型数据 设置视图 例 结果：请求域和session域中都有值 Map&amp;ModelSpring MVC 在内部使用了一个 org.springframework.ui.Model 接口存储模型数据 步骤： Spring MVC 在调用方法前会创建一个隐含的模型对象作为模型数据的存储容器。 如果方法的参数为 Map 或 Model 类型，Spring MVC 会将隐含模型的引用传递给这些参数。在方法体内，开发者可以通过这个参数对象访问到模型中的所有数据，也可以向模型中添加新的属性数据 例： Model Map @SessionAttributes 若希望在多个请求之间共用某个模型属性数据，则可以在控制器类上标注一个 @SessionAttributes, Spring MVC 将在模型中对应的属性暂存到 HttpSession 中 @SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外，还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中 例 并不推荐使用@SessionAttribute，可能会引发异常，给Session中放数据请使用原生API。 ModelAttribute 在方法定义上使用 @ModelAttribute 注解：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了 @ModelAttribute 的方法 在方法的参数前使用 @ModelAttribute注解： 可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数绑定到对象中，再传入参数 将方法参数对象添加到模型中 全字段更新问题实际开发场景中对于修改的属性，并不是全字段修改，只会修改部分字段 不修改的字段可以在页面进行展示但是不要提供修改输入框 为了简单，Controller直接在参数位置来写对象 SpringMVC为我们自动封装；（没有带的值是null） 如果接下来调用了一个全字段更新的dao操作；会将其他的字段可能变为null 全字段更新时，如何只更新页面携带数据 方法一： 修改Dao，但非常麻烦 方法二： 在保存对象的方法上加上@ModelAttribute,标注的方法会提前运行并把方法的运行结果放在隐含模型中，同时会使用一个key：如果@ModelAttribute(“key”)指定了，就用指定的key,如果没有指定就用返回值类型的首字母小写作为key 在更新方法中的参数前加上@ModelAttribute注解，key的值需要和保存对象的方法中保持一致。它可以让SpringMVC不创建对象，直接从中先取出保存的对象的信息 将请求中所有与对象对应的属性一一设置过来 使用刚才取出的对象，设置属性值（请求参数带了哪些值就覆盖之前的值） 带了的字段就改为携带的值，没带的字段就保持之前的值 将之前查到的，并且封装了请求参数的对象。进行保存 例 视图解析SpringMVC 内部最终会将返回的参数及视图名字封装成一个 ModelAndView 对象，这个对象包含两个部分：Model 是一个 HashMap 集合，View 一般则是一个 String 类型记录要跳转视图的名字或者是视图对象 SpringMVC 内部最终是借助这个 ModelAndView 对象里面的 View 来选取视图解析器，解析出视图，然后将 Model 里面的键值写进 requestScope 里面，最终呈现给客户端渲染后的视图 视图 视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户 为了实现视图模型和具体实现技术的解耦，Spring 在 org.springframework.web.servlet 包中定义了一个高度抽象的 View 接口 视图对象由视图解析器负责实例化。由于视图是无状态的，所以他们不会有线程安全的问题 常用的视图实现类 视图解析器 SpringMVC 为逻辑视图名的解析提供了不同的策略，可以在 Spring WEB 上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类 视图解析器的作用比较单一：将逻辑视图解析为一个具体的视图对象 所有的视图解析器都必须实现 ViewResolver 接口 常用的视图解析器实现类 可以选择一种视图解析器或混用多种视图解析器 每个视图解析器都实现了 Ordered 接口并开放出一个 order 属性，可以通过 order 属性指定解析器的优先顺序，order 越小优先级越高 •SpringMVC 会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则将抛出 ServletException 异常 forward指定转发操作 redirect指定重定向操作 jstlView便捷国际化导入jstl的时候会自动创建为一个jstlView，可以快速方便的支持国际化功能 javaWeb国际化步骤: 得到一个Locale对象 使用ResourceBundle绑定国际化资源文件 使用ResourceBundle.getString(“key”)；获取到国际化配置文件中的值 web页面的国际化，fmt标签库来做 &lt;fmt: setLocale&gt; &lt;fmt:setBundle &gt; &lt;fmt: message&gt; 用jstlView: 让Spring管理国际化资源就行 直接去页面使用&lt;fmt: message&gt;； 自定义视图&amp;视图解析器自定义视图和视图解析器的步骤： 编写自定义的视图解析器，和视图实现类 视图解析器必须放在ioc容器中，让其工作，能创建出我们的自定义视图对象 View层 Controller层 RESTful SpringMVC CRUDcontroller层 员工列表页面 完整源码： 链接：提取码：2333 "},{"title":"Spring5框架（事务）","date":"2021-04-24T16:00:00.000Z","url":"/2021/04/25/Spring5%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8B%E5%8A%A1%EF%BC%89/","categories":[["ssm","/categories/ssm/"]],"content":"事务操作简介 事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败 典型场景：银行转账 lucy转账100元给mary lucy少100元，mary多100元 事务特性（ACID） 原子性:事务包含的所有操作要么全部成功，要么全部失败回滚 一致性:事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态 隔离性:多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离 持久性:一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作 事务操作环境 创建数据库表，添加记录 创建 service，搭建 dao，完成对象创建和注入关系 在 dao 创建两个方法：多钱和少钱的方法，在 service 创建方法（转账的方法） 在accountMoney中手动加入异常 添加异常后，lucy少100，但因为出现异常，下面语句并没有执行，mary并没有多100.导致凭空少了100. 事务操作过程 Spring事务操作 事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层） 在 Spring 进行事务管理操作（有两种方式：编程式事务管理和声明式事务管理） 声明式事务管理（基于注解方式&amp;基于xml配置文件方式） 在 Spring 进行声明式事务管理，底层使用 AOP 原理 Spring 事务管理 API 提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类 注解声明式事务管理 在 spring 配置文件配置事务管理器 在 spring 配置文件，开启事务注解 在 spring 配置文件引入名称空间 tx 开启事务注解 在 service 类上面（或者 service 类里面方法上面）添加事务注解 @Transactional，这个注解添加到类上面，也可以添加方法上面 如果把这个注解添加类上面，这个类里面所有的方法都添加事务 如果把这个注解添加方法上面，为这个方法添加事务 管理参数配置 propagation：事务传播行为（7种） 当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行 ioslation：事务隔离级别 脏读：一个未提交事务读取到另一个未提交事务的数据 不可重复读：一个未提交事务读取到另一提交事务修改数据 一个未提交事务读取到另一提交事务添加数据 timeout：超时时间 事务需要在一定时间内进行提交，如果不提交进行回滚 默认值是 -1 ，设置时间以秒单位进行计算 readOnly：是否只读 读：查询操作，写：添加修改删除操作 readOnly 默认值 false，表示可以查询，可以添加修改删除操作 设置 readOnly 值是 true，设置成 true 之后，只能查询 rollbackFor：回滚 设置出现哪些异常进行事务回滚 noRollbackFor：不回滚 设置出现哪些异常不进行事务回滚 xml声明式事务管理 在 spring 配置文件中进行配置 配置事务管理器 配置通知 配置切入点和切面 完全注解声明式事务管理 创建配置类，使用配置类替代 xml 配置文件 编写测试类 "},{"title":"Spring5框架（AOP、JDBCTemplate）","date":"2021-04-24T16:00:00.000Z","url":"/2021/04/25/Spring5%E6%A1%86%E6%9E%B6%EF%BC%88AOP%E3%80%81JDBCTemplate%EF%BC%89/","categories":[["ssm","/categories/ssm/"]],"content":"AOP简介 AOP（Aspect-OrientedProgramming，面向切面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。 利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 不通过修改源代码方式，在主干功能里面添加新功能 底层原理AOP底层使用动态代理实现 情况一：有接口情况，使用JDK动态代理创建接口实现类代理对象，增强类的方法 使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象 调用 newProxyInstance 方法，方法有三个参数 类加载器 增强方法所在的类，这个类实现的接口，支持多个接口 实现这个接口InvocationHandler，创建代理对象，写增强的部分 编写JDK动态代理代码 创建接口，定义方法 创建接口实现类，实现方法 使用 Proxy 类创建接口代理对象 情况二：没有接口情况，使用CGLIB动态代理创建子类的代理对象，增强类的方法 Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想目标没有实现接口的类,就可以使用Cglib实现. 术语 连接点：类中的可以增强的方法 切入点：实际被增强的方法 通知（增强）：实际增强的逻辑部分 类型： 前置通知 后置通知 环绕通知 异常通知 最终通知 切面：把通知应用到切入点的过程 AOP操作Spring框架一般都是基于AspectJ实现AOP操作，AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作 切入点表达式 作用：知道对哪个类里面的哪个方法进行增强 语法结构：execution([权限修饰符] [返回类型] [类全路径] [方法名称] ([参数列表])) 例1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 execution(* com.atguigu.dao.BookDao.add(..)) 例2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强 execution(* com.atguigu.dao.BookDao.* (..)) 例3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 execution(* com.atguigu.dao.. (..)) AOP实现-注解实现 创建类，在类里面定义方法 创建增强类(编写增强逻辑) 进行通知的配置 在Spring配置文件中，开启注解扫描 使用注解创建User和UserProxy对象 在增强类上添加注解@Aspect生成代理对象 在 spring 配置文件中开启生成代理对象 配置不同类型的通知 在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置 相同的切入点抽取 有多个增强类对同一个方法进行增强，设置增强类优先级 在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高 AOP完全注解实现 创建配置类，不需要创建 xml 配置文件 测试类改为 AOP实现-xml配置文件 创建两个类，增强类和被增强类，创建方法 在Spring配置文件中创建两个类对象 在 spring 配置文件中配置切入点 JdbcTemplate简介 Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 环境配置 引入相关jar包 druid mysql-connector-java spring-jdbc spring-orm spring-tx 在 spring 配置文件配置数据库连接池 配置 JdbcTemplate 对象，注入 DataSource 创建 service 类，创建 dao 类，在 dao 注入 jdbcTemplate 对象 配置文件中加入： Service层 Dao层 JdbcTemplate操作数据库 对应数据库创建实体类 编写Service和Dao 在Dao进行数据库操作 Service层 Dao层 DaoImpl层（增删改） 查询操作 queryForObject(String sql,Class&lt; T &gt; requiredType) 第一个参数：sql语句 第二个参数：返回类型Class queryForObject(String sql,RowMapper&lt; T &gt; rowMapper,Object… args) 第一个参数：sql语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成 数据封装 第三个参数：sql 语句值 query(String sql,RowMapper&lt; T &gt; rowMapper,Object… args) 第一个参数：sql语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成 数据封装 第三个参数：sql 语句值 批量操作 batchUpdate(String sql,List&lt; Object[] &gt; batchArgs) 第一个参数：sql语句 第二个参数：List集合，添加多条记录数据 编写测试类 "},{"title":"Spring5框架（IOC）","date":"2021-04-23T16:00:00.000Z","url":"/2021/04/24/Spring5%E6%A1%86%E6%9E%B6%EF%BC%88IOC%EF%BC%89/","categories":[["ssm","/categories/ssm/"]],"content":"Spring5框架概述 Spring5是轻量级的开源的JavaEE框架 SPring可以解决企业应用开发复杂性 核心部分： IOC：控制反转，把创建对象过程交给Spring进行管理 AOP：面向切面，不修改源代码进行功能增强 特点 方便解耦，简化开发 AOP编程支持 方便程序测试 方便和其他框架进行整合 方便进行事务操作 降低API开发难度 环境搭建以spring5.2.6为例 下载Spring5压缩包 创建Java工程 导入Spring5相关jar包(压缩包的lib目录下) commons-logging-1.1.1.jar spring-beans-5.2.6.RELEASE.jar spring-context-5.2.6.RELEASE.jar spring-core-5.2.6.RELEASE.jar spring-expression-5.2.6.RELEASE.jar 创建一个普通类和方法 创建Spring配置文件，在配置文件创建配置对象 配置文件使用xml格式 编写测试代码测试 IOC（Version Of Control）简介 IOC即控制反转，是一种设计思想。IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内直接控制。 传统JavaSE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IOC是有专门一个容器来创建这些对象。即，由IOC容器来控制对象的创建。 有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转。而反转则是由容器来帮忙创建及注入依赖对象；因为有容器帮助查找及注入依赖对象，对象只是被动的接受依赖对象，所以称之为“反转”，反转的是依赖对象的获取。 IOC作用：传统应用程序都是由我们在类的内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试。使用IOC容器可以把创建和查找依赖对象的控制权交给容器，由容器进行注入组合对象，所以对象和对象之间是松散耦合，便于测试，利于**功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 底层原理实现过程xml解析、工厂模式、反射 第一步：xml配置文件，配置创建的对象 第二步：有service类和dao类，创建工厂类 实际操作中，xml解析、工厂设计模式、反射机制创建对象都是Spring封装好的。只需要修改xml文件即可。 IOC思想基于IOC容器完成，IOC容器底层即为对象工厂 IOC容器实现方式（两个接口） Spring提供了实现IOC容器的两个接口 BeanFactory：IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用（加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象） ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用（加载配置文件时候就会把在配置文件对象进行创建） ApplicationContext实现类： FileSystemXmlApplicationContext ClassPathXmlApplicationContext Bean管理(基于xml方式)创建对象 在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建 在 bean 标签有很多属性 常用的属性 id 属性：唯一标识 class 属性：类全路径（包类路径） 创建对象时候，默认也是执行无参数构造方法完成对象创建 注入属性方式DI—Dependency Injection即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中****。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。**通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。 第一种注入方式：set方法进行注入 创建类，定义属性和set方法 在Spring配置文件配置对象创建，配置属性注入 第二种注入方式：使用有参构造进行注入 创建类，定义属性，创建属性对应有参数构造方法 在Spring配置文件中进行配置 p名称空间注入(了解)使用p名称空间注入，可以简化基于xml配置方式 添加p名称空间在配置文件中 进行属性注入，在bean标签里进行操作 xml注入其他类型属性 字面量 null值 属性值包含特殊符号 注入属性-外部bean 创建两个类 service 类和 dao 类 在 service 调用 dao 里面的方法 在 spring 配置文件中进行配置 注入属性-内部bean Spring配置文件中进行配置 注入属性-级联赋值第一种写法 第二种写法先生成Dept类的get方法，然后在在 spring 配置文件中进行配置 注入属性-集合 注入数组类型属性 注入List集合类型属性 注入Map集合类型属性 创建类，定义数组、list、map、set 类型属性，生成对应 set 方法 在Spring配置文件中进行配置 在集合里面设置对象类型值 把集合注入部分提取出来 在 spring 配置文件中引入名称空间 util 使用 util 标签完成 list 集合注入提取 FactoryBean Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean） 普通 bean：在配置文件中定义 bean 类型就是返回类型 工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样 第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean 第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型 bean作用域作用域限定了Spring Bean的作用范围，在Spring配置文件定义Bean时，通过声明scope配置项，可以灵活定义Bean的作用范围。例如，当你希望每次IOC容器返回的Bean是同一个实例时，可以设置scope为singleton；当你希望每次IOC容器返回的Bean实例是一个新的实例时，可以设置scope为prototype。 默认情况下，bean是单实例对象 在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用 getBean 方法时候创建多实例对象 bean生命周期 bean-后置处理器作用是在Bean对象在实例化和依赖注入完毕后，在显示调用初始化方法的前后添加我们自己的逻辑。注意是Bean实例化完毕后及依赖注入完成后触发的 添加后置处理器后，bean的生命周期增加到了7步 通过构造器创建 bean 实例（无参数构造） 为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） 把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization 调用 bean 的初始化的方法（需要进行配置初始化的方法） 把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization bean 可以使用了（对象获取到了） 当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法） 演示 创建类，实现接口BeanPostProcessor,创建后置处理器 xml自动装配根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入 根据属性名称自动注入 根据属性类型自动注入 外部属性文件配置直接配置数据库信息 配置德鲁伊连接池 引入德鲁伊连接池依赖jar包 引入外部属性文件配置数据库连接池 创建外部属性文件，properties 格式文件，写数据库信息 把外部 properties 属性文件引入到 spring 配置文件中 引入 context 名称空间 在 spring 配置文件使用标签引入外部属性文件 Bean管理（基于注解方式） 注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..) 使用注解，注解作用在类上面，方法上面，属性上面、 使用注解目的：简化 xml 配置 Spring 针对 Bean 管理中创建对象提供注解 @Component @Service @Controller @Respository 上面四个注解功能是一样的，都可以用来创建 bean 实例 基于注解方式实现对象创建 引入依赖spring-aop-5.2.6.RELEASE.jar 开启组件扫描 创建类，在类上面添加创建对象注解 开启组件扫描细节配置 基于注解方式实现属性注入 @Autowired：根据属性类型进行自动装配 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解 @Qualifier：根据名称进行注入 这个@Qualifier 注解的使用，和上面@Autowired 一起使用 @Resource：可以根据类型注入，可以根据名称注入 @Value：注入普通类型属性 完全注解开发 创建配置类，代替xml配置文件 编写测试类 "},{"title":"JSON&Ajax&i18n","date":"2021-04-17T16:00:00.000Z","url":"/2021/04/18/JSON&Ajax&i18n/","categories":[["Java Web","/categories/Java-Web/"]],"content":"JSON简介JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON 采用完全独立于语言的文本格式，而且很多语言都提供了对 json 的支持（包括 C, C++, C#, Java, JavaScript, Perl, Python 等）。 这样就使得JSON成为理想的数据交换格式。 json是一种轻量级的数据交换格式 轻量级指的是跟xml作比较 数据交换指的是客户端和服务器之间业务数据的传递格式 JavaScript中的使用json的定义json 是由键值对组成，并且由花括号（大括号）包围。每个键由引号引起来，键和值之间使用冒号进行分隔， 多组键值对之间进行逗号进行分隔。 示例 json访问 json 本身是一个对象。 json 中的 key 我们可以理解为是对象中的一个属性。 json 中的 key 访问就跟访问对象的属性一样： json 对象.key 示例 json两个常用方法json 的存在有两种形式。 一种是：对象的形式存在，我们叫它 json 对象。 一种是：字符串的形式存在，我们叫它 json 字符串。 一般我们要操作 json 中的数据的时候，需要 json 对象的格式。 一般我们要在客户端和服务器之间进行数据交换的时候，使用 json 字符串 方法 描述 JSON.stringify() 把json对象转换成为json字符串 JSON.parse() 把json字符串转换成为json对象 示例 json在Java中的使用javaBean和json的互转 List和json的互转 map和json的互转 AJAX请求简介AJAX 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。 ajax 是一种浏览器通过 js 异步发起请求，局部更新页面的技术。 Ajax 请求的局部更新，浏览器地址栏不会发生变化 局部更新不会舍弃原来页面的内容 示例 jQuery中的Ajax请求$.ajax方法 url——表示请求的地址 type—-表示请求的类型GET或POST请求 data—-表示发送给服务器的数据 格式有两种 name=value&amp;name=value {key:value} success—-请求成功，响应的回调函数 dataType–响应的数据类型 常用的数据类型有 text–纯文本 xml–xml数据 json表示json对象 示例 $.get方法和$.post方法 url—-请求的url地址 data–发送的数据 callback—成功的回调函数 type—返回的数据类型 示例 $.getJSON方法 url—-请求的url地址 data–发送给服务器的数据 callback—成功的回调函数 示例 表单序列化serialize()serialize()可以把表单中所有表单项的内容都获取到，并以 name=value&amp;name=value的形式进行拼接 i18n国际化简介 国际化（Internationalization）指的是同一个网站可以支持多种不同的语言，以方便不同国家，不同语种的用户访问。 关于国际化我们想到的最简单的方案就是为不同的国家创建不同的网站，比如苹果公司，他的英文官网是：  而中国官网是  苹果公司这种方案并不适合全部公司，而我们希望相同的一个网站，而不同人访问的时候可以根据用户所在的区域显示 不同的语言文字，而网站的布局样式等不发生改变。 于是就有了我们说的国际化，国际化总的来说就是同一个网站不同国家的人来访问可以显示出不同的语言。但实际上这 种需求并不强烈，一般真的有国际化需求的公司，主流采用的依然是苹果公司的那种方案，为不同的国家创建不同的页 面。所以国际化的内容我们了解一下即可。 国际化的英文 Internationalization，但是由于拼写过长，老外想了一个简单的写法叫做 I18N，代表的是 Internationalization 这个单词，以 I 开头，以 N 结尾，而中间是 18 个字母，所以简写为 I18N。以后我们说 I18N 和国际化是一个意思 相关要素Locale对象Locale表示不同的时区，位置，语言 Properties属性配置文件国际化配置文件命名规则： baseName_locale.properties 例如：baseName是i18n 中文的配置文件名是：i18n_zh_CN.properties 英文的配置文件名是：i18n_en_US.properties 国际化资源 properties测试配置两个语言的配置文件 i18n_en_US.properties 英文 i18n_zh_CN.properties 中文 国际化测试代码 通过请求头国际化页面 通过显示的选择语言类型进行国际化 JSTL标签库实现国际化 "},{"title":"Filter过滤器","date":"2021-04-12T16:00:00.000Z","url":"/2021/04/13/Filter%E8%BF%87%E6%BB%A4%E5%99%A8/","categories":[["Java Web","/categories/Java-Web/"]],"content":"简介 Filter过滤器是Java Web三大组件之一（Servlet程序、Listener监听器、Filter过滤器） Filter过滤器是JavaEE的规范，也就是接口 Filter过滤器它的作用是：拦截请求，过滤响应 拦截请求常见的应用场景有： 权限检查 日记操作 事务管理 应用应用场景：当你的 web 工程下，有一个 admin 目录。这个 admin 目录下的所有资源（html 页面、jpg 图片、jsp 文件、等等）都必须是用户登录之后才允许访问。 思路：用户登录之后都会把用户登录的信息保存到 Session 域中。所以要检查用户是否 登录，可以判断 Session 中否包含有用户登录的信息即可 Filter工作流程： 客户端（浏览器）根据地址访问服务器（Tomcat） Filter过滤器检查用户是否登录（权限检查） 有权限：让程序默认运行第3步 无权限：跳转到登录页面或者不允许访问 访问目标资源 Filter代码： web.xml 中的配置: Filter使用步骤： 编写一个类实现Filter接口 实现过滤方法doFilter() 到web.xml中去配置Filter的拦截路径 完整的用户登录login.jsp页面==登录表单 LoginServlet程序 Filter的生命周期Filter的生命周期包含几个方法 构造器方法 init初始化方法 doFilter过滤方法 destory销毁方法 注： 第1、2步，在web工程启动的时候执行（Filter已经创建） 第3步，每次拦截到请求，就会执行 第4步，停止web工程的时候，就会执行（停止web工程，也会销毁Filter过滤器） FilterConfig类FilterConfig 类见名知义，它是 Filter 过滤器的配置文件类。 Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。 FilterConfig 类的作用是获取 filter 过滤器的配置内容 获取Filter的名称filter-name的内容 获取在Filter中配置的init-param初始化参数 获取ServletContext对象 java代码 web.xml配置 FilterChain 过滤器链表示多个过滤器一起工作 Filter的拦截路径精确匹配 以上配置的路径，表示请求地址必须为：工程路径/target.jsp 目录匹配 以上配置的路径，表示请求地址必须为：工程路径/admin/* 后缀名匹配 以上配置的路径，表示请求地址必须以.html 结尾才会拦截到 以上配置的路径，表示请求地址必须以.do 结尾才会拦截到 以上配置的路径，表示请求地址必须以.action 注：Filter 过滤器它只关心请求的地址是否匹配，不关心请求的资源是否存在"},{"title":"Cookie&Session","date":"2021-04-07T16:00:00.000Z","url":"/2021/04/08/Cookie&Session/","categories":[["Java Web","/categories/Java-Web/"]],"content":"Cookie Cookie 是服务器通知客户端保存键值对的一种技术 客户端有了 Cookie 后，每次请求都发送给服务器 每个 Cookie 的大小不能超过 4kb Cookie创建 Servlet程序中 服务器获取Cookie 服务器获取客户端的 Cookie 只需要一行代码：req.getCookies():Cookie[] Cookie的工具类 Servlet中的代码 修改Cookie值方案一 先创建一个要修改的同名（指的就是key）的Cookie对象 在构造器，同时赋予新的Cookie值 调用response.addCookie(Cookie); 方案二 先查找到需要修改的Cookie对象 调用setValue()方法赋予新的Cookie值 调用response.addCookie()通知客户端保存修改 Cookie生命控制 Cookie 的生命控制指的是如何管理 Cookie 什么时候被销毁（删除） setMaxAge() 正数，表示在指定的秒数后过期 负数，表示浏览器一关，Cookie 就会被删除（默认值是-1） 零，表示马上删除 Cookie有效路径Path的设置 Cookie 的 path 属性可以有效的过滤哪些 Cookie 可以发送给服务器。哪些不发。 path 属性是通过请求的地址来进行有效的过滤。 CookieA path=/工程路径 CookieB path=/工程路径/abc 请求地址如下： 工程路径/a.html CookieA 发送 CookieB 不发送 工程路径/abc/a.html CookieA 发送 CookieB 发送 免输入用户名登录练习login.jsp页面 LoginServlet页面 Session会话 Session就一个接口（HttpSession） Session就是会话。它是用来维护一个客户端和服务器之间关联的一种技术 每个客户端都有自己的一个Session会话 Session会话中，经常用来保存登录之后的信息 创建&amp;获取Session 创建和获取 Session。它们的 API 是一样的。 request.getSession() 第一次调用是：创建 Session 会话 之后调用都是：获取前面创建好的 Session 会话对象。 isNew(); 判断到底是不是刚创建出来的（新的） true 表示刚创建 false 表示获取之前创建 每个会话都有一个身份证号。也就是 ID 值。而且这个 ID 是唯一的。 getId() 得到 Session 的会话 id 值。 Session域数据的存取 Session生命周期控制 public void setMaxInactiveInterval(int interval) 设置 Session 的超时时间（以秒为单位），超过指定的时长，Session 就会被销毁。 值为正数的时候，设定 Session 的超时时长。 负数表示永不超时（极少使用） public int getMaxInactiveInterval()：获取 Session 的超时时间 public void invalidate()：让当前 Session会话马上超时无效 Session 默认的超时时间长为 30 分钟。 因为在 Tomcat 服务器的配置文件 web.xml中默认有以下的配置，它就表示配置了当前 Tomcat 服务器下所有的 Session 超时配置默认时长为30 分钟。 web工程下修改所有Session超时时长 修改个别Session超时时长 Session的超时指的是，客户端两次请求的最大间隔时长 示例 Session 马上被超时 "},{"title":"EL表达式&JSTL标签库","date":"2021-04-02T16:00:00.000Z","url":"/2021/04/03/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F&JSTL%E6%A0%87%E7%AD%BE%E5%BA%93/","categories":[["Java Web","/categories/Java-Web/"]],"content":"EL表达式简介 EL表达式全称：Expression Language是表达式语言 EL表达式主要是代替JSP页面中的表达式脚本在jsp页面中进行数据的输出。因为EL表达式在输出数据的时候，要比JSP的表达式脚本要简洁的多。 EL表达式的格式是：${表达式} EL表达式在输出null值的时候，输出的是空串。JSP表达式脚本输出null值的时候，输出的是null字符串 EL表达式搜索域数据的顺序 EL表达式主要是在JSP页面上输出数据 主要是输出域对象中的数据 当四个域中都有相同的key的数据的时候，EL表达式会按照四个域的从小到大的顺序去进行搜索，找到就输出。 EL 表达式输出 Bean 的普通属性，数组属性。List 集 合属性，map 集合属性 输出 Person 类中普通属性，数组属性。list 集合属性和 map 集合属性 person类 输出的代码 EL表达式——运算语法 关系运算 关系运算符 说明 范例 结果 ==或eq 等于 ${5==5}或${5eq5} true !=或ne 不等于 ${5!=5}或${5ne5} false &lt;或lt 小于 ${3&lt;5}或${3lt5} true &gt;或gt 大于 ${2&gt;10}或${2gt10} false &lt;=或le 小于等于 ${5&lt;=12}或${5le12} true &gt;=或ge 大于等于 ${3&gt;=5}或${3ge5} false 逻辑运算 逻辑运算符 说明 范围 结果 $$或and 与运算 ${12==12&amp;&amp;12&lt;11}或${12==12and12&lt;11} false ||或or 或运算 ${12==12||12&lt;11}或${12==12or12&lt;11} true !或not 取反运算 ${!true}或${not true} false 算术运算 算术运算符 说明 范例 结果 + 加 ${12+18} 30 - 减 ${18-8} 10 * 乘 ${12*12} 144 /或div 除 ${144/12}或${144div12} 12 %或mod 取模 ${144%10}或${144mod10} 4 empty运算empty 运算可以判断一个数据是否为空，如果为空，则输出 true,不为空输出 false。 以下几种情况为空： 值为 null 值的时候，为空 值为空串的时候，为空 值是 Object 类型数组，长度为零的时候 list 集合，元素个数为零 map 集合，元素个数为零 三元运算表达式 1？表达式 2：表达式 3 如果表达式 1 的值为真，返回表达式 2 的值，如果表达式 1 的值为假，返回表达式 3 点运算&amp;中括号运算符 .点运算，可以输出 Bean 对象中某个属性的值。 []中括号运算，可以输出有序集合中某个元素的值。 并且[]中括号运算，还可以输出 map 集合中 EL表达式的11个隐含对象EL表达式中11个隐含对象，是EL表达式中自己定义的，可以直接使用 变量 类型 作用 pageContext PageContextImpl 它可以获取jsp中的九大内置对象 pageScope Map&lt;String,Object&gt; 它可以获取pageContext域中的数据 requestScope Map&lt;String,Object&gt; 它可以获取request域中的数据 sessionScope Map&lt;String,Object&gt; 它可以获取session域中的数据 applicationScope Map&lt;String,Object&gt; 它可以获取ServletContext域中的数据 param Map&lt;String,String&gt; 它可以获取请求参数的值 paramValues Map&lt;String,String[]&gt; 它也可以获取请求参数的值，获取多个值的时候使用 header Map&lt;String,String&gt; 它可以获取请求头的信息 headerValues Map&lt;String,String[]&gt; 它可以获取请求头的信息，它可以获取多个值的情况 cookies Map&lt;String,Cookie&gt; 它可以获取当前请求的cookie信息 initParam Map&lt;String,String&gt; 它可以获取在 web.xml 中配置的上下文参数 EL 获取四个特定域中的属性 pageScope—————pageContext域 requestScope———–Request域 sessionScope———–Session域 applicationScope——ServletContext域 pageContext对象的使用 EL表达式其他隐含对象的使用 param paramValues cookie initParam web.xml中的配置 示例 JSTL标签库 JSTL 标签库 全称是指 JSP Standard Tag Library JSP 标准标签库。是一个不断完善的开放源代码的 JSP 标 签库。 EL 表达式主要是为了替换 jsp 中的表达式脚本，而标签库则是为了替换代码脚本。这样使得整个 jsp 页面 变得更佳简洁。 JSTL由五个不同功能的标签库组成 功能范围 URI 前缀 核心标签库  c 格式化  fmt 函数  fn 数据库（不使用）  sql XML（不使用）  x 在 jsp 标签库中使用 taglib指令引入标签库 JSTL标签库使用步骤 先导入 jstl 标签库的 jar 包。 taglibs-standard-impl-1.2.1.jar taglibs-standard-spec-1.2.1.jar 使用 taglib 指令引入标签库。 core核心库使用&lt;c:set /&gt;（很少使用）作用：set标签可以往域中保存数据 &lt;c:if /&gt;if 标签用来做 if 判断。 &lt; c:choose &gt;&lt; c:when &gt;&lt; c:otherwise &gt;标签作用：多路判断。跟switch…case…default非常接近 &lt;c:foreach /&gt;作用：遍历输出使用 遍历1~10输出 遍历Object数组 遍历Map集合 遍历 List 集合—list 中存放 Student 类，有属性：编号，用户名，密码，年龄， 电话信息Student类 示例 "},{"title":"JSP","date":"2021-03-31T16:00:00.000Z","url":"/2021/04/01/JSP/","categories":[["Java Web","/categories/Java-Web/"]],"content":"简介 JSP的全称是java server pages。jaa的服务器页面 jsp的主要作用是代替Servlet程序回传html页面的数据，因为 Servlet 程序回传 html 页面数据是一件非常繁锁的事情。开发成本和维护成本都极高 servlet回传html页面数据 jsp 回传 html 页面的代码 JSP访问 jsp 页面和 html 页面一样，都是存放在 web 目录下。访问也跟html页面相同 JSP本质 jsp 页面本质上是一个 Servlet 程序 当第一次访问 jsp 页面的时候。Tomcat 服务器会把 jsp 页面翻译成为一个 java 源文件。并且对它进行编译成 为.class 字节码程序。跟踪源代码发现，HttpJspBase类直接继承了HttpServlet类。也就是说，jsp翻译出的java类，间接地继承了HttpServlet类。翻译出来的是一个 Servlet 程序。 JSP的三种语法JSP头部的page指令jsp 的 page 指令可以修改JSP页面中一些重要的属性，或者行为。 属性 说明 language 表示jsp翻译后是什么语言文件。暂时只支持java contentType jsp返回的数据类型是什么。也是源码中response.setContentType()参数值 pageEncoding 表示当前jsp页面文件本身的字符集 import 跟Java源代码中一样。用于导包，导类 errorPage 设置当jsp页面运行时出错，自动跳转去的错误页面路径。 isErrorPage 设置当前jsp页面是否是错误信息页面。默认是false。如果是true可以获取异常信息 session 设置访问当前jsp页面，是否会创建HttpSession对象默认是true。 extends 设置jsp翻译出来的java类默认继承谁 out输出流 属性 说明 autoFlush 设置当out输出流缓冲区满了以后，是否自动刷新冲级区。默认值是true buffer 设置out缓冲区的大小。默认是8kb 注：当缓冲区满了之后不能自动刷新，就会报错 JSP中的脚本声明脚本（极少使用）格式 作用 可以给jsp翻译出来的java类定义属性和方法甚至是静态代码块。内部类等。 表达式脚本（常用）格式 作用 在jsp页面上输出数据 特点 所有的表达式脚本都会被翻译到_jspService()方法中 表达式脚本都会被翻译成为out.print()输出到页面上 由于表达式脚本翻译的内容都在_jspService()方法中，所以 _jspService()方法中的对象都可以直接使用。 表达式脚本中的表达式不能以分号结束 示例代码： 代码脚本格式 作用 可以在jsp页面中，编写我们自己需要的功能(写的是java语句) 特点 代码脚本翻译之后都在_jspService方法中 代码脚本由于翻译到_jspService()方法中，所以在 _jspService()方法中的现有对象都可以直接使用 还可以由多个代码脚本块组合完成一个完整的 java 语句。 代码脚本还可以和表达式脚本一起组合使用，在 jsp 页面上输出数据 示例 JSP中的三种注释html注释 html 注释会被翻译到 java 源代码中。在_jspService 方法里，以 out.writer 输出到客户端 Java注释 java 注释会被翻译到 java 源代码中 JSP注释 jsp 九大内置对象 jsp 中的内置对象，是指 Tomcat 在翻译 jsp 页面成为 Servlet 源代码后，内部提供的九大对象，叫内置对象 request 请求对象 response 响应对象 pageContext jsp的上下文对象 session 会话对象 application ServletContext对象 config ServletConfig对象 out jsp输出流对象 page 指向当前jsp的对象 exception 异常对象 JSP四大域对象 域对象 说明 pageContext (PageContextImpl类) 当前jsp页面范围内有效 request (HttpServletRequest类) 一次请求内有效 session (HttpSession类) 一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器） application (ServletContext类) 整个Web工程范围内都有效(只要Web工程不停止，数据都在) 域对象是可以像 Map 一样存取数据的对象。四个域对象功能一样。不同的是它们对数据的存取范围 虽然四个域对象都可以存取数据。在使用上它们是有优先顺序的。 四个域在使用的时候，优先顺序分别是，他们从小到大的范围的顺序。 pageContext ====&gt;&gt;&gt; request ====&gt;&gt;&gt; session Scope.jsp页面 Scope2.jsp页面 out 输出和 response.getWriter 输出的区别 response 中表示响应，我们经常用于设置返回给客户端的内容（输出） out 也是给用户做输出使用的。 out.write()输出时，会将输出结果放在out缓冲区中。 response.getWriter()输出时，会将数据直接放入response缓冲区。 当jsp中的代码全部执行完毕后会执行out.flush()操作，将out缓冲区的数据追加写入到response缓冲区末尾。然后执行response的刷新操作。把全部数据写给客户端 由于 jsp 翻译之后，底层源代码都是使用 out 来进行输出，所以一般情况下。我们在 jsp 页面中统一使用 out 来进行输出。避免打乱页面输出内容的顺序。 out.write() 输出字符串没有问题 out.print() 输出任意数据都没有问题（都转换成为字符串后调用的 write 输出 JSP的常用标签JSP静态包含 JSP动态包含 JSP标签-转发 练习在JSP页面输出九九乘法口诀表 jsp 输出一个表格，里面有 10 个学生信息。student类 SearchStudentServlet 程序 showStudent.jsp 页面 Listener监听器 Listener 监听器它是 JavaWeb 的三大组件之一。JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监 听器。 Listener 它是 JavaEE 的规范，就是接口 监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。 ServletContextListener 监听器 ServletContextListener 它可以监听 ServletContext 对象的创建和销毁。 ServletContext 对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁。 监听到创建和销毁之后都会分别调用 ServletContextListener 监听器的方法反馈。 创建&amp;销毁监听方法 如何使用 ServletContextListener 监听器监听 ServletContext 对象。 使用步骤如下： 编写一个类去实现 ServletContextListener 实现其两个回调方法 到 web.xml 中去配置监听器 监听器实现类 web.xml配置 "},{"title":"Servlet2","date":"2021-03-30T16:00:00.000Z","url":"/2021/03/31/Servlet2/","categories":[["Java Web","/categories/Java-Web/"]],"content":"HttpServletRequset类作用请求进入Tomcat服务器，服务器就会把请求过来的Http协议信息解析好封装到Request对象中。然后传递到Service方法（doGet()和doPost()）中使用。可以通过HttpServletRequest对象，获取到所有请求的信息 常用方法 方法名 说明 getRequestURI() 获取请求的资源路径 getRequestURL() 获取请求的统一资源定位符（绝对路径） getRemoteHost() 获取客户端的IP地址 getHeader() 获取请求头 getParameter 获取请求的参数 getParameterValues() 获取请求的参数（多个值时使用） getMethod() 获取请求的方式GET或POST setAttribute(key,value) 设置域数据 getAttribute(key) 获取域数据 getRequestDispatcher() 获取请求转发对象 示例 获取请求参数示例表单 Java代码 doGet请求的中文乱解决 doPost请求的中文乱码解决 请求转发服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发 特点： 浏览器地址栏没有变化 他们是一次请求 他们共享Request域中的数据 可以转发到WEB-INF目录下 不可以访问工程以外的资源 示例Servlet1 Servlet2 base标签的作用base标签可以设置当前页面中所有相对路径工作时，参照哪个路径来进行跳转 Web 中的相对路径和绝对路径相对路径 符号 说明 . 表示当前目录 .. 表示上一级目录 资源名 表示当前目录/资源名 绝对路径 工程路径/资源路径 在实际开发中，路径都使用绝对路径，而不简单的使用相对路径 相对路径 base+相对 web中“/”的不同意义 在web中“/”是一种绝对路径 “/”如果被浏览器解析，得到的地址是： “/“如果被服务器解析，得到的地址是：工程路径 /servlet1 servletContext.getRealPath(“/”); request.getRequestDispatcher(“/”); 特殊情况： response.sendRediect(“/”); 把斜杠发送给浏览器解析。得到  HttpServletResponse类作用HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息， 我们如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象来进行设置 两个输出流说明 字节流：getOutputStream();——–常用于下载（传递二进制数据） 字符流：getWriter();——————–常用于回传字符串（常用） 两个流同时只能使用一个。否则会报错。 客户端回传数据 响应的乱码解决方案一 方案二(推荐) 请求重定向请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求重定向（因为之前的地址可能已经被废弃）。 请求重定向的第一种方案 请求重定向的第二种方案(推荐)"},{"title":"HTTP协议","date":"2021-03-28T16:00:00.000Z","url":"/2021/03/29/HTTP%E5%8D%8F%E8%AE%AE/","categories":[["Java Web","/categories/Java-Web/"]],"content":"HTTP协议简介HTTP 协议就是指，客户端和服务器之间通信时，发送的数据，需要遵守的规则，叫 HTTP 协议。 HTTP 协议中的数据又叫报文。 请求的HTTP协议格式 客户端给服务器发送数据叫请求。 服务器给客户端回传数据叫响应。 请求又分为 GET 请求，和 POST 请求两种 GET请求 请求行 请求的方式———GET 请求的资源路径[+?+请求参数] 请求的协议的版本号——–HTTP/1.1 请求头 key:value 组成不同的键值对，表示不同的含义 POST请求 请求行 请求的方式———POST 请求的资源路径[+?+请求参数] 请求的协议的版本号——-HTTP/1.1 请求头 key:value———不同的请求头，有不同的含义 请求体===&gt;&gt;&gt;就是发送给服务器的数据 常用请求头说明 Accept: 表示客户端可以接收的数据类型 Accpet-Languege: 表示客户端可以接收的语言类型 User-Agent: 表示客户端浏览器的信息 Host：表示请求时的服务器 ip 和端口号 哪些是 GET 请求，哪些是 POST 请求GET 请求有哪些： form 标签 method=get a 标签 link 标签引入 css Script 标签引入 js 文件 img 标签引入图片 iframe 引入 html 页面 在浏览器地址栏中输入地址后敲回车 POST 请求有哪些： form 标签 method=post 响应的 HTTP 协议格式响应行 响应的协议和版本号 响应状态码 响应状态描述符 响应头 key : value 不同的响应头，有其不同含义 响应体 响应体 就是回传给客户端的数据 常用的响应码说明 响应码 说明 200 表示请求成功 302 表示请求重定向 404 表示请求服务器已经收到了，但需要的数据不存在（请求地址错误） 500 表示服务器已经收到请求，但是服务器内部错误（代码错误） MIME 类型说明 MIME 是 HTTP 协议中数据类型。 MIME 的英文全称是”Multipurpose Internet Mail Extensions” 多功能 Internet 邮件扩充服务。MIME 类型的格式是“大类型/小 类型”，并与某一种文件的扩展名相对应。 文件 MIME类型 超文本标记语言文本 .html , .htm text/html 普通文本 .txt text/plain RTF 文本 .rtf application/rtf GIF 图形 .gif image/gif JPEG 图形 .jpeg,.jpg image/jpeg au 声音文件 .au audio/basic MIDI音乐文件 mid,.midi audio/midi,audio/x-midi RealAudio 音乐文件 .ra, .ram audio/x-pn-realaudio MPEG 文件 .mpg,.mpeg video/mpeg AVI 文件 .avi video/x-msvideo GZIP 文件 .gz application/x-gzip TAR文件 .tar application/x-tar "},{"title":"Servlet1","date":"2021-03-28T16:00:00.000Z","url":"/2021/03/29/Servlet1/","categories":[["Java Web","/categories/Java-Web/"]],"content":"Servlet技术 Servlet是JavaEE规范之一。规范就是接口 Servlet 就 JavaWeb 三大组件之一。三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监听器 Servlet 是运行在服务器上的一个 java 小程序，它可以接收客户端发送过来的请求，并响应数据给客户端 手动实现Servlet程序 编写一个类实现Servlet接口 实现service方法，处理请求，并响应数据 到web.xml中去配置Servlet程序的访问地址 示例实现Servlet接口类 web.xml中的配置 Servlet的生命周期 执行Servlet构造器方法 执行init初始化方法 执行service方法 执行destroy销毁方法 注： 第1、2步是在第一次访问的时候创建Servlet程序会调用 第3步每次访问都会调用 第4步在web工程停止的时候调用 GET和POST请求的分发处理 通过继承HttpServlet实现Servlet程序一般在实际项目开发中，都是使用继承 HttpServlet 类的方式去实现 Servlet 程序。 编写一个类去继承 HttpServlet 类 根据业务需要重写 doGet 或 doPost 方法 到 web.xml中的配置Servlet程序的访问地址 示例Servlet类 web.xml配置 Servlet类的继承体系 ServletConfig类 ServletConfig 类是 Servlet 程序的配置信息类。 Servlet 程序和 ServletConfig 对象都是由 Tomcat 负责创建，我们负责使用。 Servlet 程序默认是第一次访问的时候创建，ServletConfig 是每个 Servlet 程序创建时，就创建一个对应的 ServletConfig 对 象。 ServletConfig类的三大作用 可以获取Servlet程序的别名servlet-name的值 获取初始化参数init-param 获取ServletContext对象 web.xml中的配置 Servlet 注：重新init()方法里面一定要调用父类的init(ServletConfig)操作 ServletContext类什么是ServletContext ServletContext是一个接口，它表示Servlet上下文对象 一个web工程，只有一个ServletContext对象实例 ServletContext对象是一个域对象 ServletContext是在web工程部署启动的时候创建。在web工程停止的时候销毁 域对象：可以像Map一样存取数据的对象。这里的域指的是存取数据的操作范围，整个web工程。 存数据 取数据 删除数据 Map put() get() remove() 域对象 setAttribute() getAttribute() removeAttribute() ServletContext类的四个作用 获取web.xml中配置的上下文参数context-param 获取当前的工程路径，格式：/工程路径 获取工程部署后在服务器硬盘上的绝对路径 像Map一样存取数据 示例ServletContext web.xml ServletContext像Map一样存取数据ContextServlet1 ContextServlet2 "},{"title":"Tomcat","date":"2021-03-27T16:00:00.000Z","url":"/2021/03/28/Tomcat/","categories":[["Java Web","/categories/Java-Web/"]],"content":"JavaWeb的概念 JavaWeb 是指，所有通过 Java 语言编写可以通过浏览器访问的程序的总称，叫 JavaWeb。 JavaWeb 是基于请求和响应来开发的。 请求是指客户端给服务器发送数据，叫请求 Request 响应是指服务器给客户端回传数据，叫响应 Response 请求和响应是成对出现的，有请求就有响应 Web资源的分类web 资源按实现的技术和呈现的效果的不同，又分为静态资源和动态资源两种。 静态资源： html、css、js、txt、mp4 视频 , jpg 图片 动态资源： jsp 页面、Servlet 程序 常用的 Web 服务器 Tomcat：由 Apache 组织提供的一种 Web 服务器，提供对 jsp 和 Servlet 的支持。它是一种轻量级的 javaWeb 容器（服务 器），也是当前应用最广的 JavaWeb 服务器（免费）。 Jboss：是一个遵从 JavaEE 规范的、开放源代码的、纯 Java 的 EJB 服务器，它支持所有的 JavaEE 规范（免费）。 GlassFish： 由 Oracle 公司开发的一款 JavaWeb 服务器，是一款强健的商业服务器，达到产品级质量（应用很少）。 Resin：是 CAUCHO 公司的产品，是一个非常流行的服务器，对 servlet 和 JSP 提供了良好的支持， 性能也比较优良，resin 自身采用 JAVA 语言开发（收费，应用比较多）。 WebLogic：是 Oracle 公司的产品，是目前应用最广泛的收费Web 服务器，支持 JavaEE 规范， 而且不断的完善以适应新的开发要求，适合大型项目（收费，用的不多，适合大公司）。 Tomcat使用目录介绍 目录 说明 bin 专门用来存放Tomcat服务器的可执行程序 conf 专门用来存放 Tocmat 服务器的配置文件 lib 专门用来存放 Tomcat 服务器的 jar 包 logs 专门用来存放 Tomcat 服务器运行时输出的日记信息 temp 专门用来存放 Tomcdat 运行时产生的临时数据 webapps 专门用来存放部署的 Web 工程 work 是 Tomcat 工作时的目录，用来存放 Tomcat 运行时 jsp 翻译为 Servlet 的源码，和 Session 钝化的目录 启动Tomcat服务器方式一找到 Tomcat 目录下的 bin 目录下的 startup.bat 文件，双击，就可以启动 Tomcat。 打开浏览器，在浏览器地址栏中输入以下地址测试：   http://真实 ip:8080 方式二 打开命令行 cd到你的Tomcat的bin目录下 输入：catalina run 关闭Tomcat 点击 tomcat 服务器窗口的 x 关闭按钮 把 Tomcat 服务器窗口置为当前窗口，然后按快捷键 Ctrl+C 找到 Tomcat 的 bin 目录下的 shutdown.bat 双击，就可以停止 Tomcat 部署Web工程到Tomcat中方式一 把 web 工程的目录拷贝到 Tomcat 的 webapps 目录下 只需要在浏览器中输入访问地址格式如下： 工程名/目录下/文件名 方式二 找到 Tomcat 下的 conf 目录\\Catalina\\localhost\\ 下,创建如下的配置文件 访问这个工程的路径如下: "},{"title":"XML","date":"2021-03-27T16:00:00.000Z","url":"/2021/03/28/XML/","categories":[["Java Web","/categories/Java-Web/"]],"content":"xml简介xml是可扩展的标记性语言 作用 用来保存数据，而且这些数据具有自我描述性 它还可以作为项目或者模块的配置文件 还可以作为网络传输数据的格式（现在json为主） xml语法文档声明 xml注释和html相同 元素（标签）xml元素指的是从（且包括）从开始标签直到（且包括）结束标签的部分。元素可包含其他元素、文本或者两者的混合物。元素也可用有属性。 命名规则 名称可以含字母、数字以及其它字符 名称不能以数字或者标点符号开始 名称不能包含空格 单&amp;双标签单标签 格式： &lt;标签名 属性=”值” 属性=”值” …… /&gt; 双标签 格式：&lt; 标签名 属性=”值” 属性=”值” ……&gt;文本数据或子标签 xml属性xml 的标签属性和 html 的标签属性是非常类似的。 在标签上可以书写属性： 一个标签上可以书写多个属性。每个属性的值必须使用引号引起来。规则和标签的书写规则一致。 语法规则 所有xml元素都必须有关闭标签（也就是闭合） xml标签对大小写敏感 必须正确嵌套 必须有根元素 根元素就是顶级元素，没有父标签的的元素叫顶级元素。根元素是没有父标签的顶级元素，而且是唯一一个才行。 xml的属性值需加引号 文本区域（CDATA区）CDATA语法可以告诉xml解析器，我CDATA里的文本内容，只是纯文本，不需要xml语法解析 CDATA格式： xml解析技术介绍不管是html还是xml文件他们都是标记型文档，都可以使用w3c组织制定的dom技术来解析。 DOM&amp;SAX简介（已经过时，但还是需要了解） dom 解析技术是 W3C 组织制定的，而所有的编程语言都对这个解析技术使用了自己语言的特点进行实现。 Java 对 dom 技术解析标记也做了实现。 sun 公司在 JDK5 版本对 dom 解析技术进行升级：SAX（ Simple API for XML ） SAX 解析，它跟 W3C 制定的解析不太一样。它是以类似事件机制通过回调告诉用户当前正在解析的内容。 它是一行一行的读取 xml 文件进行解析的。不会创建大量的 dom 对象。 所以它在解析 xml 的时候，在内存的使用上。和性能上。都优于 Dom 解析。 第三方的解析： jdom 在 dom 基础上进行了封装 dom4j 又对 jdom 进行了封装。（Dom4j是第三方的解析技术。我们需要使用第三方给我们提供好的类库才可以解析 xml 文） pull 主要用在 Android 手机开发，是在跟 sax 非常类似都是事件机制解析 xml dom4j解析技术（重点）由于 dom4j 它不是 sun 公司的技术，而属于第三方公司的技术，我们需要使用 dom4j 就需要到 dom4j 官网下载 dom4j 的 jar 包。 dom4j编程步骤 先加载xml文件创建document对象 通过Document对象拿到根元素对象 通过根元素.elements(标签名);可以返回一个集合，这个集合里放着。所有你指定的标签名的元素对象 找到你想要修改、删除的子元素，进行相应操作 保存到硬盘上 获取document对象先创建SaxReader对象。这个对象，用于读取xml文件，并创建Document 遍历标签获取所有标签中的内容（重点） 通过创建 SAXReader 对象。来读取 xml 文件，获取 Document 对象 通过 Document 对象。拿到 XML 的根元素对象 通过根元素对象。获取所有的 book 标签对象 遍历每个 book 标签对象。然后获取到 book 标签对象内的每一个元素，再通过 getText() 方法拿到起始标签和结束标签之间的文本内容 "},{"title":"jQuery2","date":"2021-03-24T16:00:00.000Z","url":"/2021/03/25/jQuery2/","categories":[["Java Web","/categories/Java-Web/"]],"content":"jQuery属性操作 属性 描述 html() 它可以设置和获取起始标签和结束标签中的内容 text() 它可以设置和获取起始标签和结束标签中的文本 val() 它可以设置和获取表单项的 value 属性值 属性 描述 attr() 可以设置和获取属性的值，不推荐操作 checked、readOnly、selected、disabled 等等。 attr 方法还可以操作非标准的属性。比如自定义属性：abc,bbj prop() 可以设置和获取属性的值,只推荐操作 checked、readOnly、selected、disabled 等等 jQuery练习 DOM的增删改 内部插入 示例 描述 appendTo() a.appendTo(b) 把 a 插入到 b 子元素末尾，成为最后一个子元素 prependTo() a.prependTo(b) 把 a 插到 b 所有子元素前面，成为第一个子元素 外部插入 示例 描述 insertAfter() a.insertAfter(b) 得到ba insertBefore() a.insertBefore(b) 得到ab 替换 示例 描述 replaceWith() a.replaceWith(b) 用b替换掉a replaceAll() a.replaceAll(b) 用a替换掉所有b 删除 示例 描述 remove() a.remove(); 删除a标签 empty() a.empty(); 清空a标签里的内容 示例 jQuery练习2 动态添加、删除表格记录 CSS样式操作 样式操作 描述 addClass() 添加样式 removeClass() 删除样式 toggleClass() 有就删除，没有就添加样式 offset() 获取和设置元素的坐标 jQuery动画基本动画 动画方法 描述 show() 将隐藏的元素显示 hide() 将可见的元素隐藏 toggle() 可见就隐藏，不可见就显示 以上动画方法都可以添加参数。 第一个参数是动画 执行的时长，以毫秒为单位 第二个参数是动画的回调函数 (动画完成后自动调用 淡入淡出动画 方法 描述 fadeln() 淡入（慢慢可见） fadeOut() 淡出（慢慢可见） fadeTo() 在指定时长内慢慢的将透明度修改到指定的值。0 透明，1 完成可见，0.5 半透明 fadeToggle() 淡入/淡出 切换 jQuery练习3需求： 点击按钮的时候，隐藏和显示卡西欧之后的品牌。 当显示全部内容的时候，按钮文本为“显示精简品牌” 然后，小三角形向上。所有品牌产品为默认颜色。 当只显示精简品牌的时候，要隐藏卡西欧之后的品牌，按钮文本为“显示全部品牌” 然后小三形向下。并且把 佳能，尼康的品牌颜色改为红色（给 li 标签添加 promoted 样式即可） jQuery事件操作$( function(){} ); 和 window.onload = function(){} 的区别？他们分别是在什么时候触发？ jQuery 的页面加载完成之后是浏览器的内核解析完页面的标签创建好 DOM 对象之后就会马上执行。 原生 js 的页面加载完成之后，除了要等浏览器内核解析完标签创建好 DOM 对象，还要等标签显示时需要的内容加载 完成。 他们触发的顺序？ jQuery 页面加载完成之后先执行 原生 js 的页面加载完成之后 他们执行的次数？ 原生 js 的页面加载完成之后，只会执行最后一次的赋值函数。 jQuery 的页面加载完成之后是全部把注册的 function 函数，依次顺序全部执行 jQuery 中其他的事件处理方法 方法 描述 click() 它可以绑定单击事件，以及触发单击事件 mouseover() 鼠标移入事件 mouseout() 鼠标移出事件 bind() 可以给元素一次性绑定一个或多个事件 one() 使用上跟 bind 一样。但是 one 方法绑定的事件只会响应一次 unbind() 跟 bind 方法相反的操作，解除事件 live() 也是用来绑定事件。它可以用来绑定选择器匹配的所有元素的事件。哪怕这个元素是后面动态创建出 来的也有效 事件的冒泡事件的冒泡是指，父子元素同时监听同一个事件。当触发子元素的事件的时候，同一个事件也被传递到了父元素的事件里去 响应。 示例 javaScript 事件对象事件对象，是封装有触发的事件信息的一个 javascript 对象。 如何获取 javascript 事件对象？ 在给元素绑定事件的时候，在事件的 function( event ) 参数列表中添加一个参数，这个参数名，我们习惯取名为 event。 这个 event 就是 javascript 传递参事件处理函数的事件对象 示例 jQuery练习3图片跟随 "},{"title":"jQuery1","date":"2021-03-24T16:00:00.000Z","url":"/2021/03/25/jQuery1/","categories":[["Java Web","/categories/Java-Web/"]],"content":"jQuery介绍 顾名思义，jQuery也就是JavaScript和查询（Query），他就是辅助JavaScript开发的Js类库。 jQuery的核心思想是“写的更少，做得更多”，所以它实现了很多浏览器的兼容问题 示例给按钮添加一个绑定单击事件 jQuery使用时一定要引入jQuery库 jQuery中的$是一个函数 jQuery核心函数$ 是 jQuery 的核心函数，能完成 jQuery 的很多功能。$()就是调用$这个函数 传入参数为[函数]时 表示页面加载完成之后。相当于window.onload=function(){} 传入参数为[HTML字符串]时 会对我们创建这个html标签对象 传入参数为[选择器字符串]时 $(“#id属性值”);——–id选择器，根据id查询标签对象 $(“标签名”);————-标签名选择器，根据指定的标签名查询标签对象 $(“.class属性值”);——类型选择器，可以根据class属性查询标签对象 传入参数为[DOM对象]时 会把这个dom对象转换为jQuery对象 jQuery对象和dom对象区分jQuery对象&amp;dom对象Dom对象 通过 getElementById()查询出来的标签对象是 Dom 对象 通过 getElementsByName()查询出来的标签对象是 Dom 对象 通过 getElementsByTagName()查询出来的标签对象是 Dom 对象 通过 createElement() 方法创建的对象，是 Dom 对象 DOM 对象 Alert 出来的效果是：**[object HTML 标签名 Element]** jQuery对象 通过jQuery提供的API创建的对象，是jQuery对象 通过jQuery包装的Dom对象，也是jQuery对象 通过jQuery提供的API查询到的对象，是jQuery对象 jQuery 对象 Alert 出来的效果是：[object Object] jQuery对象的本质jQuery 对象是 dom 对象的数组 +jQuery提供的一系列功能函数 jQuery对象和Dom对象使用区别 jQuery对象不能使用Dom对象的属性和方法 Dom对象也不能使用jQuery对象的属性和方法 Dom和jQuery对象相互转换 Dom对象转换为jQuery对象 先有Dom对象 $(Dom对象)就可以转换成jQuery对象（var $obj=$(dom对象);） jQuery对象转换为Dom对象 先有jQuery对象 jQuery对象[下标]取出相应的Dom对象（var dom=$obj[下标]） jQuery选择器基本选择器 选择器 描述 #id 根据id查找标签对象 .class 根据class查找标签对象 element 根据标签名查找标签对象 * 表示任意的，所有元素 selector1,selector2 合并选择器1，选择器2的结果并返回 示例代码 层级选择器 选择器 描述 ancestor descendant(后代选择器) 在给定的祖先元素下匹配所有的后代元素 parent&gt;child(子元素选择器) 在给定的父元素下匹配所有的子元素 prev+next(相邻元素选择器) 匹配所有紧接在prev元素后的next元素 prev~sibings(兄弟元素选择器) 匹配prev元素之后的所有siblings元素 示例代码 过滤选择器基本过滤器 过滤器 描述 :first 获取第一个元素 :last 获取最后一个元素 :not(selector) 去除所有与给定选择器匹配的元素 :even 匹配所有索引值为偶数的元素，从0开始计数 :odd 匹配所有索引值为奇数的元素，从0开始计数 :eql(index) 匹配一个给定索引值的元素 :gt(index) 匹配所有大于给定索引值的元素 :lt(index) 匹配所有小于给定索引值的元素 :header 匹配如 h1, h2, h3 之类的标题元素 :animated 匹配所有正在执行动画效果的元素 内容过滤器 过滤器 描述 :contains(text) 匹配包含给定文本的元素 :empty 匹配所有不包含子元素或者文本的空元素 :parent 匹配含有子元素或者文本的元素 :has(selector) 匹配含有选择器所匹配的元素的元素 代码示例 属性过滤器 过滤器 描述 [attribute] 匹配包含给定属性的元素 [attribute=value] 匹配给定的属性是某个特定值的元素 [attribute!=value] 匹配所有不含有指定的属性，或者属性不等于特定值的元素 [attribute^=value] 匹配给定的属性是以某些值开始的元素 [attribute$=value] 匹配给定的属性是以某些值结尾的元素 [attribute*=value] 匹配给定的属性是以包含某些值的元素 [ attrSel1 ] [ attrSel2 ] [ attrSelN ] 复合属性选择器，需要同时满足多个条件时使用 示例代码 表单过滤器&amp;表单对象属性过滤器 过滤器 描述 :input 匹配所有 input, textarea, select 和 button 元素 :text 匹配所有 文本输入框 :password 匹配所有的密码输入框 :radio 匹配所有的单选框 :checkbox 匹配所有的复选框 :submit 匹配所有提交按钮 :image 匹配所有 img 标签 :reset 匹配所有重置按钮 :button 匹配所有 input type=button 按钮 :file 匹配所有 input type=file 文件上传 :hidden 匹配所有不可见元素 display:none 或 input type=hidden 表单对象属性过滤器 过滤器 描述 :enabled 匹配所有可用元素 :disabled 匹配所有不可用元素 :checked 匹配所有选中的单选，复选，和下拉列表中选中的option标签对象 :selected 匹配所有选中的option 示例代码 jQuery元素筛选 筛选元素 描述 eq() 获取给定索引的元素 first() 获取第一个元素 last() 获取最后一个元素 filter(exp) 留下匹配的元素 is(exp) 判断是否匹配给定的选择器，只要有一个匹配就返回，true has(exp) 返回包含有匹配选择器的元素的元素 not(exp) 删除匹配选择器的元素 children(exp) 返回匹配给定选择器的子元素 find(exp) 返回匹配给定选择器的后代元素 next() 返回当前元素的下一个兄弟元素 nextAll() 返回当前元素后面所有的兄弟元素 nextUntil() 返回当前元素到指定匹配的元素为止的后面元素 parent() 返回父元素 prev(exp) 返回当前元素的上一个兄弟元素 prevAll() 返回当前元素前面所有的兄弟元素 prevUnit(exp) 返回当前元素到指定匹配的元素为止的前面元素 siblings(exp) 返回所有兄弟元素 add() 把 add 匹配的选择器的元素添加到当前 jquery 对象 "},{"title":"JavaScript","date":"2021-03-22T16:00:00.000Z","url":"/2021/03/23/JavaScript/","categories":[["Java Web","/categories/Java-Web/"]],"content":"JavaScript介绍 Javascript 语言诞生主要是完成页面的数据验证。因此它运行在客户端，需要运行浏览器来解析执行 JavaScript 代码。 特点 交互性（它可以做的就是信息的动态交互） 安全性（不允许直接访问本地硬盘） 跨平台性（只要是可以解释 JS 的浏览器都可以执行，和平台无 JavaScript 和 html 代码的结合方式第一种方式只需要在 head 标签中，或者在 body 标签中， 使用 script 标签 来书写 JavaScript 代码 第二种方式使用 script 标签引入 单独的 JavaScript 代码文件 html代码内容 css代码内容 变量变量是可以存放某些值的内存的命名，JavaScript的变量类型都包括 数值类型 number 字符串类型 string 对象类型 object 布尔类型 boolean 函数类型 function JavaScript 里特殊的值 undefined 未定义，所有js变量未赋于初始值的时候，默认值都是 undefined null 空值 NaN 全称是：Not a number。非数字。非数值 JS 中的定义变量格式 示例 关系运算 等于 全等于 == === 等于是简单的做字面值的比较 除了做字面值的比较之外，还会比较两个变量的数据类型 示例 逻辑运算 符号 含义 &amp;&amp; 且运算 || 或运算 ! 取反运算 在 JavaScript 语言中，所有的变量，都可以做为一个 boolean 类型的变量去使用。 0 、null、 undefined、””(空串) 都认为是 false 说明 &amp;&amp; 且运算。 有两种情况： 当表达式全为真的时候。返回最后一个表达式的值 当表达式中，有一个为假的时候。返回第一个为假的表达式的值 || 或运算 当表达式全为假时，返回最后一个表达式的值 只要有一个表达式为真。就会把回第一个为真的表达式的值 &amp;&amp; 和 || 有短路。 短路就是说，当这个&amp;&amp;或||运算有结果了之后 。后面的表达式不再执行 示例 数组（重点）数组定义方式JS中数组的定义方式 示例 函数（重点）函数的定义方式第一种方式使用的格式如下 在 JavaScript 语言中，定义带有返回值的函数 ，只需要在函数体内直接使用 return 语句返回值即可！ 示例 第二种方式var 函数名 = function(形参列表) { 函数 } 注：在 Java 中函数允许重载。但是在 JS 中函数的重载会直接覆盖掉上一次的定义 函数的 arguments 隐形参数（只在 function 函数内）就是在 function 函数中不需要定义，但却可以直接用来获取所有参数的变量。我们管它叫隐形参数。 隐形参数特别像 java 基础的可变长参数一样。 public void fun( Object … args ); 可变长参数其实是一个数组。 那么 js 中的隐形参数也跟 java 的可变长参数一样。操作类似数组。 示例 JS 中的自定义对象Object 形式的自定义对象 示例 {}花括号形式的自定义对象 示例 js 中的事件事件是电脑输入设备与页面进行交互的响应。我们称之为事件 常用的事件 事件 描述 onload 加载完成事件 页面加载完成之后，常用于做页面 js 代码初始化操作 onclick 单击事件 常用于按钮的点击响应操作 onblur 失去焦点事件 常用用于输入框失去焦点后验证其输入内容是否合法 onchange 内容发生改变事件 常用于下拉列表和输入框内容发生改变后操作 onsubmit 表单提交事件 常用于表单提交前，验证所有表单项是否合法 事件的注册事件的注册（绑定）：告诉浏览器，当事件响应后要执行哪些操作代码。 静态注册事件通过html标签的事件属性直接赋予事件响应后的代码 动态注册事件先通过 js 代码得到标签的 dom 对象，然后再通过 dom 对象.事件名 = function(){} 这种形式赋于事件响应后的代码。 动态注册基本步骤： 获取标签对象 标签对象.事件名 = fucntion(){} onload加载完成事件静态方法 动态方法 onclick 单击事件静态方法 动态方法 onblur 失去焦点事件静态方法 动态方法 onchange 内容发生改变事件静态方法 动态方法 onsubmit 表单提交事件静态方法 动态方法 DOM模型 DOM 全称是 Document Object Model 文档对象模型 将文档中的标签，属性，文本，转换成为对象来管理。 Document文档树内存结构 Document对象Document 对象的理解 Document 它管理了所有的 HTML 文档内容。 document 它是一种树结构的文档。有层级关系。 它让我们把所有的标签 都 对象化 我们可以通过 document 访问所有的标签对象 Document 对象中的方法介绍document.getElementById(elementId)通过标签的 id 属性查找标签 document.getElementsByName(elementName)通过标签的 name 属性查找标签 dom 对象，elementName 标签的 name 属性值 document.getElementsByTagName(tagname)通过标签名查找标签 dom 对象。tagname 是标签名 document.createElement( tagName)通过给定的标签名，创建一个标签对象。tagName是要创建的标签名 注： document 对象的三个查询方法，如果有 id 属性，优先使用 getElementById 方法来进行查询 如果没有 id 属性，则优先使用 getElementsByName 方法来进行查询 如果 id 属性和 name 属性都没有最后再按标签名查 getElementsByTagName 以上三个方法，一定要在页面加载完成之后执行，才能查询到标签对象 节点的常用属性和方法节点就是标签对象 方法 通过具体的元素节点调用 getElementsByTagName() 方法，获取当前节点的指定标签名孩子节点 appendChild( oChildNode ) 方法，可以添加一个子节点，oChildNode 是要添加的孩子节点 属性 属性 描述 childNodes 获取当前节点的所有子节点 firstChild 获取当前节点的第一个子节点 lastChild 获取当前节点的最后一个子节点 parentNode 获取当前节点的父节点 nextSibling 获取当前节点的下一个节点 previousSibling 获取当前节点的上一个节点 className 用于获取或设置标签的 class 属性 innerHTML 表示获取/设置起始标签和结束标签中的内容 innerText 表示获取/设置起始标签和结束标签中的文本 示例HTML部分 CSS部分 "},{"title":"HTML&CSS","date":"2021-03-21T16:00:00.000Z","url":"/2021/03/22/HTML&CSS/","categories":[["Java Web","/categories/Java-Web/"]],"content":"网页的组成部分页面由三部分组成，分别是 内容（结构）：在页面中可以看到的数据。称之为内容。一般内容使用 html 技术来展示 表现：内容在页面上表现的形式比如颜色、布局、大小等。一般使用CSS技术实现 行为：指的是页面中元素与输入设备交互的响应。一般使用javascript技术实现 HTML简介 Hyper Text Markup Language(超文本标记语言)，简称：HTML HTML通过标签来标记要显示的网页中的各个部分。网页文件本身是一种文本文件，通过在文本文件中添加标记符，可以告诉浏览器如何显示其中的内容（例如：文字处理、画面安排、图片显示等） HTML示例 注：Java 文件是需要先编译，再由 java 虚拟机跑起来。但 HTML 文件它不需要编译，直接由浏览器进行解析执行。 书写规范 Html 的代码注释： HTML标签简介 标签格式：&lt; 标签名 &gt;封装的数据&lt; /标签名 &gt; 标签名大小写不敏感 标签拥有自己的属性 基本属性：bgcolor=”red”————可以修改简单的样式效果 事件属性：onclick=”alert(‘你好！’);”———可以直接设置事件响应后的代码 单标签&amp;双标签 单标签格式：&lt;标签名 /&gt;————&lt; br/ &gt;换行，&lt; hr/ &gt;水平线 双标签格式：&lt; 标签名 &gt; …封装的数据…&lt; /标签名 &gt; 标签语法 标签不能交叉嵌套 标签必须正常关闭 属性必须有值，属性值必须加引号 注释不能嵌套 注意:html 代码不是很严谨。有时候标签不闭合，也不会报错。 常用标签介绍font字体标签 特殊字符常用的字符实体 显示结果 描述 实体名称 实体编号 空格 &amp; nbsp; &amp; #160; &lt; 小于 &amp; lt; &amp; #60; &gt; 大于 &amp; gt; &amp; #62; &amp; 和 &amp; amp; &amp; #38; “ 双引 &amp; quot; &amp; #34; ‘ 单引 &amp; apos;（IE不支持） &amp; #39; 其他特殊字符 显示结果 描述 实体名称 实体编号 ¢ 分 &amp; cent; &amp; #162; £ 镑 &amp; pound; &amp; #163; ￥ 日元 &amp; yen; &amp; #165; &sect; 节 &amp; sect; &amp; #167; © 版权 &amp; copy; &amp; #169; ® 已注册 &amp; reg; &amp; #174; &times; 乘号 &amp; times; &amp; #215; &divide; 除号 &amp; divide; &amp; #247; 标题标签 超链接（重点）在网页中所有点击之后可以跳转的内容都是超连接 列表标签 img标签img 标签可以在 html 页面上显示图片。 表格标签（重点） 跨行跨列表格（重点） iframe 框架标签（内嵌窗口）ifarme 标签它可以在一个 html 页面上,打开一个小窗口,去加载一个单独的页面 表单标签（重点）表单就是 html 页面中,用来收集用户信息的所有元素集合.然后把这些信息发送给服务器 表单提交细节 其他标签 CSS 技术CSS 技术介绍 CSS 是「层叠样式表单」。是用于(增强)控制网页样式并允许将样式信息与网页内容分离的一种标记性语言。 语法规则 选择器：浏览器根据“选择器”决定受 CSS 样式影响的 HTML 元素（标签）。 属性 (property) 是你要改变的样式名，并且每个属性都有一个值。属性和值被冒号分开，并 由花括号包围，这样就组成了一个完整的样式声明（declaration），例如：p {color: blue} 多个声明：如果要定义不止一个声明，则需要用分号将每个声明分开。虽然最后一条声明的 最后可以不加分号(但尽量在每条声明的末尾都加上分号） CSS 注释：/注释内容/ CSS和HTML结合方式第一种在标签的 style 属性上修改标签样式。 缺点 如果标签多了。样式多了。代码量非常庞大 可读性非常差 CSS 代码没什么复用性可言 第二种在 head 标签中，使用 style 标签来定义各种自己需要的 CSS 样式 缺点 只能在同一页面内复用代码，不能在多个页面中复用 css 代码 维护起来不方便，实际的项目中会有成千上万的页面，要到每个页面中去修改，工作量太大 第三种把 css 样式写成一个单独的 css 文件，再通过 link 标签引入即可复用。 CSS文件内容 HTML文件内容 CSS选择器标签名选择器 id选择器 class 选择器（类选择器） 组合选择器组合选择器可以让多个选择器共用同一个 css 样式 常用样式字体颜色 宽度 高度 背景颜色 字体样式 红色 1 像素实线边 DIV 居中 文本居中 超连接去下划线 表格细线 列表去除修饰"},{"title":"NewIO","date":"2021-03-20T16:00:00.000Z","url":"/2021/03/21/NewIO/","categories":[["Java","/categories/Java/"]],"content":"NewIO简介 Java NIO(New IO)是从java1.4版本开始引入的一个新的IO API，可以代替标准的Java IO API NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。 Java NIO和IO的主要区别 IO NIO 面向流（Stream Oriented） 面向缓冲区（Buffer Oriented） 阻塞IO（Blocking IO） 非阻塞IO（Non Blocking IO） 无 选择器（Selectors） 缓冲区(Buffer)&amp;通道(Channel)简介 Java NIO系统的核心在于：通道(Channel)和缓冲区 (Buffer)。通道表示打开到 IO 设备(例如：文件、 套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。 缓冲区（Buffer）简介 缓冲区（Buffer）：一个用于特定基本数据类 型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。 Java NIO 中的 Buffer 主要用于与 NIO 通道进行 交互，数据是从通道读入缓冲区，从缓冲区写 入通道中的 Buffer常用子类Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类 ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自 管理的数据类型不同而已。都是通过如下方法获取一个 Buffer 对象 Buffer中的重要概念 容量 (capacity) ：表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改 **限制 (limit)**：第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量 **位置 (position)**：下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制 **标记 (mark)与重置 (reset)**：标记是一个索引，通过 Buffer 中的 mark() 方法 指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这 个 position. 注意：标记、位置、限制、容量遵守以下不变式： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity Buffer常用方法 方法 描述 Buffer clear() 清空缓冲区并返回对缓冲区的引用 Buffer flip() 将缓冲区的界限设置为当前位置，并将当前位置重置为0 int capacity() 返回Buffer的capacity大小 boolean hasRemaining() 判断缓冲区中是否还有元素 int limit() 返回Buffer的界限（limit）的位置 Buffer limit(int n) 将设置缓冲区界限为n，并返回修改后的buffer对象 Buffer mark() 对缓冲区设置标记 int position() 返回缓冲区的当前位置position Buffer position(int n) 将设置缓冲区的当前位置为n,并返回修改后的Buffer对象 int remaining() 返回position和limit之间的元素个数 Buffer reset() 将位置position转到以前设置的mark所在的位置 Buffer rewind() 将位置设为0，取消设置的mark Buffer的数据操作使用Buffer读写数据一般遵循以下四个步骤: 写入数据到Buffer 调用flip()方法 从Buffer中读取数据 调用clear()方法或者compact()方法 当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。 一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用**clear()或compact()**方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。 Buffer 所有子类提供了两个用于数据操作的方法：get() 与 put() 方法 获取 Buffer 中的数据 get()：读取单个字节 get(byte[] dst)：批量读取多个字节到dst中 get(int index)：读取指定索引位置的字节（不会移动position） 放入数据到 Buffer 中 put(byte b)：将给定单个字节写入缓冲区的当前位置 put(byte[] src)：将src中的字节写入缓冲区的当前位置 put(int index,byte b)：将指定字节写入缓冲区的索引位置（不会移动position） 示例代码 直接与非直接缓冲区 非直接缓冲区：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中,遇到大文本的文件时 效率及其低下. 直接缓冲区：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率 注意：其中传统的io和 nio的accocate()都是非直接缓冲区. 通道(Channel)简介 通道（Channel）：由 java.nio.channels 包定义的。Channel 表示 IO 源与目标打开的连接。 Channel 类似于传统的“流”。只不过 Channel 本身不能直接访问数据，Channel 只能与 Buffer 进行交互 Channel实现类 FileChannel：用于读取、写入、映射和操作文件的通道 DatagramChannel：通过UDP读写网络中的数据通道 SocketChannel：通过TCP读写网络中的数据 ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel 获取Channel获取通道的一种方式是对支持通道的对象调用 getChannel() 方法 支持通道的类： 本地IO: FileInputStream FileOutputStream RandomAccessFile 网络IO: DatagramSocket Socket ServerSocket 获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获 取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道 Channel的数据传输将 Buffer 中数据写入 Channel 从 Channel 读取数据到 Buffer 分散(Scatter)和聚集(Gather)分散读取（Scattering Reads）是指从 Channel 中读取的数据“分 散”到多个 Buffer 中。 注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满 聚集写入（Gathering Writes）是指将多个 Buffer 中的数据“聚集” 到 Channel。 注意：按照缓冲区的顺序，写入 position 和 limit 之间的数据到 Channel 。 通道之间的数据传输transferFrom()将数据从源通道传输到其他 Channel transferTo()将数据从源通道传输到其他Channel中 FileChannel常用方法 方法 描述 int read(ByteBuffer dst) 从 Channel 中读取数据到 ByteBuffer long read(ByteBuffer[] dsts) 将 Channel 中的数据“分散”到 ByteBuffer[] int write(ByteBuffer src) 将 ByteBuffer 中的数据写入到 Channel long write(ByteBuffer[] srcs) 将 ByteBuffer[] 中的数据“聚集”到 Channel long position() 返回此通道的文件位置 FileChannel position(long p) 设置此通道的文件位置 long size() 返回此通道的文件的当前大小 FileChannel truncate(long s) 将此通道的文件截取为给定大小 void force(boolean metaData) 强制将所有对此通道的文件更新写入到存储设备中 NIO的非阻塞式网络通信阻塞与非阻塞 传统的 IO 流都是阻塞式的。也就是说，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行 IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理， 当服务器端需要处理大量客户端时，性能急剧下降 Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO可以让服务器端使用一个或有限几个线程来同 时处理连接到服务器端的所有客户端 选择器（Selector） 选择器（Selector） 是 SelectableChannel 对象的多路复用器，Selector 可 以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector 可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心 选择器的应用创建 Selector 向选择器注册通道 当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。 可以监听的事件类型（可使用 SelectionKey 的四个常量表示） 读 : SelectionKey.OP_READ 写 : SelectionKey.OP_WRITE 连接 : SelectionKey.OP_CONNECT 接收 : SelectionKey.OP_ACCEPT 若注册时不止监听一个事件，则可以使用“位或”操作符连接 SelectionKey：表示 SelectableChannel 和 Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整 数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。 方法 描述 int interestOps() 获取感兴趣事件集合 int readyOps() 获取通道已经准备就绪的操作的集合 SelectableChannel channel() 获取注册通道 Selector selector() 返回选择器 boolean isReadable() 检测Channel中读事件是否就绪 boolean isWritable() 检测Channel中写事件是否就绪 boolean isConnectable() 检测Channel中连接是否就绪 boolean isAcceptable() 检测Channel中接收是否就绪 Selector常用方法 方法 描述 Set&lt; SelectionKey &gt; keys() 所有的 SelectionKey 集合。代表注册在该Selector上的Channel selectedKeys() 被选择的 SelectionKey 集合。返回此Selector的已选择键集 int select() 监控所有注册的Channel，当它们中间有需要处理的 IO 操作时， 该方法返回，并将对应得的 SelectionKey 加入被选择的 SelectionKey 集合中，该方法返回这些 Channel 的数量。 int select(long timeout) 可以设置超时时长的 select() 操作 int selectNow(); 执行一个立即返回的 select() 操作，该方法不会阻塞线程 Selector wakeup() 使一个还未返回的 select() 方法立即返回 void close() 关闭该选择器 SocketChannelJava NIO中的SocketChannel是一个连接到TCP网络套接字的通道 操作步骤： 打开 SocketChannel 读写数据 关闭 SocketChannel Java NIO中的 ServerSocketChannel 是一个可以 监听新进来的TCP连接的通道，就像标准IO中 的ServerSocket一样。 DatagramChannel Java NIO中的DatagramChannel是一个能收发 UDP包的通道 操作步骤 打开 DatagramChannel 接收/发送数据 管道（Pipe） Java NIO 管道是2个线程之间的单向数据连接。 Pipe有一个source通道和一个sink通道。数据会 被写到sink通道，从source通道读取。 读写操作"},{"title":"JUC","date":"2021-03-17T16:00:00.000Z","url":"/2021/03/18/JUC/","categories":[["Java","/categories/Java/"]],"content":"Java JUC简介在Java 5.0 提供了 java.util.concurrent （简称 JUC ）包，在此包中增加了在并发编程中很常用 的实用工具类，用于定义类似于线程的自定义子 系统，包括线程池、异步 IO 和轻量级任务框架。 提供可调的、灵活的线程池。还提供了设计用于 多线程上下文中的 Collection 实现等 内存可见性 内存可见性：当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。 可见性错误：当读操作与写操作在不同的线程中执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。 我们可以通过同步来保证对象被安全地发布。除此之外我们也可以 使用一种更加轻量级的 volatile 变量。 volatile关键字多个线程访问共享数据时，保证内存中的数据是可见的。相较于synchronized是一种较为轻量级的同步策略（因为它不会引起线程上下文的切换和调度）。 注意: volatile不具备”互斥性”（当一个线程访问主内存时，其他线程依旧可以访问） volatile不能保证变量的”原子性”（不可分割） 可见性问题内存可见性：当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。 执行后发现，子线程执行时已经将 flag 设置成 true，但主线程执行时没有读到 flag 的最新值，导致控制台没有输出上面的句子。 问题原因JMM（Java内存模型）机制问题 JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。 JMM 的规定： 所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。 线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量。 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。 JMM抽象示意图 解决方法两种方案：加锁或使用volatile关键字 方法一：synchronized 原因：当一个线程进入 synchronized 代码块后，线程获取到锁，会清空本地内存，然后从主内存中拷贝共享变量的最新值到本地内存作为副本，执行代码，又将修改后的副本值刷新到主内存中，最后线程释放锁。 PS：除了 synchronizer 外，其它锁也能保证变量的内存可见性。 方法二：volatile关键字 原因：使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 CPU 总线嗅探机制告知其他线程该变量副本已经失效，需要重新从主内存中读取。 volatile 保证了不同线程对共享变量操作的可见性，也就是说一个线程修改了 volatile 修饰的变量，当修改后的变量写回主内存时，其他线程能立即看到最新值。 volatile的原子性问题原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。 在多线程环境下，volatile 关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性。也就是说，多线程环境下，使用 volatile 修饰的变量是线程不安全的。 可以使用锁机制，或者使用原子类（如 AtomicInteger）解决 注意：对任意单个使用 volatile 修饰的变量的读 / 写是具有原子性。但类似于 flag = !flag 这种复合操作不具有原子性。简单地说就是，单纯的赋值操作是原子性的。 总结 volatile 修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值；或者作为状态变量，如 flag = ture，实现轻量级同步。 volatile 属性的读写操作都是无锁的，它不能替代 synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是低成本的。 volatile 提供了可见性，任何一个线程对其的修改将立马对其他线程可见。volatile 属性不会被线程缓存，始终从主存中读取。 volatile 可以使纯赋值操作是原子的，如 boolean flag = true; falg = false。 原子变量,CAS算法原子变量类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可 将 volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。 类 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对 相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。 AtomicIntegerArray、AtomicLongArray 和AtomicReferenceArray 类进一步扩展了原子操 作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方 面也引人注目，这对于普通数组来说是不受支持的。 核心方法：boolean compareAndSet(expectedValue, updateValue) java.util.concurrent.atomic 包下提供了一些原子操作的常用类 AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference AtomicIntegerArray 、AtomicLongArray AtomicMarkableReference AtomicReferenceArray AtomicStampedReference CAS算法 CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器 操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。 CAS 是一种无锁的非阻塞算法的实现。 函数公式：CAS(V,E,N)。 V：表示要更新的变量 E：表示预期值 N：表示新值 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的 值，否则不会执行任何操作。 优点它不会像synchronized一样，当一个线程访问共享数据的时候，别的线程都在阻塞。synchronized不管是否有线程冲突都会进行加锁。由于CAS是非阻塞的，它死锁问题天生免疫，并且线程间的相互影响也非常小，更重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，所以它要比锁的方式拥有更优越的性能。 实现过程原理图： 如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作。 模拟CAS算法实现 ConcurrentHashMap锁分段机制简介 ConcurrentHashMap 同步容器类是Java 5 增加的一个线程安全的哈希表。对 与多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段” 机制替代 Hashtable 的独占锁。进而提高性能。 此包还提供了设计用于多线程上下文中的 Collection 实现： ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、 CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给 定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap， ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远 大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。 ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 底层实现原理jdk7版本 jdk8版本 改进一：取消segments字段，直接采用transient volatile HashEntry&lt;K,V&gt; table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。 改进二：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中。如果hash之后散列的很均匀，那么table数组中的每个队列长度主要为0或者1。但实际情况并非总是如此理想，虽然ConcurrentHashMap类默认的加载因子为0.75，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。 基本操作读操作因为读操作不会改变数值的大小，所以它是不加锁的，而且HashEntry加了volatile关键字，也可以保证读取到的值是最新值。同时读操作可以多个线程进行操作，即至少可以有16个线程操作，至多无上限，只要在CPU的能力承受范围内即可。 写操作具有锁机制，可以同时让16（默认容量的）个线程进行操作，每个线程进入各自所需寻找的Segment数组中的HashEentry数组进行操作，大大的提高了操作效率。 主要特点 存储方面采用了数组加数组加链表的形式 在线程对每部分的Segment段读取数据时，可以多个线程访问，效率较高；在线程对每部分的Segment段写数据时，加锁机制启动，只许一个进入，线程安全 安全性方面采用了分段的锁机制机，即保证了多线程的安全性，又提高了访问的效率 HashMap、HashTable和ConcurrentHashMap的区别？底层结构 HashMap是数组加链表 HashTable是数组加链表 ConcurrentHashMap是数组加数组加链表 扩容 HashMap是初始容量右移一位加一 HashTable是初始容量右移一位 ConcurrentHashMap是初始的Segment数组保持不变，只将HashEntry的数组进行扩容 继承关系 HashMap是继承于 extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable HashTable是继承于extends Dictionary&lt;K,V&gt;implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable ConcurrentHashMap是继承于 extends AbstractMap&lt;K, V&gt;implements ConcurrentMap&lt;K, V&gt;, Serializable 在线程安全方面： HashMap在单线程下是安全的，多线程下不安全， HashTable在多线程下是安全的，因为它在基本操作前面都加上了synchronized锁，即就是就算在多个线程操作的时候，只要有一个线程进入了基本方法内，其他的线程就必须等待。只有当第一个线程操作结束，释放了锁，其他的线程才可以进行操作。虽然说在多线程操作的时候线程是安全的但是效率比较低，毕竟那么多的线程就在等一把锁。 JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。 CountDownLatch闭锁简介 CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作 之前，它允许一个或多个线程一直等待。 闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行 确保某个计算在其需要的所有资源都被初始化之后才继续执行 确保某个服务在其依赖的所有其他服务都已经启动之后才启动 等待直到某个操作所有参与者都准备就绪再继续执行 CountDownLatch 定义了一个计数器，和一个阻塞队列， 当计数器的值递减为0之前，阻塞队列里面的线程处于挂起状态，当计数器递减到0时会唤醒阻塞队列所有线程，这里的计数器是一个标志，可以表示一个任务一个线程，也可以表示一个倒计时器，CountDownLatch可以解决那些一个或者多个线程在执行之前必须依赖于某些必要的前提业务先执行的场景。 常用方法 代码实现 上面代码中计算10个LanchDemo线程计算0-50000的偶数，并计算所用时间。当调用LatchDemo的线程时，10个线程和计算时间的主线程同时运行，没办法得到最后的计算时间，所以运用latch.await();函数来让LanchDemo进入阻塞状态，并用CountDown();函数对计数器进行递减1操作，等待10个全部执行完毕后，计数器递减为0，当前线程会唤醒阻塞队列中的所有线程。 实现Callable接口简介 Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常。 Callable 需要依赖FutureTask ，FutureTask 也可以用作闭锁。 代码实现 Lock同步锁简介 在 Java 5.0 之前，协调共享对象的访问时可以使用的机 制只有 synchronized 和 volatile 。Java 5.0 后增加了一些 新的机制，但并不是一种替代内置锁的方法，而是当内 置锁不适用时，作为一种可选择的高级功能。 ReentrantLock 实现了 Lock 接口，并提供了与 synchronized 相同的互斥性和内存可见性。但相较于 synchronized 提供了更高的处理锁的灵活性。 应用场景当一个代码块被synchronized修饰了，一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况： 获取锁的线程执行完了该代码块，然后线程释放对锁的占有 线程执行发生异常，此时JVM会让线程自动释放锁 那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能地等待，这多么影响程序执行效率。 因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断） 代码实现 生产者消费者问题使用Synchronized和Object中的wait()&amp;notifyAll()实现 使用Lock&amp;Condition控制线程通信实现Condition Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用 法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关 联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版 本中的不同。 在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是 await、signal 和 signalAll。 Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得 Condition 实例，请使用其 newCondition() 方法。 题目：线程按序交替编写一个程序，开启三个线程，这三个线程的ID分别为A,B,C，每个线程将自己的ID在屏幕上打印10遍，要求输出的结果必须按顺序显示如：ABCABCABC…依次递归 ReadWriteLock读写锁简介 ReadWriteLock 维护了一对相关的锁，一个用于只读操作， 另一个用于写入操作。只要没有 writer，读取锁可以由 多个 reader 线程同时保持。写入锁是独占的。 ReadWriteLock 读取操作通常不会改变共享资源，但执行 写入操作时，必须独占方式来获取锁。对于读取操作占 多数的数据结构。 ReadWriteLock 能提供比独占锁更高 的并发性。而对于只读的数据结构，其中包含的不变性 可以完全不需要考虑加锁操作。 示例代码 互斥锁一次只允许一个线程访问共享数据，哪怕进行的是只读操作；读写锁允许对共享数据进行更高级别的并发访问：对于写操作，一次只有一个线程（write线程）可以修改共享数据，对于读操作，允许任意数量的线程同时进行读取。 与互斥锁相比，使用读写锁能否提升性能则取决于读写操作期间读取数据相对于修改数据的频率，以及数据的争用——即在同一时间试图对该数据执行读取或写入操作的线程数。 线程八锁 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用 其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻 内，只能有唯一一个线程去访问这些synchronized方法 锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的 synchronized方法 所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实 例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获 取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实 例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非 静态同步方法释放锁就可以获取他们自己的锁。 所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对 象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个 静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取 锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同 步方法之间，只要它们同一个类的实例对象！ 代码示例 线程八锁关键 非静态方法的锁默认为 this，静态方法的锁为对应的class 实例 在某一时刻内，只能有一个线程持有锁，无论几个方法。 线程池简介 提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。 第四种获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在 执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行 任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。 工具类: Executors ExecutorService newFixedThreadPool():创建固定大小的线程池 ExecutorService newCachedThreadPool():缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。 ExecutorService newSingleThreadExecutor(): 创建单个线程池。线程池中只有一个线程 ScheduledExecutorService newScheduledThreadPool():创建固定大小的线程，可以延迟或定时的执行任务。 线程池的体系结构 java.util.concurrent.Executor : 负责线程的使用与调度的根接口 –ExecutorService 子接口: 线程池的主要接口 –ThreadPoolExecutor 线程池的实现类 –ScheduledExecutorService 子接口：负责线程的调度 代码实现 线程调度一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令。 ForkJoinPool分支/合并框架 工作窃取Fork/Join 框架就是在必要的情况下，将一个大任务，进行**拆分(fork)**成 若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总。 Fork/Join 框架与线程池的区别 采用 “工作窃取”模式（work-stealing）： 当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加 到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队 列中。 相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务 的处理方式上.在一般的线程池中，如果一个线程正在执行的任务由于某些 原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中， 如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理 该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了 线程的等待时间，提高了性能。 代码实例"},{"title":"JDBC核心技术2","date":"2021-03-16T16:00:00.000Z","url":"/2021/03/17/JDBC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF2/","categories":[["JDBC","/categories/JDBC/"]],"content":"数据库事务数据库事务介绍 事务：一组逻辑操作单元，是数据从一种状态变换到另一种状态 事务处理（事务操作）：保证所有事物都作为一个工作单元来执行，即使出现故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交（commit）,那么这些修改就永久地保存下来；要么数据库管理系统将放弃所做的所有修改，整个事务回滚（rollback）到最初状态。 为确保数据库中的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部退回到开始状态。 JDBC事务处理 数据一旦被提交，就不可回滚。 数据什么时候意味着提交？ 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一连接下。 JDBC程序中为了让多个SQL语句作为一个事务执行： 调用Connection对象的setAutoCommit(false);以取消自动提交事务 在所有的SQL语句都成功执行后，调用Commit();方法提交事务 在出现异常时，调用rollback();方法回滚事务 若此时Connection没有被关闭，还可能被重复利用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 例如：用户AA向用户BB转账100 对数据库的操作的方法为： 事务的ACID属性 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另一个一致性状态。 隔离性（Isolation） 事物的隔离性是指一个事务的执行不能被其他事务干扰，即一个事物内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 数据库的并发问题 对于同时运行的多个事务，当这些事务访问数据库中的相同数据时，如果没有采取必要的隔离机制，就会导致各种并发问题： 脏读：对于两个事务T1，T2，T1已经读取了被T2更新但还没有被提交的字段。之后，若T2回滚，T1读取的内容就是临时且无效的。 不可重复读：对于两个事务T1，T2，T1读取了一个字段，然后T2更新了该字段。之后，T1再次读取同一个字段，值就不同了。 幻读：对于两个事务T1，T2，T1从一个表中读取了一个字段，然后T2在该表中插入了一些新的行。之后，如果T1再次读取同一个表，就会多出几行。 数据库事务的隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性弱。 四种隔离级别 数据库提供的4种事务隔离级别 隔离级别 描述 READ UNCOMMITED（读未提交数据） 允许事务读取未被其他事务提交的变更。脏读，不可重复读和幻读的问题都会出现 READ COMMITED（读已提交数据） 只允许事务读取已经被其他事务提交的变更。可以避免脏读，但不可重复读和幻读问题仍然可能出现 REPEATABLE READ（可重复读） 确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事物对这个字段进行更新，可以避免脏读和不可重复读，但幻读的问题仍然存在 SERIALIZABLE（串行化） 确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作，所有并发问题都可以避免，但性能十分低下 Oracle支持的两种事务隔离级别：READ COMMITED,SERIALIZABLE。Oracle默认的事务隔离级别为：READ COMMITED. Mysql支持四种事务隔离级别。Mysql默认的事务隔离级别为：REPEATABLE READ. 在Mysql中设置事务隔离级别 每启动一个mysql程序，就会获得一个单独的数据库连接，每个数据库连接都有一个全局变量@@tx_isolation,表示当前的事务隔离级别。 查看当前的隔离级别: 设置当前 mySQL 连接的隔离级别: 设置数据库系统的全局的隔离级别: 补充操作： 创建mysql数据库的用户： 授予权限 DAO及相关实现类 DAO:Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create,Retrival,Update,Delete）,而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更利于代码的维护和升级 层次结构： 创建底层DAO（封装了针对于数据表的通用的操作） 创建DAO接口（用于规范针对于customers表的常用操作） 创建DAOImpl实现类（继承父类和接口，具体实现功能） 例如：创建customer表的DAO BaseDAO: CustomerDAO: CustomerImpl: Customer类： 数据库连接池JDBC数据库连接池的必要性 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤： 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接 这种开发模式，存在的问题： 普通的JDBC数据库连接使用DriverManager来获取，每次向数据库建立连接的时候都要将Connection加载到内存中，再验证用户名和密码（得花费0.05s~1s的时间）。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（内存泄漏：保留下来却永远不再使用的对象引用。） 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 数据库连接池技术 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。 数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 数据库连接池技术的优点 1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 C3P0数据库连接池 获取连接方式一 获取连接方式二 其中，src下的配置文件为：【c3p0-config.xml】 注意： c3p0-0.9.2版本后需再导入数据库连接池的辅助包mchange-commons-java-x.x.x.x.jar。 mysql8.0需要注意c3p0版本。 DBCP数据库连接池 DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件： Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 配置属性说明 属性 默认值 说明 initialSize 0 连接池启动时创建的初始化连接数量 maxActive 8 连接池中可同时连接的最大的连接数 maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 poolPreparedStatements false 开启池的Statement是否prepared maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数 minEvictableIdleTimeMillis 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间 removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接 removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 获取连接方式一： 获取连接方式二： 其中，src下的配置文件为：【dbcp.properties】 Druid（德鲁伊）数据库连接池Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。 其中，src下的配置文件为：【druid.properties】 详细配置参数： 配置 缺省 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this) url 连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里： driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 Apache-DBUtils实现CRUD操作Apache-DBUtils简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 API介绍： org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler 工具类：org.apache.commons.dbutils.DbUtils API包说明： 对应的jar包需build path到当前工程下 ResultSetHandler，此接口用于处理数据库查询操作得到的结果集。不同的结果集的情形，由其不同的子类来实现 QueryRunner，提供数据库操作的一系列重载的update()和query()操作 主要API的使用DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLException。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 插入 删除 ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 接口的主要实现类： ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List ScalarHandler：查询单个值对象 测试： 总结"},{"title":"JDBC核心技术1","date":"2021-03-13T16:00:00.000Z","url":"/2021/03/14/JDBC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF1/","categories":[["JDBC","/categories/JDBC/"]],"content":"JDBC概述数据的持久化 持久化(persistece)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以“固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存在磁盘文件、XML数据文件中。 Java中的数据存储技术在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO(Java Data Object)技术 第三方O/R工具，如Hibernate，Mybatis等 JDBC是java访问数据库的基石，JDO，Hibernate、Mybatis等只是更好的封装了JDBC JDBC介绍JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统，通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准java类库，（java.sql.javax.sql）使用这些类库可以以一种标准的方法，方便的访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多了解，从而大大简化和加快了开发过程。 总结：java应用程序直接访问数据库可行，但这意味着java应用程序没有更好的可移植性。因此并不建议这么做。 JDBC体系结构JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。 不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ​ ————面向接口编程 JDBC接口(API)包括两个层次： 面向应用API：Java API，抽象接口，供应用程序开发人员使用(连接数据库，执行SQL语句，获得结果)。 面向数据库API：Java Driver API，供开发商开发数据库驱动程序用。 JDBC程序编写步骤 开始——》导入java.sql包——》 两种方式： SQL Server：JDBC-ODBC桥方式（建立数据源） Oracle、Mysql：纯Java驱动方式（附加相应产商提供的驱动） ——》加载并注册驱动程序——》创建Connection对象——》创建Statement对象——》执行SQL语句——》 不同功能： 查询：使用ResultSet对象——》关闭ResultSet对象——》关闭Statement对象——》关闭Connection对象——》结束。 更新：关闭Statement对象 ——》关闭Connection对象——》结束。 补充：ODBC（Open Database Conectivity,开放式数据库连接），是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由ODBC驱动程序将调用转换成为对特定的数据库的调用请求。 获取数据库连接要素一：Driver接口实现类Driver接口介绍 java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 Oracle的驱动：oracle.jdbc.driver.OracleDriver Mysql的驱动：com.mysql.jdbc.Driver 将连接数据库所需的jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹存入。 在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path。 注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可 加载与注册JDBC驱动 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”); 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序 使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来驱动注册 通常不用显式调用DriverManager类的registerDriver()方法来注册驱动程序类的实例，因为Driver接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用DriverManager.registerDriver()方法来注册自身的一个实例。 Mysql的Driver实现类的源码： 要素二：URL JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 例如： 几种常用数据库的 JDBC URL MySQL的连接URL编写方式： jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值 jdbc:mysql://localhost:3306/test jdbc:mysql://localhost:3306/test**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql://localhost:3306/test?user=用户名&amp;password=密码 Oracle9i的连接URL编写方式： jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 jdbc:oracle:thin:@localhost:1521:test SQLServer的连接URL编写方式： jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称 jdbc:sqlserver://localhost:1433:DatabaseName=test 要素三：用户名和密码user,password可以用“属性名=属性值”方式告诉数据库 可以调用DriverManager类的getConnection()方法建立到数据库的连接 数据库连接方式举例方式一： 说明：上述代码中显式出现了第三方数据库的API 方式二： 说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。 方式三: 说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。 方式四： 说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。 方式五（推荐使用）： 其中，配置文件声明在工程的src目录下：【jdbc.properties】 说明：使用配置文件的方式保存配置信息，在代码中加载配置文件 注意：MySQL8.0以下版本应改成：dirverClass=com.mysql.jdbc.Driver 使用配置文件的好处： ①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码②如果修改了配置信息，省去重新编译的过程。 使用PreparedStatement实现CRUD操作操作和访问数据库数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 使用Statement操作数据表的弊端通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： 但是使用Statement操作数据表存在弊端： 存在拼串操作，繁琐 存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 例如： 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。 PreparedStatement的使用PreparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 Java与SQL对应数据类型转换表 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 使用PreparedStatement实现增、删、改操作 使用PreparedStatement实现查询操作 说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。 ResultSet与ResultSetMetaDataResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现 ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。 例如: getInt(1), getString(“name”) 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。 ResultSet 接口的常用方法： boolean next() getString() … ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象 ResultSetMetaData meta = rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名 getColumnCount()：返回当前 ResultSet 对象中的列数。 getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 isNullable(int column)：指示指定列中的值是否可以为 null。 isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？ ​ 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData 问题2：关于ResultSetMetaData 如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法即可 获取 ResultSet 中有多少列： 调用 ResultSetMetaData 的 getColumnCount() 方法 获取 ResultSet 每一列的列的别名是什么： 调用 ResultSetMetaData 的getColumnLabel() 方法 资源的释放 释放ResultSet, Statement,Connection。 数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。 JDBC API小结 两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 sql是需要结合列名和表的属性名来写。注意起别名。 两种技术 JDBC结果集的元数据：ResultSetMetaData 获取列数：getColumnCount() 获取列的别名：getColumnLabel() 通过反射，创建指定类的对象，获取指定的属性并赋值 "},{"title":"关于最近学习状态调整这件事","date":"2021-02-28T16:00:00.000Z","url":"/2021/03/01/%E5%B0%91%E5%B9%B4%E3%81%AE%E6%97%A5%E5%B8%B802/","categories":[["少年の日常","/categories/%E5%B0%91%E5%B9%B4%E3%81%AE%E6%97%A5%E5%B8%B8/"]],"content":"正所谓计划赶不上变化（借口），本假期接近尾声，但是学习进度着实是慢了一些。 3月10日到校，预计开学时会看完Oracle数据库。 时光飞逝，找实习的日子不远了，时不我待！加油！ 目前学习状态需要好好调整，空余时间还是多看看技术类文章为好。 根据目前课表来看课程虽然不算少，但是空闲时间也还是有。所以，空闲时间还是以继续学习尚硅谷的课程为主。 游戏的话。。。。混蛋！别想着玩了！ 希望自己能坚持下去 （话说这东西写出来也就只有自己看吧。。。）"},{"title":"MySQL","date":"2021-02-05T16:00:00.000Z","url":"/2021/02/06/202126mysql/","categories":[["MySQL","/categories/MySQL/"]],"content":"启动MySQL服务通过计算机管理方式： ​ 右击计算机—管理—服务—启动或停止MySQL服务 通过命令行方式： ​ 启动：net start mysql服务名 ​ 停止：net stop mysql服务名 MySQL服务端的登录和退出控制台输入 登录：mysql -h 主机IP -P 端口 -u 用户名 -p密码 退出：exit 如果没有写-h 主机，默认就是本机 吐过没有写-P 端口，默认就是3306 MySQL语法规范 不区分大小写 每句话用;或者\\g结尾 各子句一般分行写 关键字不能缩写也不能分行 用缩进提高语句的可读性 MySQL常见命令 show database; 查看当前所有的数据库 create database 数据库名; 创建数据库 drop database 数据库名; 删除数据库 create database 数据库名 character set 字符集; 创建使用指定字符集数据库（默认UTF8） use 库名; 打开指定的库 show tables; 查看当前库的所有表 show tables from 库名; 查看其它库的所有表 create table 表名（列名 列类型,列名 列类型…）; 创建表 desc 表名; 查看表结构 登录到mysql服务端 :select version();没有登陆mysql客户端 :mysql –version/mysql –V 查看服务器版本 mysqldump -u 用户名 -p -B 数据库1 数据库2 数据库n &gt;文件名.sql 备份数据库 Source 文件名.sql 恢复数据库 注释： 单行注释：#注释文字 或 –注释文字 多行注释：/* 注释文字 */ MySQL三层结构所谓安装Mysql数据库，就是在主机安装一个数据库管理系统(DBMS)，这个管理程序可以管理多个数据库，一个数据库一管理多个表，以保存数据。 数据操纵语句(DML)用于添加、删除、修改、查询数据库记录，并检查数据完整性。 插入语法：INSERT INTO 表名(字段名，…) ​ VALUES(值1，…); 特点： 字段类型和值类型一致或兼容，而且一一对应 可以为空的字段，可以不用插入值，或用null填充 不可以为空的字段，必须插入值 字段个数和值的个数必须一致 字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致 修改修改单表语法 修改多表语法 删除方式一：DELETE语句 单表的删除： 多表的删除： 方式二：truncate语句 两种方式的区别： truncate不能加WHERE条件，而DELETE可以加WHERE条件 truncate效率高一点 truncate删除带自增长列的表后，如果再插入数据，数据从1开始 delete删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始 truncate删除不能回滚，delete删除可以回滚 数据查询语句(DQL)基本SELECT语句 列的别名 重命名一个列 便于计算 紧跟列名（也可以在列名和别名之间加入关键字’AS‘，别名使用双引号，以便于在别名中包含空格或特殊字符并区分大小写） 例如： 字符串 字符串可以是 SELECT 列表中的一个字符,数字,日期。 日期和字符只能在单引号中出现。 每当返回一行时，字符串被输出一次。 过滤WHERE子句使用WHERE子句，将不满足条件的行过滤掉。 WHERE子句紧跟FROM子句 比较运算 操作符 含义 = 等于（不是==） &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 &lt;&gt; 不等于（也可以是!=） PS:赋值使用=符号 其他比较运算 操作符 含义 BETWEEN…AND… 在两个值之间（包含边界） IN(值1,值2,值3…) 等于值列表中的一个 LIKE 模糊查询 IS NULL 空值 LIKE： 使用LIKE运算选择类似的值 选择条件可以包含字符或数字： ——%代表0个或多个字符（任意个字符） ——_代表一个字符。 ‘%’和’_’可以同时使用 NULL： 使用IS (NOT) NULL判断是否为空值 逻辑运算 操作符 含义 AND 并 OR 或 NOT 否 ORDER BY子句使用ORDER BY子句排序 ——ASC（ascend）：升序 ——DESC（descend）：降序 ORDER BY子句在SELECT语句的结尾 常见函数 操作符 含义 concat 拼接 substr 截取子串 upper 转换成大写 lower 转换成小写 trim 去掉前后指定的空格和字符 Itrim 去掉左边空格 rtrim 去掉右边空格 replace 替换 lpad 左填充 rpad 右填充 instr 返回字串第一次出现的索引 length 获取字节个数 数学函数 操作符 含义 round 四舍五入 rand 随机数 floor 向下取整 ceil 向上取整 mod 取余 truncate 截断 日期函数 操作符 含义 now 当前系统日期+时间 curdate 当前系统日期 curtime 当前系统时间 str_to_date 将字符转换成日期 date_format 将日期转换为字符 格式符 功能 %Y 四位的年份 %y 2位的年份 %m 月份（01，02…11，12） %c 月份（1，2…11，12） %d 日（01，02…） %H 小时（24小时制） %h 小时（12小时制） %i 分钟（00，01…59） %s 秒（00，01，…59） 流程控制函数if：处理双分支 case语句：处理多分支 ​ 情况1：处理等值判断 ​ 情况2：处理条件判断 条件函数 操作符 含义 version 版本 database 当前库 user 当前连接用户 分组函数分组函数作用于一组数据，并对一组数据返回一个值。 操作符 含义 SUM（列名） 求和 MAX（列名） 最大值 MIN（列名） 最小值 AVG（列名） 平均值 COUNT（） 计数 特点： 以上五个分组函数都忽略null值，除了count（*） sum和avg一般用于处理数值型max、min、count可以处理任何数据类型 都可以搭配distinct使用，用于统计去重后的结果 count的参数可以支持：字段、*、常量值，一般放1 建议使用 count(*) 分组查询&amp;过滤分组语法： 特点： 1、可以按单个字段分组2、和分组函数一同查询的字段最好是分组后的字段3、分组筛选 针对的表 位置 关键字分组前筛选： 原始表 GROUP BY的前面 WHERE分组后筛选： 分组后的结果集 GROUP BY的后面 HAVING 4、可以按多个字段分组，字段之间用逗号隔开5、可以支持排序6、having后可以支持别名 过滤分组：HAVING子句 使用 HAVING 过滤分组: 行已经被分组。 使用了组函数。 满足HAVING 子句中条件的分组将被显示。 多表连接查询如果连接条件省略或者无效则会出现笛卡尔乘积 解决办法：WHERE处添加连接条件 传统模式下的链接：等值连接——非等值连接 等值连接的结果=多个表的交集 n表连接，至少需要n-1个连接条件 多个表不分主次，没有顺序要求 一般为表起别名，提高阅读性和性能 在表中有相同列时，在列名之前加上表名前缀 sql99语法：通过join关键字实现连接 自然连接中是以具有相同名字的列为连接条件的。 可以使用 ON 子句指定额外的连接条件。 这个连接条件是与其它条件分开的。 ON 子句使语句具有更高的易读性。 分类： 内连接：[inner] join on: 也称为等值连接，返回两张表都满足条件的部分 外连接： ——左外连接 left [outer] join on: 取左边的表的全部，右边的表按条件，符合的显示，不符合则显示null 例如： ——右外连接 right [outer] join on: 取右边表的全部，左边的表按条件，符合的显示，不符合则显示null 例如： ——全外连接 full [outer] join on 全外连接是在结果中除了显示满足连接的条件的行外，还显示了join两侧表中所有满足检索条件的行 ——交叉连接 cross join 返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积 SQL99语法多表联查 PS：内连接和where SQL中关键字的执行顺序：from-&gt;on-&gt;join-&gt;where-&gt;group by-&gt;having-&gt;select-&gt;distinct-&gt;union-&gt;order by 如果两张表的数据量都比较大的话，那样就会占用很大的内存空间这显然是不合理的。所以，我们在进行表连接查询的时候一般都会使用JOIN xxx ON xxx的语法，ON语句的执行是在JOIN语句之前的，也就是说两张表数据行之间进行匹配的时候，会先判断数据行是否符合ON语句后面的条件，再决定是否JOIN。 当两张表的数据量比较大，又需要连接查询时，应该使用 FROM table1 JOIN table2 ON xxx的语法，避免使用 FROM table1,table2 WHERE xxx 的语法，因为后者会在内存中先生成一张数据量比较大的笛卡尔积表，增加了内存的开销。 子查询含义：一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询 特点： 子查询都放在小括号内 子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧 子查询优先于主查询执行，主查询使用了子查询的执行结果 子查询根据结果的行数不同分为以下两类： 单行子查询 结果集只有一行 一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 非法使用子查询的情况： 子查询的结果为一组值 子查询的结果为空 多行子查询 结果集有多行 一般搭配多行操作符使用：any、all、in、not in in/not in:属于子查询结果的任意一个就行 any和all往往可以用其他查询代替 子查询中的HAVING子句 首先执行子查询 向主查询中的HAVING子句返回结果 分页查询实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句 语法： 特点： 起始条目索引从0开始 limit语句放在查询语句的最后 公式：SELECT*FROM 表LIMIT(page-1)*sizePerPage,sizePerPage sizePerPage:每页显示条目数 page：要显示的页数 联合查询引入：union 联合、合并 语法： 特点： 多条查询语句的查询列数必须是一致的 多条查询语句的查询的列的类型几乎相同 union代表去重，union all代表不去重 数据定义语句(DDL)用于库和表的创建、修改、删除 库和表的管理 库的管理： 表的管理： 常见类型 整型:Tinyint、Smallint、Mediumint、Int、Integer、Bigint 小数：定点型:DEC(M,D)/DECIMAL(M,D) ​ 浮点型:float、double 字符型:char(M)、varchar(M) 日期型:date、datetime、timestamp、time、year Timestamp支持的时间范围较小，取值范围： 19700101080001——2038年的某个时间 Datetime的取值范围：1000-1-1 ——9999—12-31 timestamp和实际时区有关，更能反映实际的日 期，而datetime则只能反映出插入时的当地时区 timestamp的属性受Mysql版本和SQLMode的影响 很大 Blob型：用于存储二进制数据。类似于char和varchar，不同的是它们包含二进制字符串而不包含非二 进制字符 Enum型：要求插入的值必须属于列表中指定的值之一 如果列表成员为1255，则需要1个字节存储 如果列表成员为25565535，则需要2个字节存储 最多需要65535个成员！ Set型：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区 别是：SET类型一次可以选取多个成员，而Enum只能选一个 根据成员个数不同，存储所占的字节也不同 成员数 字节数 1~8 1 9~16 2 17~24 3 25~32 4 33~64 8 约束 为了保证数据的一致性和完整性，SQL规范以约束的方式对表的数据进行额外的条件限制。 约束是表级的强制规定 可以在创建表时规定约束（通过CREATE TABLE 语句），或者在表创建以后也可以（通过ALTER TABLE 语句） 六种约束 NOT NULL 非空约束，规定某个字段不能为空 UNIQUE 唯一约束，规定某个字段在整个表中是唯一的 PRIMARY KEY 主键（非空且唯一） FOREIGN KEY 外键 CHECK 检查约束 DEFAULT 默认值 注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果 根据约束列的限制，约束可以分为： 单列约束：每个约束只约束一列 多列约束：每个约束可约束多列数据 根据约束的作用范围，约束可分为： 列级约束只能作用在一个列上，跟在列的定义后面 表级约束可以作用在多个列上，不与列一起，而是单独定义 创建表时添加约束 修改表时添加或删除约束 自增长列特点： 不用手动插入值，可以自动提供序列值，默认从1开始，步长为1auto_increment_increment如果要更改起始值：手动插入值如果要更改步长：更改系统变量set auto_increment_increment=值; 一个表至多有一个自增长列 自增长列只能支持数值型 自增长列必须为一个key NOT NULL约束 非空约束用于确保当前列的值不为空值，非空约束只能出现在表对象的列上。 Null类型特征： 所有的类型的值都可以是null，包括int、float等数据类型 空字符串“”不等于null，0也不等于null 例： UNIQUE约束 同一个表可以有多个唯一约束，多个列组合的约束。在创建唯一约束的时候，如果不给唯一约束名称，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引 例： PRIMARY KEY约束 主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值 如果是多列组合的主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。 每个表最多只允许一个主键，建立主键约束可以在列级别创建，也可以在表级别创建。 MySQL的主键名总是PRIMARY，当创建主键约束时，系统默认会在所在的列和列组合上建立对应的唯一索引。 例： 注意：PRIMARY KEY和UNIQUE比较 区别： 一个表只能有一个主键，但可以有多个唯一键 主键不允许为空，唯一键可以为空 相同点： 都具有唯一性 都支持组合键，但不推荐 FOREIGN KEY约束 外键约束是保证一个或两个表之间的参照完整性， 外键是构建于一个表的两个字段或是两个表的两个字 段之间的参照关系。 从表的外键值必须在主表中能找到或者为空。当主 表的记录被从表参照时，主表的记录将不允许删除， 如果要删除数据，需要先删除从表中依赖该记录的数 据，然后才可以删除主表的数据。 插入数据，先插入主表。删除数据，先删除从表 注意：外键约束的参照列，在主表中引用的只能是 主键或唯一键约束的列 同一个表可以有多个外键约束 注意： FOREIGN KEY：在表级指定子表中的列 REFERENCES：表示在父表中的列 ON DELETE CASCADE(级联删除): 当父表中的列被删除 时，子表中相对应的列也被删除 ON DELETE SET NULL(级联置空): 子表中相应的列置空 CHECK约束MySQL可以使用check约束，但check约束对数据 验证没有任何作用,添加数据时，没有任何错误或 警告 DEFAULT约束DEFAULT 约束用于向列中插入默认值。 如果没有规定其他的值，那么会将默认值添加到所有的新记录。 索引提高数据库性能，当不使用索引时进行数据操作会对全表进行扫描，造成资源浪费。使用索引时，会形成一个索引的数据结构，比如二叉树 但是使用索引会导致对磁盘占用增加，并且对DML(update、delete、insert)语句的效率影响。因为每次对数据本身进行操作，都会导致索引创建的数据结构进行更改。 类型 主键索引，主键自动的为主索引(类型Primary key) 唯一索引(UNIQUE) 普通索引(INDEX) 全文索引(FULLTEXT)[适用于MylSAM] 一般开发，不使用mysql自带的全文索引，而是使用：全文搜索Solr和ElasticSearch(ES) 普通索引这是最基本的索引，它没有任何限制 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。 唯一索引索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一 主键索引主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引 较为频繁的作为查询条件字段应该创建索引 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件 更新非常频繁的字段不适合创建索引 不会出现在WHERE子句中字段不应该创建索引 事务事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个SQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的是数据将返回到事务开始以前的状态。如果单元中的所有SQL语句均执行成功，则事务顺利执行。 事务的属性 原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另外一个一致性状态 隔离性（Isolation）：事物的隔离性是指一个事务的执行不能被其他事务干扰，即一个事物内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能相互干扰 持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响 事务分类隐式事务没有明显的开启和结束，本身就是一条事务可以自动提交，比如：INSERT、UPDATE、DELETE、 显式事务步骤： 开启事务： set autocommit=0; start transaction;(可以省略) 编写一组逻辑SQL语句（注意：SQL语句支持的是INSERT、UPDATE、DELETE） 设置回滚点：savepoint 回滚点名; 结束事务 ·提交：commit; -回滚：rollback; -回滚到指定地方：rollback to 回滚点名; 并发事务多个事务同时操作同一个数据的相同数据时会引发下列并发问题 脏读：对于两个事务 T1, T2,。T1 读取了已经被 T2 更新但还没有被提交的字段之后, 若 T2 回滚, T1读取的内容就是临时且无效的. 不可重复读：对于两个事务T1, T2。T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了. 幻读：对于两个事务T1, T2。T1 从一个表中读取了一个字段, 然后 T2 在该表中插 入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行. 解决方法： 通过设置隔离级别来解决并发问题 数据库事务的隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。 隔离级别：一个事务与其他事务隔离的程度。数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。 四种事务隔离级别 隔离级别 描述 READ UNCOMMITTED(读未提交数据) 允许事务读取未被其他事务提交的变更。脏读、不可重复读、幻读的问题都会出现。 READ COMMITTED(读已提交数据) 只允许事务读取已经被其他事务提交的变更，可以避免脏读，但不可重复读和幻读问题仍可能出现。 REPEATABLE READ(可重复读) 确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复读，但幻读的问题仍然存在。 SERIALIZABLE(串行化) 确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，所有并发问题都i可以避免，但性能十分低下。 设置隔离级别 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每 个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的 事务隔离级别. 视图MySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了SQL逻辑，不保存查询结果 应用于： 多个地方用到同样的查询结果 该查询结果使用的SQL语句较复杂 好处： 重用SQL语句 简化复杂的SQL操作，不必知道它的查询细节 保护数据，提高安全性 语法： 创建视图 OR REPLACE：表示在创建视图时候会替换已有视图 ALGORITHM：表示视图选择算法 [WITH [CASCADED | LOCAL] CHECK OPTION]：表示视图在更新时保证在视图的权限范围之内 推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 修改视图 删除视图 查看视图 DML操作更新视图因为视图本身并没有数据，因此对视图的DML操作最终都体现在基表上。 插入： 修改： 删除 注意：视图一般用于查询，而不是更新，所以具备以下特点的视图都不允许更新 包含分组函数：GROUP BY、DISTINCT、HAVING、UNION JOIN 常量视图 WHRER后的子查询用到了FROM中的表 用到了不可更新的视图 视图和表的对比 关键字 是否占用物理空间 使用 视图 VIEW 占用较小，只保存SQL逻辑 一般用于查询 表 TABLE 保存实际的数据 增删改查 变量系统变量说明：变量由系统提供，不用自定义.分为全局变量和会话变量 全局变量服务器层面上的，必须拥有super权限才能为系统变量赋值，作用域为整个服务器，也就是针对于所有连接(会话)有效 语法： 查看全局变量 查看满足条件的部分全局变量 查看指定的全局变量的值 为全局变量赋值 方式一： 方式二： 注意：如果没有显式声明GLOBAL还是SESSION，默认SESSION 会话变量服务器为每一个连接的客户端都提供了系统变量，作用域为当前的连接(会话) 查看所有会话变量 查看满足条件的部分会话变量 查看指定的会话变量的值 为某个会话变量赋值 自定义变量用户变量作用域：针对于当前连接(会话)生效 位置：BEGIN END里面，也可以放在外面 使用： 赋值 更新值 方式一： 方式二： 使用 局部变量作用域：仅仅在定义它的BEGIN END中有效 位置：只能放在BEGIN END 中，而且只能放在第一句 使用： 声明 赋值或更新 方式一： 方式二： 使用 存储过程和函数事先经过编译并存储在数据库中的一段SQL语句的集合。 好处： 简化应用开发人员的很多工作 减少数据在数据库和应用服务器之间的传输 提高了数据处理效率 存储过程创建存储过程 注意： 参数模式：IN、OUT、INOUT，其中IN可以省略 存储过程体的每一条SQL语句都需要用分号结尾 调用 查看 删除 函数创建函数 注意：函数体中肯定会有RETURN语句 调用函数 查看函数 删除函数 函数和存储过程的区别 关键字 调用语法 返回值 应用场景 函数 FUNCTION SELECT 函数() 只能有一个 一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个 存储过程 PROCEDURE CALL 存储过程() 可以有0个或多个 一般用于更新 流程控制结构分支结构if函数功能：实现简单双分支 语法：if(条件，值1，值2) 特点：可以用在任何位置 case语句功能：实现多分支 语法1： 语法2: 特点： 可以放在任何位置 如果放在BEGIN END外面，作为表达式结合着其他语句使用 如果放在BEGIN END里面，一般作为独立的语句使用 if elseif语句功能：实现多分支 语法： 位置： 只能放在 BEGIN END中 应用场合 if函数 简单双分支 case结构 等值判断的多分支 if结构 区间判断的多分支 循环结构位置： 只能放在BEGIN END中 特点：都能实现循环结构 while语法： loop语法： repeat语法： 循环控制语句 leave:类似于break，用于跳出所在循环 iterate:类似于continue，用于结束本次循环，继续下一次 对比 这三种循环都可以省略名称，但如果循环中加入了循环控制语句则必须添加名称 loop：一般用于实现简单的死循环 while：先判断后执行 repeat：先执行后判断，无条件至少执行一次 "},{"title":"Java反射机制","date":"2021-01-22T16:00:00.000Z","url":"/2021/01/23/Java%E5%8F%8D%E5%B0%84/","categories":[["Java","/categories/Java/"]],"content":"反射的概述反射的理解Reflection（反射）是被视作动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个 类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可 以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看 到类的结构，所以，我们形象的称之为：反射。 正常方式：引入需要的“包类”名称——&gt;通过new实例化——&gt;取得实例化对象 反射方式：实例化对象——&gt;getClass()方法——&gt;得到完整的包类名称 框架=反射+注解+设计模式。 动态语言&amp;静态语言动态语言：是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以 被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运 行时代码可以根据某些条件改变自身结构。 主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。 静态语言：与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、 C++。 Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动 态性，可以利用反射机制、字节码操作获得类似动态语言的特性。 反射机制能提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解 生成动态代理 相关APIjava.lang.Class:反射的源头java.lang.reflect.Methodjava.lang.reflect.Fieldjava.lang.reflect.Constructor … Class类的理解&amp;获取Class类的实例Class类在Object类中定义了以下的方法，此方法 将被所有子类继承：public final Class getClass() 。 以上的方法返回值的类型是一个Class类， 此类是Java反射的源头，实际上所谓反射 从程序的运行结果来看也很好理解，即： 可以通过对象反射求出类的名称。 Class本身也是一个类 Class 对象只能由系统建立对象 一个加载的类在 JVM 中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个 Class 实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 Class对象 Class类的理解1.类的加载过程：程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。2.换句话说，Class的实例就对应着一个运行时类。3.加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。 Class的常用方法 方法名 功能说明 static Class forName(String name) 返回指定类名name的Class对象 Object newInstance() 调用缺省构造函数，返回该Class对象的一个实例 getName() 返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class [] getInterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 Class getSuperclass() 返回表示此Class所表示的实体的超类的Class Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组 Field[] getDeclaredFields() 返回Field对象的一个数组 Method getMethod(String name,Class … paramTypes) 返回一个Method对象，此对象的形参类型为paramType 获取Class实例的几种方式 PS：前三种方法需要熟记！ 创建类的对象的方式 new+构造器 要创建XXX类的对象，可以考虑：XXX、XXXS、XXXFactory、XXXBuilder类中查看是否有静态方法的存在。可以调用其静态方法，创建XXX对象。 通过反射创建 Class实例可以是哪些结构的说明 Class：外部类、成员（成员内部类、静态内部类），局部内部类，匿名内部类 interface：接口 []：数组 enum：枚举 annotation：注解@interface primitive type：基本数据类型 void 了解ClassLoader类的加载过程 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时 数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问 入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的 过程需要类加载器参与。 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存 都将在方法区中进行分配。 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 初始化： 执行类构造器&lt; clinit &gt;()方法的过程。类构造器&lt; clinit &gt;()方法是由编译期自动收集类中 所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信 息的，不是构造该类对象的构造器）。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类 的初始化。 虚拟机会保证一个类的&lt; clinit &gt;()方法在多线程环境中被正确加锁和同步。 什么时候会发生类的初始化类的主动引用（一定会发生类的初始化） 当虚拟机启动，先初始化main方法所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对类进行反射调用 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类 类的被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化，当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常 量池中了） 类的加载器的作用 类的加载器的分类 Java类编译、运行的执行的流程 使用Classloader加载src目录下的配置文件 反射应用一：创建运行时类的对象创建类的对象：调用Class对象的newInstance()方法要求： 类必须有一个无参数的构造器 类的构造器的访问权限需要足够 问题：没有无参构造器是否就不能创建对象 答：不是，只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。 步骤如下： 通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类 型的构造器 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。 通过Constructor实例化对象。 反射应用二：获取运行时类的完整结构我们可以通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等。。。。 使用反射可以取得： 反射应用三：调用运行时类的指定结构示例代码 关于setAccessible方法的使用1.Method和Field、Constructor对象都有setAccessible()方法。 2.setAccessible启动和禁用访问安全检查的开关。 3.参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 ​ 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被 调用，那么请设置为true。 ​ 使得原本无法访问的私有成员也可以访问 4.参数值为false则指示反射的对象应该实施Java语言访问检查。 反射应用四：动态代理代理模式原理使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 静态代理实现Runnable接口的方法创建多线程。 缺点： 代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。 每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。 动态代理特点动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。 动态代理的实现需要解决的两个主要问题： 如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。 （通过Proxy.newProxyInstance()实现） 当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。(通过InvocationHandler接口的实现类及其方法invoke()) Java动态代理相关APIProxy ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一 个或多个接口动态地生成实现类。 提供用于创建动态代理类和动态代理对象的静态方法 static Class getProxyClass(ClassLoader loader, Class… interfaces) 创建 一个动态代理类所对应的Class对象 static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 直接创建一个动态代理对象 动态代理步骤1.创建一个实现接口InvocationHandler的类，它必须实现invoke方 法，以完成代理的具体操作。 2.创建被代理的类以及接口 3.通过Proxy的静态方法 4.通过 Subject代理调用RealSubject实现类的方法 代码实现 To be continue…"},{"title":"网络编程","date":"2021-01-19T16:00:00.000Z","url":"/2021/01/20/2021120-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","tags":[["TCP","/tags/TCP/"],["UDP","/tags/UDP/"],["Socket","/tags/Socket/"]],"categories":[["undefined",""]],"content":"网络相关概念网络通信 两台设备之间通过网络进行数据传输 java.net包下提供了一系列的类或接口完成网络通信 网络两台或多台设备通过一定物理设备连接起来构成了网络 局域网：覆盖范围最小，仅仅覆盖一个教室或机房 城域网：覆盖范围较大，可以覆盖一个城市 广域网：覆盖范围最大，可以覆盖全球，万维网是广域网的代表 IP地址用于唯一标识网络中的每台计算机/主机 cmd查看IP地址：ipconfig IP地址表示形式：点分十进制 xx.xx.xx.xx（每一个十进制数的范围：0~255） IP地址的组成=网络地址+主机地址 IPV6是互联网工程任务组设计的用于替代IPV4的下一代IP协议 IPV4存在的最大问题在于网络地址资源有限，严重制约了互联网应用和发展。IPV6的使用，不仅解决了网络地址资源数量问题，而且也解决了多种接入设备连入互联网的障碍 IPV4地址分类 类型 范围 A 0.0.0.0到127.255.255.255 B 128.0.0.0到191.255.255.255 C 192.0.0.0到223.255.255.255 D 224.0.0.0到239.255.255.255 E 240.0.0.0到247.255.255.255 127.0.0.1表示本机地址 域名为了方便记忆，解决记IP的困难 通过HTTP协议，将IP地址映射成域名 端口号用于表示计算机上某个特定的网络程序 表示形式：以整数形式，端口范围065535[2个字节表示端口02^16-1] 0~1024已经被占用，比如：ssh-22,ftp-21,smtp-25,http-80 常见的网络程序端口号： tomcat:8080 mysql:3306 oracle:1521 sqlserver:1433 网络通信协议 OSI模型： 对于客户端/服务器（C/S）结构。 即通信双方一方作为服务器等待客户提出请求并予以响应。客户则在需要服务时向服务器提出申请。服务器一般作为守护进程始终运行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服务端口，使后来的客户也能及时得到服务。 对于浏览器/服务器（B/S）结构。 客户则在需要服务时向服务器进行请求。服务器响应后及时返回，不需要实时监听端口 TCP/UDPTCP协议TCP是 Tranfer Control Protocol 的简称，是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。 使用TCP协议前必须先建立TCP连接，形成传输数据通道 传输前，采用“三次握手”方式，是可靠的 TCP协议进行通信的两个应用进程：客户端、服务器 在连接中可进行大数据量的传输 传输完毕，需释放已建立的连接，效率低 三次握手建立起一个TCP连接需要经过“三次握手”： 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求 UDP协议UDP是 User Datagram Protocol 的简称，是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址 将数据、源、目的封装成数据包，不需要建立连接 每个数据报的大小限制在64K内，不适合传输大量数据 因无需连接，故是不可靠的 发送数据结束时无需释放资源(因为不是面向连接的)，速度快 应用TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此TCP传输的效率不如UDP高 UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些 InetAddress类getLocalHost()：获取本机InetAddress对象 getByName()：根据指定主机名/域名获取IP地址对象 getHostName()：获取InetAddress对象的主机名getHostName getHostAddress()：获取InetAddress对象的地址 Socket套接字(Socket)开发网络应用程序被广泛采用。在网络编程中，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket Socket套接字是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口 通信的两端都要有Socket，是两台机器通信的端点。网络通信其实就是Socket之间的通信 Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输 步骤套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认 服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态 客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求 连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求 基于TCP的Socket实现 基于客户端-服务端的网络通信 底层使用的是TCP/IP协议 使用字符流 使用字节流 上传文件 当客户端连接到服务端后，实际上客户端也是通过一个端口和服务器进行通讯的，这个端口是TCP/IP来分配的，是不确定的，是随机的 基于UDP的Socket实现 类DatagramSocket和DatagramPacket[数据包/数据报]实现了基于UDP协议网络程序 UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送达，也不能确定什么时候抵达 DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号 UDP协议中每个数据报都给出了完整的地址信息，因此无需建立发送方和接收方的连接 netast指令netast -an：可以查看当前主机网络情况，包括端口监听情况和网络连接情况 netast an|more：可以分页显示 说明： Listening表示某个端口在监听 如果有一个外部程序(客户端)连接到该端口，就会显示一条连接信息 ctrl+c退出指令 "},{"title":"JavaIO流","date":"2021-01-19T16:00:00.000Z","url":"/2021/01/20/JavaIO/","categories":[["Java","/categories/Java/"]],"content":"File类的使用理解 File类的一个对象，代表一个文件或一个文件目录（文件夹） File类声明在java.io包下 File中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。 后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点” File的实例化常用构造器 路径的分类相对路径：相较于某个路径下，指明的路径。绝对路径：包含盘符在内的文件或文件目录的路径 说明：IDEA中：如果开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下。如果使用main()测试，相对路径即为当前的Project下。Eclipse中：不管使用单元测试方法还是使用main()测试，相对路径都是当前的Project下。 路径分隔符windows和DOS系统默认使用“\\”来表示UNIX和URL使用“/”来表示 File类的常用方法 IO流概述流的分类 操作数据单位：字节流、字符流 数据的流向：输入流、输出流 流的角色：节点流、处理流 图示： 流的体系结构 说明：红框对应的是IO流中的4个抽象基类。蓝框的流需要重点关注。 重点说明的几个流结构 输入、输出的标准化过程输入过程 创建File类的对象，指明读取的数据的来源。（要求此文件一定要存在） 创建相应的输入流，将File类的对象作为参数，传入流的构造器中 具体的读入过程：创建相应的byte[]或char[] 关闭资源流 说明:程序中出现的异常需要用try-catch-finally处理。 输出过程 创建File类的对象，指明写出的数据的位置。(不要求此文件一定存在) 创建相应的输出流，将File类的对象作为参数，传入流的构造器中 具体的写出过程：write(char[]/byte[] buffer,0,len) 关闭资源流 说明：程序中出现的异常需要使用try-catch-finally处理。 节点流（或文件流）FileReader/FileWriter的使用FileReader的使用 FileWriter的使用 文本文件的复制 FileInputStream / FileOutputStream的使用 注意： 相对路径在IDEA和Eclipse中使用的区别？IDEA:如果使用单元测试方法，相对路径基于当前的Module的。如果使用main()测试，相对路径基于当前Project的。 Eclipse:单元测试方法还是main(),相对路径都是基于当前Project的。 缓冲流的使用缓冲流涉及到的类BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 作用作用：提供流的读取、写入的速度提高读写速度的原因：内部提供了一个缓冲区。默认情况下是8kb 典型代码使用BufferedInputStream和BufferedOutputStream:处理非文本文件 使用BufferedReader和BufferedWriter：处理文本文件 转换流的使用转换流涉及到的类属于字符流 InputStreamReader：将一个字节的输入流转换为字符的输入流解码：字节、字节数组 —&gt;字符数组、字符串 OutputStreamWriter：将一个字符的输出流转换为字节的输出流编码：字符数组、字符串 —&gt; 字节、字节数组 说明：编码决定了解码的方式 作用提供字节流与字符流之间的转换 图示 典型实现 编码集常见的编码表ASCII：美国标准信息交换码。用一个字节的7位可以表示。ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。GB2312：中国的中文编码表。最多两个字节编码所有字符GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码Unicode：国际标准码，融合了目前人类使用的所字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。 其他的流的使用标准的输入输出流System.in:标准的输入流，默认从键盘输入System.out:标准的输出流，默认从控制台输出 修改默认的输入和输出行为System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入和输出的流。 打印流PrintStream 和PrintWriter 说明： 提供了一系列重载的print()和println()方法，用于多种数据类型的的输出 System.out返回的是PrintStream的实例 数据流DataInputStream 和 DataOutputStream作用：用于读取或写出基本数据类型的变量或字符串 示例： 对象流的使用对象流ObjectInputStream 和 ObjectOutputStream 作用ObjectOutputStream:内存中的对象—&gt;存储中的文件、通过网络传输出去：序列化过程ObjectInputStream:存储中的文件、通过网络接收过来 —&gt;内存中的对象：反序列化过程 对象的序列化机制对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象 序列化代码实现 反序列化代码实现 实现序列化的对象所属的类需要满足 需要实现接口：Serializable 当前类提供一个全局常量：serialVersionUID 除了当前Person类需要实现Serializable接口之外，还必须保证其内部所属性也必须是可序列化的。（默认情况下，基本数据类型可序列化） 补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 RandomAccessFile类的使用随机存取文件流RandomAccessFile（） 说明 RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口 RandomAccessFile既可以作为一个输入流，又可以作为一个输出流 如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。如果写出到的文件存在，则会对原文件内容进行覆盖。（默认情况下，从头覆盖） 可以通过相关的操作，实现RandomAccessFile“插入”数据的效果。seek(int pos) 代码示例 Path\\Paths\\Files的使用NIO的使用说明 Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的JavaIO API。 NIO与原来的IO同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。 NIO将以更加高效的方式进行文件的读写操作。 随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。 Path的使用Path的说明Path替换原有的File类。 如何实例化 常用方法 Files工具类作用操作文件或文件目录的工具类 常用方法 The End!"},{"title":"Java泛型","date":"2021-01-03T16:00:00.000Z","url":"/2021/01/04/%E6%B3%9B%E5%9E%8B/","categories":[["Java","/categories/Java/"]],"content":"泛型的概念所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时确定（即传入实际的类型参数，也称为类型实参）。 背景 集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection&lt; E &gt;，List&lt; E &gt;，ArrayList&lt; E &gt; 这个&lt; E &gt;就是类型参数，即泛型。 集合中不使用泛型 集合中使用泛型 在集合中使用泛型的情况：以HashMap为例： 总结 集合接口或集合类在jdk5.0时都修改为带泛型的结构 在实例化集合类时，可以指明具体的泛型类型 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。比如：add(E e)—&gt;实例化以后:add(Integer e) 注意：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换。 如果实例化时，没指明泛型的类型。默认泛型为java.long.Object类型。 在给泛型指定具体类型后，可以传入该类型或者其子类类型 自定义泛型泛型的声明inteface List&lt; T &gt;和class GenTest&lt; K,V &gt; 其中的T、K、V不代表值，而是类型。使用任意字母都可。常用T表示，是Type缩写。 泛型的实例化一定要在类型后面指定类型参数的值（类型）。例如： List strList=new ArrayList(); Iterator iterator=customers.iterator(); T只能是类，不能用基本数据类型填充。但可以使用包装类填充。 核心思想：把一个集合中的内容限制为一个特定的 数据类型。 体会：使用泛型的主要优点是能够在编译时而不是运行时找到错误。 自定义泛型类、泛型接口 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt; E1,E2,E3 &gt; 泛型类的构造器如下： public GenericClass(){}。 而下面是错误的： public GenericClass&lt; E &gt;(){} 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。 泛型不同的引用不能相互赋值. PS:尽管在编译时ArrayList和ArrayList是两种类型，但是，在运行时只有 一个ArrayList被加载到JVM中。 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价 于Object。经验：泛型要使用一路都用。要不用，一路都不要用。 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。 jdk1.7，泛型的简化操作：ArrayList flist = new ArrayList&lt;&gt;(); 泛型的指定中不能使用基本数据类型，可以使用包装类替换。 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态 属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法 中不能使用类的泛型。 异常类不能是泛型的 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity]; 参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型： 子类不保留父类的泛型：按需实现 ​ 没有类型 擦除 ​ 具体类型 子类保留父类的泛型：泛型子类 ​ 全部保留 ​ 部分保留 结论：子类除了指定或保留父类的泛型，还可以增加自己的泛型 自定义泛型方法方法也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。 泛型方法的格式： [访问权限]&lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常 泛型方法声明泛型时也可以指定上限 应用场景举例： 举例： 父类：JavaGeneric 子类：subJavaGeneric、subJavaGeneric 测试类：GenericTest 泛型在继承上的体现类A是类B的父类，但是G&lt; A &gt;和G&lt; B &gt;二者不具备子父类的关系，二者为并列关系。 补充：类A是类B的父类，A&lt; G &gt;是B&lt; G &gt;的父类 通配符通配符的使用通配符：? 类A是类B的父类，G&lt; A &gt;和G&lt; B &gt;是没关系的，二者共同的父类是：G&lt;?&gt; 通配符的集合的数据的写入和读取 有限制条件的通配符的使用 通配符指定上限 上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;=。 通配符指定下限 下限super：使用时指定的类型不能小于操作的类，即&gt;= 举例： 只允许泛型为A及A子类的引用调用 只允许泛型为A及A父类的引用调用 只允许泛型为实现Comparable接口的实现类的引用调用 读取与写入：读取没问题，因为&lt; ?&gt;也可以进行读取 参考链接："},{"title":"记录一次new String()报错","date":"2020-11-29T16:00:00.000Z","url":"/2020/11/30/error01/","categories":[["Error","/categories/Error/"]],"content":" 解决方法： 删除导入的import com.sun.org.apache.xpath.internal.operations.String;即可。"},{"title":"即使是期末，学习也不要停下来啊！","date":"2020-11-29T16:00:00.000Z","url":"/2020/11/30/%E5%B0%91%E5%B9%B4%E3%81%AE%E6%97%A5%E5%B8%B801/","categories":[["少年の日常","/categories/%E5%B0%91%E5%B9%B4%E3%81%AE%E6%97%A5%E5%B8%B8/"]],"content":"临近期末，开始准备考试！可能会拖慢学习进度，但还是保证尽量一周至少更新一次学习类博客。 PS：心中有党，成绩理想！"},{"title":"Java集合","date":"2020-11-29T16:00:00.000Z","url":"/2020/11/30/20201130-%E9%9B%86%E5%90%88/","tags":[["集合","/tags/%E9%9B%86%E5%90%88/"],["Map","/tags/Map/"],["Set","/tags/Set/"]],"categories":[["Java","/categories/Java/"]],"content":"概述数组 长度开始时必须指定，而且一旦指定，不能更改 保存的必须为同一类型元素 使用数组进行增加/删除元素比较麻烦 集合 可以动态保存任意多个对象，使用比较方便 提供了一系列方便的操作对象的方法 使用集合添加、删除新元素更加简洁 Collection接口单列集合框架结构Collection接口：单列集合，用来存储一个一个的对象 List接口：存储有序的、可重复的数据。–&gt;“动态”数组 Set接口：存储无序的、不可重复的数据 图示： Collection接口常用方法 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals(). Iterator说明 Iterator对象称为迭代器（设计模式的一种），重要用于遍历Colletion集合中的元素。 GOF（Gang of Four）给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。 所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器 Iterator仅用于遍历集合,Iterator本身并不存放对象 如何获取实例 遍历的代码实现 注意：在调用iterator.next()方法之前必须要调用iterator。hasNext()进行检测。若不调用，且下一条记录无效，直接调用.next()会抛出NoSuchElementException异常 IDEA快速生成代码：itit 图示说明 remove（）的使用 增强for循环增强for循环可以代替iterator迭代器，特点：增强for解释简化版的iterator，本质一样。只能用于遍历集合或数组.内部仍然调用了迭代器 格式：for(元素类型 元素名:集合名或数组名){访问元素} 遍历集合举例 遍历数组举例 List接口List接口是Collection接口的子接口 List集合类中元素有序(即添加顺序和取出顺序一致)，且可重复 List集合中的每一个元素都有其对应的顺序索引，即支持索引 List容器中的元素都对应一个整数型的序号记载其在容器中位置，可以根据序号存取容器中的元素 JDK API中List接口的实现类： AbstractList AbstractSequentialList ArrayList(常用) AttributeList CopyOrWriteArrayList LinkedList(常用) RoleList RoleUnresolvedList Stack Vector(常用) List接口常用方法 遍历 ArrayList ArrayList可以加入null，并且多个 ArrayList是由数组来实现数据存储的 ArrayList基本等同于Vector，除了ArrayList是线程不安全的(执行效率高)。在多线程情况下，不建议使用ArrayList 底层操作机制源码分析 ArrayList中维护了一个Object类型的数组elementData 当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容elementData为10，如需再次扩容,则扩容elementData为1.5倍 如果使用的是指定大小的构造器，则初始elementData容量为指定的大小,如果需要扩容，则直接扩容elementData为1.5倍v 使用无参构造器创建ArrayList1.创建了一个空的elementData数组 2.执行list.add。先确定是否需要扩容，然后再执行赋值 3.调用calculateCapacity() 4.该方法确认minCapacity第一次扩容为10 5.modCount++记录集合被修改的次数。如果elementData的大小不够，就调用grow()去扩容 6.使用扩容机制来确定要扩容到多大。第一次newCapacity=10,第二次及以后，按照1.5倍扩容。扩容使用的是Arrays.CopyOf() Vector Vector底层也是一个对象数组elementData Vector是线程同步的，即线程安全，Vector类的操作方法带有Synchronized 在开发中，需要考虑线程同步安全时，考虑使用Vector 如果使用的是无参构造器，则初始elementData容量为10，如需再次扩容,则扩容elementData为2倍 如果使用的是指定大小构造器，则每次直接按2倍扩容 LinkedList LinkedList底层实现了双向链表和双端队列特点 可以添加任意元素(元素可以重复)，包括null 线程不安全，没有实现同步 底层操作机制 LinkedList底层维护了一个双向链表 LinkedList中维护了两个属性first和last分别指向首节点和尾节点 每个节点(Node对象)，里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个。最终实现双向链表 linkedList元素的添加和删除，不是通过数组完成的，相对来说效率较高 ArrayList和LinkedList比较 底层结构 增删的效率 改查的效率 ArrayList 可变数组 较低，数组扩容 较高 LinkedList 双向链表 较高，通过链表追加 较低 如果改查操作多，选择ArrayList 如果增删操作多，选择LinkedList Set接口 无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值来决定的 不可重复性：保证添加的元素照equals()判断时，不能返回true。即：相同的元素只能添加一个 Set接口中没有额外定义新方法，使用的都是Collection中声明过的方法 HashSet HashSet实现了Set接口 HashSet实际上是HashMap 不能有重复元素/对象 HashSet不保证元素是有序的，取决于Hash后，再确定索引的结果（即，不能保证存放元素的顺序和取出顺序一致） HashSet底层机制HashSet底层是HashMap，HashMap底层是(数组+链表+红黑树) HashSet添加元素底层实现过程： 先获取元素的哈希值(hashCode方法) 对hash值进行运算，得出一个索引值。即要存放在hash表中的位置号 如果该位置上没有其他元素，则直接存放。 如果该位置上有其他元素，则需要进行equals判断：如果相等，则不再添加。如果不相等，则以链表的方式添加 在Java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD(默认是8)，斌且table的大小&gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树) 源码分析： 因此使用HashSet时需要重写equals()和hashCode()方法 HashSet的扩容和转成红黑树机制 第一次添加时，table数组扩充为16，临界值(threshold)是16*加载因子(loadFactor)是0.75=12 如果table数组使用到了临界值12，就会扩容到16 * 2=32，新的临界值就是32 * 0.75=24，以此类推 在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table大小&gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树)，否则仍然采用数组扩容机制 LinkedHashSet LinkedHashSet是HashSet的子类 LinkedHashSet底层是LinkedHashMap，底层维护了一个 数组+双向链表 LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的 LinkedHashSet不允许添加重复元素 注意：同样需要重写equals()和hashCode()方法 TreeSet使用说明： 1.向TreeSet中添加的数据，要求是相同类的对象。2.两种排序方式：自然排序（实现Comparable接口 和 定制排序（Comparator） 常用的排序方式 Map接口 Map与conllection并列存在.用于保存具有映射关系的数据：Key-value Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中 Map中的key不允许重复，原因和HashSet一样 Map中的value可以重复 Map的key可以为null，value也可以为null，注意key为null，只能有一个，value为null，可以多个 常用String类作为Map的key key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value 一对k-v是放在一个HashMap$Node中的，又因为Node实现了Entry接口，也可以说一对k-v就是一个Entry 常用方法 遍历 常用实现类结构 HashMap HashMap是Map接口使用频率最高的实现类 HashMap是以key-value对的方式来存储数据(HashMap$Node类型) key不能重复，但是值可以重复，允许使用null键和null值 如果添加相同的key，则会覆盖原来的key-val，等同于修改（key不会替换，val会替换） 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的 HashMap没有实现同步，因此线程是不安全的，方法没有做同步互斥的操作，没有synchronized 底层机制扩容机制（和HashSet相同） HashMap底层维护了Node类型的数组table,默认为null 当创建对象时，将加载因子(loadfactor)初始化为0.75 当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换val；如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容 第一次添加，则需要扩容table容量为16，临界值(threshold)为12 以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍，以此类推 在Java8中，如果一条链表的元素个数超过TREEIFY—THRESHOLD(默认是8)，并且table的大小&gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树) 源码 LinkedHashMap的底层实现原理LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap.区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node. HashTable 存放的元素时键值对：即，k-v hashTable的键和值都不能为null，否则会抛出NullPointerException hashTable使用方法基本上和HashMap相同 hashTable是线程安全的，hashMap是线程不安全的 Hashtable 和 HashMap 对比 版本 线程安全(同步) 效率 允许null键null值 HashMap 1.2 不安全 高 可以 HashTable 1.0 安全 较低 不可以 properties Properties类继承自HashTable类并且实现了Map接口，也是一种键值对形式来保存数据 它的使用特点和HashTable类似 Properties还可以用于从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改 xxx.properties文件通常作为配置文件 如何选择集合实现类主要取决于业务操作特点，然后根据集合实现类特性进行选择 先判断存储的类型(一组对象[单列]或一组键值对[双列]) 一组对象[单列]：Collection接口 允许重复：List 增删多：LinkedList[底层维护了一个双向链表] 改查多：ArrayList[底层维护Object类型的可变数组] 不允许重复：Set 无序：HashSet[底层是HashMap，维护了一个哈希表，即[数组+链表+红黑树]] 排序：TreeSet 插入和取出顺序一致：LinkedHashSet，维护数组+双向链表 一组键值对[双列]：Map 键无序：HashMap[底层是：哈希表] 键排序：TreeMap 键插入和取出顺序一致：LinkedHashMap 读取文件：Properties TreeMap的使用向TreeMap中添加key-value，要求key必须是由同一个类创建的对象，因为要按照key进行排序：自然排序、定制排序 Collections工具类Collections工具类作用操作Collection和map的工具类 常用的方法reverse(List)：反转 List 中元素的顺序shuffle(List)：对 List 集合元素进行随机排序sort(List)：根据元素的自然顺序对指定 List 集合元素升序排序sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素Object min(Collection)Object min(Collection，Comparator)int frequency(Collection，Object)：返回指定集合中指定元素的出现次数void copy(List dest,List src)：将src中的内容复制到dest中boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所旧值 说明：ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程的。使用synchronizedList(List list） 和 synchronizedMap(Map map）"},{"title":"枚举类和注解","date":"2020-11-20T16:00:00.000Z","url":"/2020/11/21/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3/","categories":[["Java","/categories/Java/"]],"content":"枚举类和注解枚举类的说明 枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类 当需要定义一组常量时，强烈建议使用枚举类 如果枚举类中只有一个对象，则可以作为单例模式的实现方式。 自定义枚举类步骤: jdk 5.0 新增使用enum定义枚举类步骤： 使用enum定义枚举类之后，枚举类常用方法：（继承于java.lang.Enum类） 使用enum定义枚举类之后，如何让枚举类对象分别实现接口 注解（Annotation）注解的理解jdk5.0新增功能 Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 框架 = 注解 + 反射机制 + 设计模式 注解的使用示例示例一：生成文档相关的注解 示例二：在编译时进行格式检查(JDK内置的个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的择 @SuppressWarnings: 抑制编译器警告 示例：跟踪代码依赖性，实现替代配置文件功能 如何自定义注解：参照@SuppressWarnings定义 注解声明为：@interface 内部定义成员，通常使用value表示 可以指定成员的默认值，使用default定义 如果自定义注解没成员，表明是一个标识作用 说明：如果注解有成员，在使用注解时，需要指明成员的值。自定义注解必须配上注解的信息处理流程(使用反射)才意义。自定义注解通过都会指明两个元注解：Retention、Target 代码举例： 元注解 ：对现有的注解进行解释说明的注解jdk 提供的4种元注解：Retention：指定所修饰的 Annotation 的生命周期：SOURCE\\CLASS（默认行为\\RUNTIME 只声明为RUNTIME生命周期的注解，才能通过反射获取。Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素——出现的频率较低——Documented:表示所修饰的注解在被javadoc解析时，保留下来。Inherited:被它修饰的 Annotation 将具继承性。 —&gt;类比：元数据的概念：String name = “Tom”; 如何获取注解信息:通过反射来进行获取、调用前提：要求此注解的元注解Retention中声明的生命周期状态为：RUNTIME. JDK8中注解的新特性：可重复注解、类型注解可重复注解： 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 类型注解： ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明） ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。 "},{"title":"Java常用类2","date":"2020-11-17T16:00:00.000Z","url":"/2020/11/18/Class2/","categories":[["Java","/categories/Java/"]],"content":"JDK8之前日期时间API获取系统当前时间：System类中的currentTimeMillis() java.util.Date类与java.sql.Date类java.util.Date 是 java.sql.Date 的父类java.util.Date是常用的表示时间的类，我们通常格式化或者得到当前时间都是用他 java.sql.Date在读写数据库的时候用他，因为PreparedStament的setDate()的第2参数和ResultSet的getDate()方法的第2个参数都是java.sql.Date 继承关系：java.lang.Object –》 java.util.Date –》 java.sql.Date 1.两个构造器的使用 构造器一：Date()：创建一个对应当前时间的Date对象 构造器二：创建指定毫秒数的Date对象 2.两个方法的使用 toString():显示当前的年、月、日、时、分、秒 getTime():获取当前Date对象对应的毫秒数。（时间戳） 3. java.sql.Date对应着数据库中的日期类型的变量 如何实例化 如何将java.util.Date对象转换为java.sql.Date对象 java.text.SimpleDataFormat类Java中怎么才能把日期转换成想要的格式呢，或把字符串转换成一定格式的日期，如把数据库中的日期或时间转换成自己想要的格式，JAVA中提供了SimpleDateFormat类可以实现。 SimpleDateFormat的实例化: new + 构造器 SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。 SimpleDateFormat 使得可以选择任何用户定义的日期-时间格式的模式。但是，仍然建议通过 DateFormat 中的 getTimeInstance、getDateInstance 或 getDateTimeInstance 来创建日期-时间格式器。每一个这样的类方法都能够返回一个以默认格式模式初始化的日期/时间格式器。 结果为： 公元2010年07月27日 09时19分29秒2010/07/27 09:192010-07-27 09:19:292010年07月27日 09时19分29秒 星期二2010/07/27 星期二一年中的第 208 天 ，第31个星期 ，一个月中第5个星期 ，9时 CST时区 SimpleDateFormat日期-时间格式模式参数字母 日期或时间元素 表示 示例G Era 标志符 Text ADy 年 Year 1996; 96M 年中的月份 Month July; Jul; 07w 年中的周数 Number 27W 月份中的周数 Number 2D 年中的天数 Number 189d 月份中的天数 Number 10F 月份中的星期 Number 2E 星期中的天数 Text Tuesday; Tue （我在部署的时候在本机oracle是返回星期是星期二，而在Oracle的服务器上是返回Tue.)a Am/pm 标记 Text PMH 一天中的小时数（0-23） Number 0k 一天中的小时数（1-24） Number 24K am/pm 中的小时数（0-11） Number 0h am/pm 中的小时数（1-12） Number 12m 小时中的分钟数 Number 30s 分钟中的秒数 Number 55S 毫秒数 Number 978z 时区 General time zone Pacific Standard Time; PST; GMT-08:00Z 时区 RFC 822 time zone -0800 Calendar类：日历类、抽象类实例化方式一：创建其子类GregorianCalendar的对象方式二：调用其静态方法getInstance() //Calendar calendar = Calendar.getInstance(); 常用方法： JDK8中新日期时间API日期时间API迭代第一代：jdk 1.0 Date类第二代：jdk 1.1 Calendar类，一定程度上替换Date类第三代：jdk 1.8 提出了新的一套API 前两代存在的问题举例可变性：像日期和时间这样的类应该是不可变的。偏移性：Date中的年份是从1900开始的，而月份都从0开始。格式化：格式化只对Date用，Calendar则不行。此外，它们也不是线程安全的；不能处理闰秒等。 java 8 中新的日期时间API涉及到的包 本地日期、本地时间、本地日期时间的使用：LocalDate / LocalTime / LocalDateTime说明： 分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。 LocalDateTime相较于LocalDate、LocalTime，使用频率要高 类似于Calendar 常用方法： 时间点：Instant说明： 时间线上的一个瞬时点。 概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC开始的秒数。） 类似于 java.util.Date类 常用方法： 日期时间格式化类：DateTimeFormatter说明： 格式化或解析日期、时间 类似于SimpleDateFormat 常用方法： 实例化方式： 预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) 特别的：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)重点：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) 格式化 格式化String str4 = formatter3.format(LocalDateTime.now());System.out.println(str4);//2019-02-18 03:52:09 解析 带时区的日期时间：ZonedDateTime / ZoneId举例： 时间间隔：Duration–用于计算两个“时间”间隔，以秒和纳秒为基准举例： 日期间隔：Period –用于计算两个“日期”间隔，以年、月、日衡量 举例： 日期时间校正器：TemporalAdjuster举例： Java比较器Java比较器的使用背景Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。如何实现？使用两个接口中的任何一个：Comparable 或 Comparator 自然排序：使用Comparable接口说明： 像String、包装类等实现了comparable接口，重写了compareTo(obj)方法，给出了两个比较对象大小的方式。 像String、包装类重写compareTo()方法以后，进行了从小到大的排列 重写compareTo(obj)的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序 自定义类代码举例： 定制排序：使用Comparator接口说明： 背景：当元素的类型没实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序 重写compare(Object o1,Object o2)方法，比较o1和o2的大小： 如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 代码举例： 使用：Arrays.sort(goods,com);Collections.sort(coll,com);new TreeSet(com); 两种排序方式对比Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。Comparator接口属于临时性的比较。 其他类System类 System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。 方法：native long currentTimeMillis()void exit(int status)void gc()String getProperty(String key) Math类java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。 BigInteger、BigDecimal类说明： java.math包的BigInteger可以表示不可变的任意精度的整数。 要求数字精度比较高，用到java.math.BigDecimal类代码举例： "},{"title":"Java常用类1","date":"2020-11-15T16:00:00.000Z","url":"/2020/11/16/Class1/","categories":[["Java","/categories/Java/"]],"content":"String类java.lang.String类的使用概述String：字符串，使用一对“”引起来表示。 String声明为final，不可被继承 String实现了Serializable接口：表示字符串是支持序列化的 实现了Comparable接口：表示String可以比较大小 String内部定义了final char[] value用于储存字符串数据 通过字面量的方式（区别于new给一个字符串赋值，此时的字符串声明在字符串常量池中） 字符串常量池中不会储存相同内容（使用String类的equals()比较，返回true）的字符串。 String的不可变性说明 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有字符串进行连续操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 例如： 图示 String实例化的不同方式方式说明*方式一：通过字面量定义的方式 方式二：通过new+构造器的方式 例如： String s = new String(“abc”);方式创建对象，在内存中创建了几个对象？两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc” 图示： 字符串拼接方式赋值的对比对比说明 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。 只要其中一个是变量，结果就在堆中。 如果拼接的结果调用intern()方法，返回值就在常量池中 举例 常用方法int length()：返回字符串的长度：return value.length char charAt(int index)：返回某索引处的字符return value[index] boolean isEmpty()：判断是否是空的字符串：return value.length ==0 String tolowerCase()：使用默认语言环境，将String中的所有字符转换为小写 String toUpperCase()：使用默认语言环境·，将String中的所有字符转换为大写 String trim()：返回字符串的副本，忽略前导空白和尾部空白 boolean equals(Object obj)：比较字符串的内容是否相同 boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写 String concat(String str)：将指定字符串链接到此字符串的结尾，等价于用“+” int compareTo(String anotherString)：比较两个字符串的大小 String subString(int beginIndex)：返回一个新的字符串，它是此字符串从beginIndex开始截取到最后的·一个子字符串。 String subString(int beginIndex,int endIndex)：返回一个新字符串，它是此字符串beginIndex开始截取到endIndex(不包含)的一个子字符串 boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束 boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始 boolean startsWith(String prefix，int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始 boolean contains(CharSequence s)：当且仅当此字符串包含指定的char值返回序列时，返回true int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引 int indexOf(String str，int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始 int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引 int lastIndexOf(String str，int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索 注：indexOf和lastIndexOf如果未找到都是返回-1 替换： String replace(char oldChar，char newChar)：返回一个新的字符串，它是通过用newChar替换此字符串中出现的所有oldChar得到的。 String repalce(CharSequence target,CharSequence replacement)：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串 String replaceAll(String regex,String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的子字符串 String replaceFirst(String regex,String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串 匹配： boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式 切片： String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串 String[] split(String regex,int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后的元素中 String与其他结构的转换与基本数据类型、包装类之间的转换String——&gt;基本数据类型、包装类：调用包装类的静态方法：parseXxx(str) 基本数据类型、包装类——&gt;String：调用String重载的valueOf(xxx) 与字符数组之间的转换编码：Stirng——&gt;byte[]：调用String的getBytes() 解码：byte[]——&gt;String：diaoyongString的构造器 编码：字符串——&gt;字节（看得懂——&gt;看不懂的二进制数据） 解码：编码的逆过程，字节——&gt;字符串（看不懂的二进制数据——&gt;看得懂） 说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。 与StringBuffer、StringBuilder之间的转换String——&gt;StringBuffer、StringBuilder：调用StringBuffer、StringBuilder构造器 StringBuffer、StringBuilder –&gt;String： 1.调用String构造器 2.StringBuffer、StringBuilder的toString() JVM中字符串常量池存放位置说明jdk1.6：字符串常量池储存在方法区(永久区) jdk1.7：字符串常量池储存在堆空间 jdk1.8：字符串常量池储存在方法区(元空间) 算法题目考查1.模拟一个trim方法，去除字符串两端的空格。 2.将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg” 3.获取一个字符串在另一个字符串中出现的次数。 比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数 4.获取两个字符串中最大相同子串。比如： str1 = “abcwerthelloyuiodef“;str2 = “cvhellobnm” 提示：将短的那个串进行长度依次递减的子串与较长的串比较。 5.对字符串中字符进行自然顺序排序。 提示： 1字符串变成字符数组。 2对数组排序，择，冒泡，Arrays.sort(); 3将排序后的数组变成字符串。 String、StringBuffer、StringBuilder三者对比 String:不可变的字符序列;底层使用char[]储存。 StringBuffer:可变的字符序列；线程安全，效率低；底层使用char[]存储。 StringBuilder:可变的字符序列；jdk5.0新增，线程不安全，效率高；底层使用char[]存储。 StringBuffer和StringBuilder的内存解析例如StringBuffer： 开发中建议使用：StringBuffer(int capacity) 或 StringBuilder(int capacity) 对比String、StringBuffer、StringBuilder三者的执行效率从高到低排列：StringBuilder &gt; StringBuffer &gt; String StringBuffer、StringBuilder中的常用方法增：append(xxx) 删：delete(int start,int end) 改：setCharAt(int n,char ch) /replace(int start,int end,String str) 查：charAt(int n) 插入：insert(int offset,xxx) 长度：length() 遍历：for()+charAt()/toString()"},{"title":"多线程","date":"2020-11-14T16:00:00.000Z","url":"/2020/11/15/Thread/","tags":[["synchronized","/tags/synchronized/"],["lock","/tags/lock/"],["Callable","/tags/Callable/"],["线程池","/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"]],"categories":[["Java","/categories/Java/"]],"content":"程序、进程、线程程序（program)：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。 进程（process)：程序的一次执行过程，或是正在运行的一个程序。 线程（thread)：进程可进一步细化为一个或多个线程，是一个程序内部的一条执行路径。 说明： 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc），线程切换的开销小。 每个线程，拥有自己独立的：栈、程序计数器。 多个线程，共享同一个进程中的结构：方法区、堆。 一个Java应用程序Java.exe，其实至少三个线程:main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 并行和并发并行：同一时刻，多个任务同时执行。多核CPU可以实现 并发：同一个时刻，多个任务交替执行，造成一种“貌似同时”的错觉。单核CPU实现的多任务就是并发 创建线程方式方式一：继承Thread类的方式 创建一个继承于Thread类的子类 重写Thread类的run() ——&gt;将此线程执行的操作声明在run()中 创建Thread类的子类的对象 通过此对象调用的start():1.启动当前线程2.调用当前线程的run() 说明： 1：我们启动一个线程，必须调用start()，不能调用run()的方式启动线程。 2：如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start()。 方式二：实现Runnable接口的方式 创建一个实现Runnable接口的类 实现类去实现Runnable中的抽象方法：run() 创建实现类的对象 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 通过Thread类的对象调用start() 两种方式对比： 开发中：优先选择：实现Runnable接口的方式 原因：1.实现的方式没有类的单继承性的局限性。 2.实现的方式更适合来处理多个线程共享数据的情况。 相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中。 ​ 目前两种方式，想要启动线程，都是调用的Thread类中的start()。 Thread类中的常用方法 方法 说明 start() 启动当前线程：调用当前线程的run() run() 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 currentThread() 静态方法，返回执行当前代码的线程 getName() 获取当前线程的名字 setName() 设置当前线程的名字 yield() 释放当前CPU的执行权 join() 在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完后，线程a才结束阻塞状态 stop() （已过时）当执行此方法时，强行结束当前线程 sleep(long millitime) 让当前线程“睡眠”指定的毫秒（millitime）。在指定的millitime毫秒时间内，当前线程是阻塞状态 isAlive() 判断当前线程是否存活 线程的优先级 MAX_PRIORITY: 10 MIN_PRIORITY: 1 NORM_PRIORITY: 5——&gt;默认优先级 如何获取和设置当前线程的优先级： getPriority():获取线程的优先级 setPriority(int p):设置线程的优先级 说明：高优先级的线程要抢占低优先级的线程CPU的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。 线程通信：wait()/notify()/notifyAll()：此三个方法定义在Object()类中的。 补充：线程的分类 一种是守护线程，一种是用户线程。 线程的生命周期 JDK 中用 Thread.State 枚举表示了线程的几种状态 NEW：尚未启动的线程处于此状态 RUNNABLE：在Java虚拟机中的线程处于此状态 BLOCKED：被阻塞等待监视器锁定的线程处于此状态 WAITING：正在等待另一个线程执行特定动作的线程处于此状态 TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态 TERMINATED：已退出的线程处于此状态 线程的同步机制例：创建个窗口卖票，总票数为100张，使用实现Runnable接口的方式问题：卖票过程中，出现了重票、错票——&gt;出现了线程的安全问题问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。解决问题：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。 Java解决方案：同步机制同步代码块 说明： 操作共享数据的代码，即为需要被同步的代码。——&gt;不能包含代码多了，也不能包含代码少了。 共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。 要求：多个线程必须要共用同一把锁。 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 同步方法如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 总结： 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 非静态的同步方法，同步监视器是：this 静态的同步方法，同步监视器是：当前类本身 Lock锁 （JDK5.0新增)Lock类实际上是一个接口，我们在实例化的时候实际上是实例化实现了该接口的类Lock lock = new ReentrantLock();。用synchronized的时候，synchronized可以修饰方法，或者对一段代码块进行同步处理。 自定义线程类： 测试类： synchronized 与 Lock的异同？ 相同：二者都可以解决线程安全问题 不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器 Lock需要手动的启动同步（lock()。同时，结束同步也需要手动的实现（unlock()） 使用的优先顺序： Lock —&gt; 同步代码块（已经进入了方法体，分配了相应资源 ) —&gt;同步方法（在方法体之外) 利弊：同步的方式，解决了线程的安全问题。—好处操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 线程安全的单例模式使用同步机制将单例模式中的懒汉式改写为线程安全的。 死锁问题不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 说明： 死锁出现后，不会出现异常，不会出现提示，只是所有线程都处于阻塞状态，无法继续 使用同步时，要避免出现死锁 例如： 线程通信线程通信涉及到的三个方法：wait(): 一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。notify(): 一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。notifyAll(): 一旦执行此方法，就会唤醒所有被wait的线程。 说明：1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。面试题：sleep() 和 wait()的异同？相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。不同点： 两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait() 调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 释放锁的操作 不会释放锁的操作 JDK5.0新增线程创建的方式新增方式一：实现Callable接口。 （JDK 5.0新增） 说明：如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？ call()可以返回值的。 call()可以抛出异常，被外面的操作捕获，获取异常的信息 Callable是支持泛型的 新增方式二：使用线程池 说明：好处：1.提高响应速度（减少了创建新线程的时间）2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）3.便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没任务时最多保持多长时间后会终止"},{"title":"Java异常处理机制","date":"2020-11-11T16:00:00.000Z","url":"/2020/11/12/Exception/","categories":[["Java","/categories/Java/"]],"content":"Java异常处理机制Java异常机制用到的几个关键字try用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。 catch用来捕获异常，catch用来捕获try语句块中发生的异常。 throw用来抛出异常 throws用在方法签名中，用于声明该方法可能抛出的异常。主方法上也可能使用throws抛出。如果在主方法上使用了throws抛出，就表示在主方法里面可以不用强制性进行异常处理，如果出现了异常，就交给JVNM进行默认处理，则此时会导致程序中断运行。 finallyfinally语句块总是会被执行。像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等中止方法的语句，则就不会跳回执行，直接停止。 三种类型的异常 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。 异常方法： 方法 public String getMessage() 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 public Throwable getCause() 返回一个Throwable 对象代表异常原因。 public String toString() 使用getMessage()的结果返回类的串级名字。 public void printStack Trace() 打印toString()结果和栈层次到System.err，即错误输出流。 public Stack TraceElement [] getStack Trace() 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 public Throwable filllnStack Trace() 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 异常的使用及执行流程异常的处理方案1 try…catch try…catch…finally try…finally 说明： 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配。 一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没写finally的情况。继续执行其后的代码。 catch中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓。catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 在try结构中声明的变量，再出了try结构以后，就不能再被调用。 try-catch-finally结构可以嵌套。 异常的处理方案2 “throws + 异常类型“写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。 一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！ 对比两种处理方式： try-catch-finally:真正的将异常给处理掉了。 throws的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。 开发中应该如何选择两种处理方式？ 如果父类中被重写的方法没throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理。 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。 补充： 方法重写的规则之一： 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 手动抛出异常对象 说明：在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。 throw 和 throws区别： throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。 throws 属于异常处理的一种方式，声明在方法的声明处。 例如： 自定义异常类 如何自定义异常类？ 继承于现的异常结构：RuntimeException 、Exception 提供全局常量：serialVersionUID 提供重载的构造器 例如： "},{"title":"设计模式：单例模式","date":"2020-11-11T16:00:00.000Z","url":"/2020/11/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","categories":[["Java","/categories/Java/"]],"content":"设计模式：单例模式所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。 而如何保证类在内存中只有一个对象？平时在实例化类的对象时，基本都是通过new 的方式来实例化一个对象，其实说白了，就是调用了需要实例化类的默认的构造方法，所以为了保证类只有一个对象，我们需要将类的对象设置为private。 1）控制类的创建，不让其他类创建本类的对象，即需要设置private属性 2）在本类中定义一个本类的对象 测试结果为true，可见s1,s2用的是同一个地址值。 但是，在执行main方法的时候，若突然有个进程插了进来，将Singleton中的s变成了null（多线程中，很常见），这时就相当于引用了两个地址，即不符合了单例的定义 所以，除了使用private设置构造函数还不够，还需要提供公共的访问方式 先将Sinleton类中的实例化私有（private），使得外界不能调用，然后创建要给get方法，返回一个实例s，这样，就保证了在外类中不能更改s的值，即保证了单例的实现 其实上述的方式 就是单例模式中的饿汉式。 这是比较常见的写法，在类加载的时候就完成了实例化，避免了多线程的同步问题。当然缺点也是有的，因为类加载时就实例化了，没有达到Lazy Loading (懒加载) 的效果，如果该实例没被使用，内存就浪费了。 而对于懒汉式，就是在需要的时候再创建类的实例化 普通懒汉式（线程不安全，不可用） 这是懒汉式中最简单的一种写法，只有在方法第一次被访问时才会实例化，达到了懒加载的效果。但是这种写法有个致命的问题，就是多线程的安全问题。假设对象还没被实例化，然后有两个线程同时访问，那么就可能出现多次实例化的结果，所以这种写法不可采用。 同步方法的懒汉式 这种写法是对getInstance()加了锁的处理，保证了同一时刻只能有一个线程访问并获得实例，但是缺点也很明显，因为synchronized是修饰整个方法，每个线程访问都要进行同步，而其实这个方法只执行一次实例化代码就够了，每次都同步方法显然效率低下，为了改进这种写法，就有了下面的双重检查懒汉式。 双重检查懒汉式 (可用，推荐) 这种写法用了两个if判断，也就是Double-Check，并且同步的不是方法，而是代码块，效率较高，是对第三种写法的改进。为什么要做两次判断呢？这是为了线程安全考虑，还是那个场景，对象还没实例化，两个线程A和B同时访问静态方法并同时运行到第一个if判断语句，这时线程A先进入同步代码块中实例化对象，结束之后线程B也进入同步代码块，如果没有第二个if判断语句，那么线程B也同样会执行实例化对象的操作了。 静态内部类 (可用，推荐) 这种写法在《Effective JAVA》中大为推崇，它可以解决两个问题： 1）线程安全问题。因为Java虚拟机在加载枚举类的时候会使用ClassLoader的方法，这个方法使用了同步代码块来保证线程安全。 2）避免反序列化破坏对象，因为枚举的反序列化并不通过反射实现。 ### 单例模式的优缺点 #### 优点 单例类只有一个实例，节省了内存资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能； 单例模式可以在系统设置全局的访问点，优化和共享数据，例如前面说的Web应用的页面计数器就可以用单例模式实现计数值的保存。 #### 缺点 单例模式一般没有接口，扩展的话除了修改代码基本上没有其他途径。 "},{"title":"每一天都要充实的度过！","date":"2020-11-09T16:00:00.000Z","url":"/2020/11/10/First/","categories":[["Java","/categories/Java/"]],"content":"此博客建立于2020年11月10日，目的为记录日常生活和学习。 希望能不断丰富这个博客的同时，也不断积累经验。 PS:偶尔也会偷懒~(才不)"}]