[{"title":"RabbitMq食用说明","date":"2021-12-08T16:00:00.000Z","url":"/2021/12/09/2021129-RabbitMq%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/","categories":[["消息队列","/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"]],"content":"消息队列MQ（Message Queue）字面意义上讲，其本质是个队列，FIFO(先入先出)，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游逻辑解耦+物理解耦的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。 MQ可以解决： 流量消峰 当一个订单系统一秒内最多能处理1万次订单，正常时段下单一秒后即可返回结果。但在高峰期，超过1万次操作系统是处理不了的，只能限制订单超过1万后不允许用户下单。 使用消息队列做缓冲，可以取消这个限制，将一秒内下的订单分散成一段时间来处理，这时有些用户可能会在下单十几秒后才收到下单成功的操作，但和不能下单比，体验要好得多。 应用解耦 如果电商应用中，有订单系统、库存系统、支付系统。当用户创建订单后，调用这些系统时，任何一个子系统出故障，都会导致下单出现异常。 使用消息队列做缓冲，系统间的调用问题会减少很多。如，当物流系统出现故障，需要几分钟时间修复时，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单即可。下单用户感受不到系统的故障，提升系统可用性。 异步处理 有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完。 常规有两种方式： A 过一段时间去调用 B 的查询 api 查询。 A 提供一个 callback api， B 执行完之后调用 api 通知 A 服务 使用消息队列： A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。 这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。 RabbitMQ概述2007年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统。 RabbitMQ 是一个消息中间件：它接受并转发消息。 优点：由于 erlang 语言的高并发特性，性能较好；吞吐量到万级，MQ 功能比较完备,健壮、稳定、易用、跨平台、支持多种语言 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX 文档齐全；开源提供的管理界面非常棒，用起来很好用,社区活跃度高；更新频率相当高。 核心概念生产者产生数据发送消息的程序是生产者 交换机交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得由交换机类型决定 队列队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。 消费者消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。生产者、消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。 工作原理 Broker：接受和分发消息的应用，RabbitMQ Server就是Message Broker Virtual host：处于多租户和安全因素设计，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ Server提供的服务时，可以划分出多个vhost，每个用户在自己的vhost创建exchange/queue等。 Connection：publisher/consumer 和 broker 之间的 TCP 连接 Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销 Exchange：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast) Queue：消息最终被送到这里等待 consumer 取走 Binding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据 核心模式简单模式(Hello World) 生产者代码创建队列名称 main()方法 消费者代码创建队列名称 mian()方法 当生产者运行后，会在队列中存放名为hello的信息。消费者启动后，信息被接受，队列中消息为空。 工作模式(Work queues)工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反，我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。 工作线程代码 在IDEA中的Edit Configurations选项中，勾选Allow parallel run选项，可以创建一个工作线程类，模拟多个工作线程环境 消费者代码 当在控制台分别输入AA BB CC DD时，两个工作线程分别轮流接收消息。 消息应答RabbitMQ一旦向消费者传递了一条信息，便立即将该消息标记为删除。当消费者处理该任务时仅完成了部分后死亡，就会丢失正在处理的信息，以及后续发送给该消费者的信息，因为它无法接收到。 为了保证消息在发送过程中不丢失，RabbitMQ引入消息应答机制：消费者在接收到消息并且处理该消息后，会发送一个ACK(消息)通知RabbitMQ，此时RabbitMQ可以把该消息删除。 自动应答消息发送后立即被认为传送成功。 该模式下，如果消息在接收到之前，消费者那边出现连接或channel关闭，那么消息就会丢失。 然而，这种模式没有对传递的消息数量进行限制，允许传递过载的信息。但是可能会导致消费者接收了太多消息来不及处理，导致消息积压，内存耗尽，使得消费者线程被操作系统杀死。因此，该模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。 手动应答消费者处理完业务逻辑，手动返回ACK(通知)告诉队列处理完毕，队列进而删除消息。可以进行批量应答，并减少网络堵塞。 方法： Channel.basicAck(用于肯定确认) Channel.basicNack(用于否定确认) Channel.basicReject(用于否定确认，与basicNack()相比少了Mutiple参数) 肯定确认：RabbitMQ已经知道该消息并且成功处理，可以将其丢弃 否定确认：不处理该消息，直接拒绝，可以将其丢弃 Mutiple： true：代表批量应答 channel 上未应答的消息 false：只会应答信道最近的一个消息 消息自动重新入队如果消费者由于某些原因失去连接(通道关闭，连接关闭或TCP连接丢失)，导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。 改手动应答实例生产者 消费者1 消费者2 SleepUtils工具类 当启动消费者1、2和生产者时，生产者发送两条消息，消费者1睡眠时间为1秒，所以会短暂停顿后接收消息。根据轮询的规则，第2条消费者2接收，但消费者2睡眠时间为30秒。待时间过后才会接收到消息。 如果在等待消费者2的过程中消费者2停止运行，此时将会由消费者1来接收消息。显示在消费者1中，符合消息自动重新入队概念。 RabbitMQ持久化默认情况下，RabbitMQ退出或者由于某种原因崩溃时，它忽视队列和消息。为了保障当RabbitMQ服务停止后消息不会丢失，需要将队列和消息都标记为持久化。 队列持久化将队列实现持久化，需要在生产者声明队列的时候将durable参数设置为true; 如果之前声明的队列不是持久化的，需要把原先队列先删除，或重新创建一个持久化的队列，否则会报错。 消息持久化将消息实现持久化，需要在生产者修改代码 将消息标记为持久化并不能完全保证不会丢失消息。存在着当消息刚准备存储在磁盘，但还没存储完时，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。持久性保证并不强。 不公平分发当两个消费者在处理任务，消费者1处理速度远大于消费者2时，使用轮询分发就会使得消费者1空闲很长时间。此时可以使用不公平分发来解决。 设置参数channel.basicQos(1); 含义是：如果当前任务没有处理完或者还没有进行应答，就先不分配给此消费者，然后rabbitMQ就会把该任务分配给空闲消费者。 如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。 预取值消息的发送本身即为异步发送，所以，任何时候，channel上肯定不止只有一个消息。另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，希望开发者能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。 该问题可以通过设置basic.qos方法设置预取数来完成。该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认。 消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的 RAM消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大 发布确认模式(Publisher Confirms)生产者将信道设置为confirm模式。该模式下，所有在该信道上发布的消息都会被指派一个唯一的ID(从1开始)，消息投递到匹配的队列后，就会向生产者发送一个确认消息，让生产者知道消息已经到达正确的队列。如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出。回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号 confirm其最大好处在于是异步执行，发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条，当消息得到确认后，生产者便可以通过回调方法来处理该消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息， 生产者应用程序同样可以在回调方法中处理该 nack 消息。 开启发布确认 发布确认默认是没有开启的，需创建信道后，调用此方法。 确认发布方式单个确认发布这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布,waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。该方法非常耗时。 创建单个确认发布方法 main方法调用 批量确认发布也是同步确认发布方式，先发送一批消息，然后再一起确认消息。可以极大提高吞吐量，但是如果出错不能查出具体是哪个消息出错。 创建批量确认发布方法 main()方法调用 异步确认发布 利用回调函数来达到消息可靠性传递 创建异步确认发布方法 创建监听器来监听消息 使用函数式接口来写回调函数(ackCallback,nackCallback) 处理异步未确认消息 创建集合，记录所有要发送的消息 删除已经确认的消息，剩余的就是未确认的消息 打印未确认的消息 对比单独发布消息：同步等待确认，简单，但吞吐量非常有限 批量发布消息：批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条 消息出现了问题 异步处理：最佳性能和资源使用，在出现错误的情况下可以很好地控制，但较难实现 发布/订阅模式(Publish/Subscribe)也称作广播模式(Fanout),将接收到的所有消息广播到它知道的所有队列中。 交换机RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从不会直接发送到队列。生产者只能将消息发送到交换机，交换机负责接收生产者的消息，再将它们推入队列。根据交换机类型的不同，处理收到的消息的方式也不相同。 交换机的类型直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout) 无名交换机通过空字符串(“”)来表示，表示默认或无名称交换机，消息能发送到队列中是由routingKey(bindingkey)绑定key指定的(如果存在的话)。 临时队列之前使用的一直是有指定名称的队列。队列的名称指定了消费者去消费哪个队列的消息。 每次连接到RabbitMQ时都需要创建一个全新的空队列，因此，可以创建一个具有随机名称的队列，或者能让服务器随机队列名称。当断开消费者连接时，队列也会被自动删除。 绑定绑定作为交换机和队列之间的桥梁，明确了交换机和哪个队列进行了绑定关系 Fanout交换机实例生产者代码 消费者1代码(打印在控制台) 消费者2代码(存入磁盘文件) 路由模式(Routing) 跟订阅模式类似，只不过在订阅模式的基础上加上了类型，订阅模式是分发到所有绑定到交换机的队列，路由模式只分发到绑定在交换机上面指定路由键的队列。 Direct exchangeFanout只能进行无意识的广播，使用direct可以让消息只去到它绑定的routingKey队列中去。 例如，交换机与多个队列绑定的routingKey不相同时，根据发消息时指定的routingKey不同，发送的对象也是不相同的。 多重绑定绑定类型还是direct，但是绑定的多个队列的key如果相同，该情况下，表现情况和fanout类似。 Direct交换机实例生产者代码 消费者1代码 消费者2代码 主题模式(Topics)topic交换机的消息的routingKey不能随意写，必须满足一定要求，它必须是一个单词列表，以点号分隔开。单词可以是任意单词，但不能超过255字节。 替换符规则列表中的替换符： *：可以代替一个单词 #：可以代替0个或多个单词 例如： (*.orange.*)：中间带orange大小共3个单词的字符串 (*.*.rabbit)：最后一个单词是rabbit大小共3个单词的字符串 (lazy.#)：第一个单词是lazy的多个单词 注意： 当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了 当队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了 实例生产者代码 消费者1代码 消费者2代码 死信队列死信，意为无法被消费的信息。一般来说，生产者将消息投递到队列后，消费者从队列取出消息进行消费，但是有时候因为某些原因导致队列中的消息无法被消费，此类消息若没有后续处理，就会成为死信。死信队列就是存放该类消息而存在。 死信来源 消息TTL过期 队列达到最大长度(队列满了，无法再添加数据到 mq 中) 消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false 死信工作流程 死信TTL消息过期先运行消费者1，建立好交换机与队列。再关闭消费者1使其不能接收消息，此时开启生产者发送消息和开启消费者2，消息到时间过期。消费者2接收到死信消息。 生产者代码 消费者1代码 生产者中的消息的存活时间为10秒，过后成为死信加入到死信队列中 消费者2代码（接收死信队列消息） 队列达到最大长度生产者代码 消费者1代码 在消息过期代码的基础上加上队列长度限制 消息被拒更改消费者1中的部分代码，让其info5不能被正常队列接收到 延迟队列用来存放需要在指定时间被处理的元素的队列。队列内部有序，在队列内部中的元素在指定时间到了之后或之前进行取出和处理。 队列TTL队列QA和QB的TTL分别为10S和40S，创建direct交换机X和Y，创建死信队列QD，以及绑定关系： 延迟队列实例创建Springboot工程 ttl队列配置类 rabbitMq配置文件 日志文件 生产者代码 消费者代码 延迟队列优化以上代码每新增一个时间需求，就需要创建一个队列。针对此缺点进行优化。 创建QC队列，该队列不设置TTL时间。让生产者发送消息的过期时间。 在原有队列配置类上加入 生产者中加入方法 消费者不做改变 该方法虽然使得队列的数量大大减少，但是如果使用在消息属性上设置TTL的方式，消息可能并不会死亡，RabbitMq只会检查第一个消息是否过期，如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。 例如： 你好 1/20000 你好 2/2000 RabbitMq插件实现延迟队列下载rabbitmq_delayed_message_exchange 插件并安装 安装后会多一个x-delayed-message类型的交换机，该类型消息支持延迟投递机制 消息传递后并 不会立即投递到目标队列中，而是存储在mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中 队列配置类 生产者代码 消费者代码 发起请求：  ybh-1/20000  ybh-2/2000 此时，第二个消息会先被消费。 总结延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正 确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。 发布确认高级"},{"title":"类的加载过程","date":"2021-11-29T16:00:00.000Z","url":"/2021/11/30/20211130-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","categories":[["JVM-字节码与类的加载","/categories/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"]],"content":"概述在Java中数据类型分为基本数据类型和引用数据类型。 基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载 按照Java虚拟机规范，从Class文件到加载到内存中的类，到类卸载出内存为止，整个生命周期为： 加载→链接{验证→准备→解析}→初始化→使用→卸载 加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中 Loading（加载）阶段加载就是将Java类的字节码文件加载到机器内存中，并构建出Java类的原型–类模板对象。 类模板对象：Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出常量池、类字段、类方法等信息存到类模板中，这样JVM在运行期即可通过类模板获取Java类中任意信息，对Java类中的成员进行遍历或方法调用。反射机制就是基于这一基础。 加载完成操作查找并加载类的二进制数据，生成Class实例。 在加载类时JVM必须完成3件事 通过类的全名，获取类的二进制数据流 解析类的二进制数据流为方法区内的数据结构(Java类模板) 创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口 二进制流的获取方式 虚拟机可能通过文件系统读入一个class后缀的文件 读入jar、zip等归档数据包、提取类文件 事先存放在数据库中的类的二进制数据 使用类似于Http之类的协议通过网络进行加载 在运行时生成一段Class的二进制信息等 收到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例 如果输入的数据不是ClassFile结构，就会抛出ClassFormatError错误 类模板与Class实例的位置类模板的位置加载的类在JVM中创建相应的类结构，类结构会存储在方法区(JDK8之前:永久代，JDK8之后:元空间) Class实例的位置类将.Class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象 说明： Class类的构造方法是私有的，只有JVM能够创建 Java.lang.Class实例是访问类型元数据的接口，也是反射的关键数据、入口。通过Class类提供的接口，可以获得目标类所关联的.Class文件中具体的数据结构：方法、字段等信息 数组类的加载数组类本身并不是由类加载器负责创建，而是JVM在运行时根据需要直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。 创建数组类的过程： 如果数组的元素类型为引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型 JVM使用指定的元素类型和数组维度来创建新的数组类 如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public Linking（链接）阶段Verification（验证）验证是链接操作的第一步，目的是保证加载的字节码是合法、合理并符合规范的 验证步骤大体为： 格式检查→语义检查→字节码验证→符号引用验证 其中，格式检查和加载阶段一起执行。验证通过，类加载器才会成功将类的二进制数据信息加载到方法区中。 格式检查之外的验证操作将在方法区中进行。 格式验证魔数检查：是否以魔数0XCAFEBABE开头 版本检查：主版本和副版本号是否在当前Java虚拟机的支持范围内 长度检查：数据中每一个项是否都拥有正确的长度等。 语义检查Java虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。如： 是否所有的类都有父类的存在（在Java里，除了object外，其他类都应该有父类） 是否一些被定义为final的方法或者类被重写或继承了 非抽象类是否实现了所有抽象方法或者接口方法 字节码验证字节码验证是验证过程中最为复杂的一个过程，试图通过对字节码流的分析，判断字节码是否可以被正确地执行。如： 在字节码的执行过程中，是否会跳转到一条不存在的指令 函数的调用是否传递了正确类型的参数 变量的赋值是不是给了正确的数据类型等 栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但并不是100%准确判断，只能尽可能地检查出可以预知的明显问题。 符号引用验证校验器还将进符号引用的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，虚拟机会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出NoClassDefFoundError，如果一个方法无法被找到，则会抛出NoSuchMethodError。此阶段在解析环节才会执行。 Preparation（准备）为类的静态变量分配内存，并将其初始化为默认值 当一个类验证通过时，虚拟机就会进入准备阶段。会为该类分配内存空间，并设置默认值 类型 默认初始值 byte (byte)0 short (short)0 int 0 long 0L float 0.0f double 0.0 char \\u0000 boolean false reference null Java并不支持boolean类型，对于boolean类型，内部实现是int，由于int的默认值是0，故对应的，boolean默认值为false 注意： 上述并不包含基本数据类型的字段用static final修饰的情况，final修饰的在编译的时候就会分配，准备阶段就会显式赋值。 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。 Resolution（解析）将类、接口、字段和方法的符号引用转为直接引用。 符号引用：就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。 以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。 通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用 Initialization（初始化）阶段为类的静态变量赋予正确的初始值 初始化阶段的重要工作是执行类的初始化方法:&lt;clinit&gt;()方法 此方法仅能由Java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法 由静态类成员的赋值语句以及static语句块合并产生的 补充： 父类的&lt;clinit&gt;()方法总是在子类的&lt;clinit&gt;()方法之前执行，也就是说父类的static块优先级高于子类 由父及子，静态先行 Java编译器不是为所有的类都能产生&lt;clinit&gt;()方法，当以下类编译为字节码文件时，字节码文件中不会包含&lt;clinit&gt;()方法 一个类中并没有声明任何的类变量，也没有静态代码块 一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作 一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式 static与final的搭配问题在链接阶段的准备环节赋值 对于基本数据类型来说，如果使用static final修饰，则在此环节显式赋值(直接赋常量，而非调用方法) 对于引用类型来说，使用字面量的方式赋值，使用static final修饰，则在此环节赋值 在初始化阶段&lt; clinit &gt;()赋值除了在链接阶段的准备环节赋值的情况外，其余的情况 结论使用static+final修饰，并且进行显示赋值（定义的时候后面就已经附了初始值），还不涉及到方法或者构造器调用的基本数据类型或者String类型字面量(“XXX”这种形式，而不是new String(“XXX”)这种形式)的字段，将在准备中的链接阶段进行显示赋值，其他已经进行显示赋值的静态常量（包括引用类型，尤其是new String(“XXX”)这种类型的，还有调用其他方法获得的值，比如new Random().nextInt(10)等）或者静态变量（这是肯定在初始化方法中显示赋值）都将在初始化中的方法中进行显示赋值 对于准备阶段就完成赋值的，其字段下面的有属性ConstantValue，否则是没有属性ConstantValue &lt; clinit &gt;()的线程安全性虚拟机会在内部确保其多线程环境中的安全性。 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境下被正确的加锁、同步。当多个线程去执行同一个初始化方法时，只会有一个线程去执行该方法，其他线程都需要阻塞等待，直到活动线程执行初始化方法完成。 同时，因为函数&lt;clinit&gt;()是线程安全的，所以，如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，就可能造成多个线程堵塞，引发死锁。此类死锁较难发现，它们看起来并没有可用的锁信息。 初始化方法只会加载一次，当其他类需要使用时，虚拟机会直接返回给它已经准备好的信息。 类的初始化情况：主动使用&amp;被动使用主动使用Class在首次使用时会被装载，虚拟机不会无条件地装载Class类型。Java虚拟机规定一个类或接口在初次使用前，必须要进行初始化。这个“使用”指的就是主动使用。 主动使用情况： 实例化：当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。 静态方法：当调用类的静态方法时，即当使用了字节码invokestatic指令。 静态字段：当使用类、接口的静态字段时（final修饰特殊考虑），比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作） 反射：当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”) 继承：当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 default方法：如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。 main方法：当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 MethodHandle：当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF getStatic、REF_putStatic、REF invokeStatic方法句柄对应的类） 出现上述情况时，会对类进行初始化。初始化之前的加载、验证、准备、解析已经完成 补充： 5：当Java虚拟机初始化一个类的时候，要求他的所有父类都已经被初始化，但是这条规则并不适用于接口： 初始化一个类时，并不会先初始化它所实现的接口 初始化一个接口时，并不会先初始化它的父接口 因此，一个父接口不会因为它的子接口或实现类的初始化而初始化。只有当程序第一次使用特定接口的静态字段时，会导致该接口的初始化。 7：JVM启动的时候通过引导类加载器加载一个初始类。这个类调用public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。 被动使用除了主动使用的8种情况外，其余均为被动使用。 被动使用不会影响类的初始化。或者说，并不是在代码中出现的类，就一定会被加载或初始化。如果不符合主动使用的条件的话，类就不会初始化。 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化 当通过子类引用父类的静态变量，子类加载但不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类接口的初始化。因为常量在链接阶段就已经被显式赋值了 调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。 类的使用(using)任何一个类在加载、链接和初始化3个类加载步骤结束后，即可被直接使用。 开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用new关键字为其创建对象实例。 类的卸载(Unloading)类、类加载器、类的实例之间的引用关系类加载器的内部实现中，使用一个Java集合来存放所加载类的引用。一个Class对象总会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。因此，一个类的类加载器与Class实例为双向关联关系 一个类的实例总是引用它的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有Java类都有一个静态属性class，它引用这个类的Class对象 类的生命周期当一个类被加载、链接、初始化后，它的生命周期就开始了。当代表此类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，该类在方法区内的数据也会被卸载，结束该类的生命周期。 一个类结束生命周期的时间，取决于它的Class对象何时结束生命周期 类的加载器概述类加载器时JVM执行类加载机制的前提 类加载器的分类Jvm加载class文件到内存的方式 显式加载显示加载指的是在代码中通过调用classLoader加载class对象，如直接调用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象 隐式加载隐式加载是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件的时候，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中 类加载器的必要性 避免在开发中遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，只有了解类加载器的加载机制才能够在出现异常时快速地根据错误异常日志定位问题和解决问题 需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作 开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的逻辑处理 命名空间类的唯一性对于任意一个类，都需要由加载它的类加载器和类本身一同确认其在Java虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。 命名空间概述 每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成 在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类 在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类 类加载器的基本特征通常有三个基本特征 双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。 可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。 单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。 类加载器的分类JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分 启动类加载器通过C/C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器 引导类加载器(Bootstrap ClassLoader) 这个类加载使用C/C++语言实现的，嵌套在JVM内部。 它用来加载Java的核心库（JAVAHOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。 并不继承自java.lang.ClassLoader，没有父加载器。 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。 使用-XX:+TraceClassLoading参数得到打印信息 扩展类加载器(Extension ClassLoader) Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。 继承于ClassLoader类 父类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。 系统类加载器(Application ClassLoader)应用程序类加载器（系统类加载器，AppClassLoader） java语言编写，由sun.misc.Launcher$AppClassLoader实现 继承于ClassLoader类 父类加载器为扩展类加载器 它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库 应用程序中的类加载器默认是系统类加载器 它是用户自定义类加载器的默认父加载器 通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器 用户自定义类加载器 在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。 体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。 通过类加载器可以实现绝妙的插件机制，例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。 同时，自定义加载器都能够实现应用隔离，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。 双亲委派模型概述如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。 规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。 优势避免类的重复加载，确保一个类的全局唯一性。（Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层次关系可以避免类的重复加载，当父类加载过该类时，子类不会重复加载。） 保护程序安全，防止核心API被随意篡改 双亲委派机制在java.lang.ClassLoader.loadClass(String，boolean)接口中体现。该接口的逻辑如下： 先在当前加载器的缓存中查找有无目标类，如果有，直接返回。 判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。 反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassorNull(name)接口，让引导类加载器进行加载。 如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。 双亲委派的模型就隐藏在这第2和第3步中。 劣势检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。 通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。 总结java虚拟机并没有规定一定要使用双亲委派模型，只是建议采用。比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Serylet规范推荐的一种做法。 破坏双亲委派机制双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。 在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。 第一次由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。 第二次双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题。但当基础类型又要回调用户代码时(JNDI服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码)，启动类加载器并不认识这些代码。此时设计团队设计了线程上下文加载器。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。 第三次由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等 IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。 当收到类加载请求时，OSGi将按照下面的顺序进行类搜索 将以java.*开头的类，委派给父类加载器加载 否则，将委派列表名单的类，委派给父类加载器加载 否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。 否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。 否则，查找Dynamic Import列表的Bundle，委派给对应Bund1e的类加载器加载。 否则，类查找失败。 说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的 热替换的实现热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。 热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。 但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。 注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。 沙箱安全机制 保证程序安全 保护Java原生的JDK代码 Java安全模式的核心就是Java沙箱(sandbox)。沙箱是一个限制程序运行的环境。 沙箱机制就是将Java代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问。保证对代码的有限隔离，防止对本地系统造成破坏。 沙箱主要限制系统资源访问。系统资源包括CPU、内存、文件系统、网络等。不同级别的沙箱对这些资源的访问限制也不一样。 所有的Java程序运行都可以指定沙箱，可以制定安全策略 JDK1.0时期在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱（Sandbox）机制。 JDK1.1时期JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。 因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限。 JDK1.2时期在Java1.2版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。 JDK1.6时期当前最新的安全机制实现，则引入了域（Domain）的概念。 虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限。 自定义类的加载器自定义类加载器作用隔离加载类在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如:阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如:Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。 修改类加载的方式类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载 扩展加载器比如从数据库、网络、甚至是电视机机顶盒进行加载 防止源码泄露Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。 使用场景 实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是JavaEE和OSGI、JPMS等框架。 应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。 注意：一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。 实现方式Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。 在自定义ClassLoader的子类时候，我们常见的会有两种做法: 方式一:重写loadClass()方法 方式二:重写findclass()方法 对比本质上差不多，loadClass()也会调用findClass()。但从逻辑上讲最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。 loadclass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此最好在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委派的重复代码，从代码复用性上来说，不直接修改这个方法始终是比较好的选择 当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作 说明 其父类加载器是系统类加载器 JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。 Java9新特性为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。 扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(platform class loader)。可以通过classLoader的新方法getPlatformClassLoader()来获取。JDK9时基于模块化进行构建(原来的rt.jar和tools.jar被拆分成数十个JMOD文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留\\lib\\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。 平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。 ​ 如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。 在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。 启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。 类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。 在Java模块化系统明确规定了三个类加载器负责各自加载的模块 启动类加载器负责加载的模块 java.basejava.security.sasljava.datatransferjava.xmljava.desktopjdk.httpserverjava.instrumentjdk.internal.vm.cijava.loggingjdk.managementjava.managementjdk.management.agentjava.management.rmijdk.naming.rmijava.namingjdk.netjava.prefsjdk.sctpjava.rmijdk. unsupported 平台类加载器负责加载的模块 java.activation*jdk.accessibilityjava.compiler*jdk.charsetsjava.corba*jdk.crypto.cryptokijava.scriptingjdk.crypto.ecjava.sejdk.dynalinkjava. se.eejdk.incubator.httpclientjava.security.jgssjdk.internal.vm.compiler*java.smartcardiojdk .jsobjectjava.sqljdk . localedatajava.sql.rowsetjdk.naming.dnsjava.transaction*jdk.scripting.nashornjava.xml.bind*jdk.security.authjava.xml.cryptojdk.security.jgssjava.xml.ws*jdk .xml.domjava.xml.ws.annotation*jdk.zipfs 应用程序类加载器负责加载的模块 jdk.aotjdk.jdepsjdk.attachjdk.jdijdk.compilerjdk.jdwp.agent "},{"title":"Class文件结构","date":"2021-11-22T16:00:00.000Z","url":"/2021/11/23/20211123-Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","categories":[["JVM-字节码与类的加载","/categories/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"]],"content":"概述Java的前端编译器让一个Java程序正确的在JVM中运行，Java源代码就需要被编译为符合JVM规范的字节码文件，而javac是一种能做到这种功能的前端编译器。 javac的编译过程分为了四个步骤： 词法解析 语法解析 语义解析 生成字节码 HotSpot VM中没有强制要求只能使用javac来编译字节码，只要是符合JVM规范，可被JVM所识别的都可以。 除了javac外，内置在Eclipse中的ECJ(Eclipse Compiler for Java)编译器也是经常用的前端编译器。 不同的是，Javac属于全量式编译，ECJ属于增量式编译 当开发人员使用 ctrl+s保存时，ECJ所采取的编译方案是把未编译部分的源码逐行编译而非每次都全量编译。因此在效率上，ECJ比javac要好一些，同时编译质量和javac也大致一样。 在Tomcat中，也是使用ECJ编译器来编译jsp文件 补充：前端控制器不会直接涉及编译优化等方面的技术，而是将这些具体优化细节移交给HotSpot的JIT编译器负责 透过字节码指令看代码细节Class文件字节码文件一种二进制的类文件，它的内容是JVM的指令，而不像C、C++经由编译器直接生成机器码 字节码指令由一个字节长度、代表着某种特定操作含义的操作码，以及跟随其后的0个或多个代表此操作所需参数的操作数构成。 虚拟机中许多指令并不包含操作数，只有一个操作码 Class文件格式Class文件里，其中的数据项，无论是字节顺序或数量，都是被严格限定的，字节含义，长度，先后顺序，都不允许改变 Class文件格式使用类似于C语言结构体的方式进行存储，这种结构只有两种数据类型：无符号数和表 无符号数属于基本的数据类型，以u1、u2、u4、u8来表示1字节、2字节、4字节、8字节的无符号数。 无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。 表由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性的以_info结尾。 表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明 Class文件结构随着Java虚拟机的不断发展，其内部结构也不断进行调整，但其基本框架和结构非常稳定。 Class文件总体结构为： 魔数 Class文件版本 常量池 访问标志 类索引，父类索引，接口索引集合 字段表集合 方法表集合 属性表集合 魔数(Magic Number)每个Class文件开头的4个字节的无符号整数。 魔数值为：0xCAFEBABE，不会改变。 主要用于确定这个文件是否为一个能被虚拟机接受的有效合法的class文件。如果不是以规定的形式开头，则会报错：Error: A JNI error has occurred,please check your installation and try again 扩展名可以随意更改，所以不能用于进行文件识别。 Class文件版本号Class文件版本号分为主版本号和副版本号，它们共同构成了Class文件的格式版本号。如：主版本号为M，副版本号为m，则版本号为：M.m Java的版本号是从45开始的，1.1之后每个大版本发布后，主版本号+1。副版本号从1.1往后为0 不同版本的Java编译器编译的Class文件对应的版本是不一样的。 高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是反之则不行，会抛出java.lang.UnsupportedClassVersionError的异常 虚拟机JDK版本为1.k(k&gt;=2)时，对应的class文件格式版本号的范围为45.0~44+k.0 常量池常量池计数器(constant_pool_count)常量池的数量不固定，需要放置两个字节来表示常量池容量计数值 常量池容量计数值：从1开始，表示常量池中有多少项常量。(如：constant_pool_count=1表示常量池中有0个常量项) 注意：通常写程序时都是从0开始，但常量池是从1开始，它将第0项常量空出来了。为的是满足后面某些指向常量池的索引值的数据在特定情况下需要表达”不引用任何一个常量池的常量项”的含义，这种情况可用索引值0来表示。 常量池表(constant_pool []) constant_pool是一种表结构，以1~constant_pool_count-1为索引。表明后面有多少个常量项。 常量池主要存放两大类常量：字面量(Literal)和符号引用(Symbolic References) 包含了Class文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第一个字节作为类型标记，用于确定该项的格式。这个字节称为tag byte(标记字节，标签字节) 字面量 分为文本字符串和声明为final的常量值 符号引用 分为： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 全限定名：将包名的.替换为/最后以;结束 简单名称：没有类型和参数修饰的方法或者字段名称 描述符：用来描述字段的数据类型、方法的参数列表(数量、类型、以及顺序)和返回值 根据描述符规则，基本数据类型以及void类型都用一个大写字符表示，而对象类型则用字符L加对象的全限定名表示。 标志符 含义 B 基本数据类型byte C 基本数据类型char D 基本数据类型double F 基本数据类型float I 基本数据类型int J 基本数据类型long S 基本数据类型short Z 基本数据类型boolean V 代表void类型 L 对象类型，比如：Ljava/lang/Object; [ 数组类型，代表一维数组。比如：double[][][] is [[[D 补充： 虚拟机在加载Class文件时才会进行动态链接。即，Class文件不会保存各个方法和字段的最终内存布局消息。因此，虚拟机运行时需要先从常量池获取对应的符号引用，在之后的类加载过程的解析阶段替换为直接引用，并翻译到具体的内存地址中。 常量类型和结构 这14个常量项结构的共同点是表开始的第一位是一个u1类型的标志位(tag)，代表当前这个常量项使用的是哪种结构，即，哪种常量类型。 其中，CONSTANT_Utf8_info常量项是一种使用改进过的UTF-8编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息 这14种常量项结构还有一个特点，其中13个常量项占用的字节固定，只有CONSTANT_Utf8_info占用字节不固定，大小由length来决定。究其原因在于常量池存放的是字面量和符号引用，最终这些内容都会是一个字符串，而这字符串大小是在编写程序时确定的。 访问标识(access_flag)该标识使用2个字节表示，用于识别一些类和接口层次的访问信息。如：判断Class是类还是接口，是否为public类型，是否为抽象类，是否被声明为final等。 标志名称 标志值 含义 ACC_PUBLIC 0x0001 标志为public类型 ACC_FINAL 0x0010 标志被声明为final，只有类可以设置 ACC_SUPER 0x0020 标志允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法） ACC_INTERFACE 0x0200 标志这是一个接口 ACC_ABSTRACT 0x0400 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 ACC_SYNTHETIC 0x1000 标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应） ACC_ANNOTATION 0x2000 标志这是一个注解 ACC_ENUM 0x4000 标志这是一个枚举 类的访问权限通常为ACC_开头的常量 带有ACC_INTERFACE标志的class文件表示的是接口不是类，反之亦然 索引在访问标识后，会指定该类的类别、父类类别以及实现的接口 长度 含义 u2 this_class u2 super_class u2 interfaces_count u2 interfaces[interfaces_count] 通过这三项数据来确定这个类的继承关系 类索引确定这个类的全限定名 父类索引用于确定这个类的父类的全限定名。同时，因为java.lang.Object没有父类。因此，除了java.lang.Object外，其他所有类的父类索引都不为0 接口索引集合用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句(如果这个类本身是一个接口，则应当是extends语句)后的接口顺序从左到右排列在接口索引集合中。 this_class（类索引）2字节无符号整数，指向常量池的索引。它提供了类的全限定名。this_class的值必须是对常量池表中某项的有效索引值。常量池在这个索引处的成员必须为constant_Class_info类型结构体，该结构体表示这个class文件所定义的类或接口 super_class（父类索引）2字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。superclass指向的父类不能是final interfaces指向常量池索引集合，它提供了一个符号引用到所有已实现的接口。因为可以实现多个接口，因此需要以数组的形式保存多个接口索引，表示接口的每个索引也是一个指向常量池的CONSTANT——Class interface_count(接口计数器) interfaces_count项的值表示当前类或接口的数量 interfaces [] (接口索引集合) interfaces []中每个成员值必须是对常量表池中某项的有效索引值，它的长度为interfaces_count。每个成员interfaces[i]必须为CONSTANT_Class_info结构，其中0&lt;=i&lt;interfaces_count.各成员表示的接口顺序和对应的源代码中给定的接口顺序一样。 字段表用于描述接口或类中声明的变量。字段包括类级变量以及实例级变量，但是不包括方法内部、代码块内部的局部变量。 字段的名字、数据类型是无法固定的，只能引用常量池中的常量描述 它指向常量池索引集合，描述了每个字段的完整信息。如，字段的标识符、访问修饰符、类变量/实例变量、常量 字段计数器fields_count（字段计数器） fields_count的值表示当前class文件fields表的成员个数。使用两个字节来表示。 fields表中每个成员都是一个field_info结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。 标志名称 标志值 含义 数量 u2 access_flags 访问标志 1 u2 name_index 字段名索引 1 u2 descriptor_index 描述符索引 1 u2 attributes_count 属性计数器 1 attribute_info attributes 属性集合 attributes_count 字段表字段表访问标识一个字段可以被各种关键字去修饰。因此，其可像类的访问标志那样，使用一些标志来标记字段 标志名称 标志值 含义 ACC_PUBLIC 0x0001 字段是否为public ACC_PRIVATE 0x0002 字段是否为private ACC_PROTECTED 0x0004 字段是否为protected ACC_STATIC 0x0008 字段是否为static ACC_FINAL 0x0010 字段是否为final ACC_VOLATILE 0x0040 字段是否为volatile ACC_TRANSTENT 0x0080 字段是否为transient ACC_SYNCHETIC 0x1000 字段是否为由编译器自动产生 ACC_ENUM 0x4000 字段是否为enum 描述符索引用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型及代表无返回值的void类型都用一个大写字符来表示，而对象则用字符L加对象的全限定名来表示 标志符 含义 B 基本数据类型byte C 基本数据类型char D 基本数据类型double F 基本数据类型float I 基本数据类型int J 基本数据类型long S 基本数据类型short Z 基本数据类型boolean V 代表void类型 L 对象类型，比如：Ljava/lang/Object; [ 数组类型，代表一维数组。比如：`double[][][] is [[[D 属性表集合一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在attribute_count中，属性具体内容存放在attributes数组中。 对于常量属性而言，attribute_length值恒为2 方法表指向常量池索引集合，它完整描述了每个方法的签名 在字节码文件中，每一个method_info项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private或protected），方法的返回值类型以及方法的参数信息等。 如果这个方法不是抽象的或者不是native的，那么字节码中会体现出来。 一方面，methods表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法&lt;clinit&gt;()和实例初始化方法&lt;init&gt;()）。 在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个class文件中。 也就是说，尽管Java语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和Java语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。 方法计数器method_count(方法计数器) methods_count的值表示当前class文件methods表的成员个数。使用两个字节来表示。 methods表中每个成员都是一个method_info结构。 method[]methods表中的每个成员都必须是一个method_info结构，用于表示当前类或接口中某个方法的完整描述。如果某个method_info结构的access_flags项既没有设置ACC_NATIVE标志也没有设置ACC_ABSTRACT标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。 method_info结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法 标志名称 标志值 含义 数量 u2 access_flags 访问标志 1 u2 name_index 方法名索引 1 u2 descriptor_index 描述符索引 1 u2 attributes_count 属性计数器 1 attribute_info attributes 属性集合 attributes_count 方法表访问标志 标志名称 标志值 含义 ACC_PUBLIC 0x0001 public，方法可以从包外访问 ACC_PRIVATE 0x0002 private，方法只能本类访问 ACC_PROTECTED 0x0004 protected，方法在自身和子类可以访问 ACC_STATIC 0x0008 static，静态方法 属性表方法表集合之后的属性表集合，指的是class文件所携带的辅助信息，比如该class文件的源文件的名称。以及任何带有RetentionPolicy.CLASS 或者RetentionPolicy.RUNTIME的注解。这类信息通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无须深入了解 此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。 属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但Java虚拟机运行时会忽略掉它不认识的属性。 属性计数器attributes_count的值表示当前class文件属性表的成员个数。属性表中每一项都是一个attribute_info结构。 属性表属性表的每个项的值必须是attribute_info结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。 属性的通用格式 类型 名称 数量 含义 u2 attribute_name_index 1 属性名索引 u4 attribute_length 1 属性长度 u1 info attribute_length 属性表 属性类型 属性名称 使用位置 含义 Code 方法表 Java代码编译成的字节码指令 ConstantValue 字段表 final关键字定义的常量池 Deprecated 类，方法，字段表 被声明为deprecated的方法和字段 Exceptions 方法表 方法抛出的异常 EnclosingMethod 类文件 仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法 InnerClass 类文件 内部类列表 LineNumberTable Code属性 Java源码的行号与字节码指令的对应关系 LocalVariableTable Code属性 方法的局部变量描述 StackMapTable Code属性 JDK1.6中新增的属性，供新的类型检查检验器和处理目标方法的局部变量和操作数有所需要的类是否匹配 Signature 类，方法表，字段表 用于支持泛型情况下的方法签名 SourceFile 类文件 记录源文件名称 SourceDebugExtension 类文件 用于存储额外的调试信息 Synthetic 类，方法表，字段表 标志方法或字段为编译器自动生成的 LocalVariableTypeTable 类 是哟很难过特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加 RuntimeVisibleAnnotations 类，方法表，字段表 为动态注解提供支持 RuntimeInvisibleAnnotations 类，方法表，字段表 用于指明哪些注解是运行时不可见的 RuntimeVisibleParameterAnnotation 方法表 作用与RuntimeVisibleAnnotations属性类似，只不过作用对象或方法 RuntimeInvisibleParameterAnnotation 方法表 作用与RuntimeInvisibleAnnotations属性类似，只不过作用对象或方法 AnnotationDefault 方法表 用于记录注解类元素的默认值 BootstrapMethods 类文件 用于保存invokeddynamic指令引用的引导方法限定符 "},{"title":"MyBatis-Plus食用说明(持续更新)","date":"2021-11-21T16:00:00.000Z","url":"/2021/11/22/20211122-MyBatis-Plus%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/","categories":[["MyBatis","/categories/MyBatis/"]],"content":" 根据面试或实际使用来记录，持续更新。。。 快速搭建 创建一个SpringBoot工程，导入MyBatis-plus、MySQLDriver、SpringFrameWork、lombok依赖 在启动类中加入扫描mapper文件注解：@MapperScan(&quot;mapper文件夹路径&quot;) 在application.yml中写SQL配置。 创建实体类和Mapper接口，Mapper接口继承BaseMapper&lt;&gt; 创建测试类，实现基本的CRUD功能 优点：相较于MyBatis，一些简单的功能不用再写xml文件，同时增加了许多功能，简化了开发。 配置日志 通过配置日志来查看SQL是如何执行的 CRUDInsert 设置主键设置主键id时，需要在实体类字段上使用@TableId(type = IdType.类型) 默认为ID_WORKER 使用AUTO时，需要在数据库配置主键自增 Update 自动填充一般来讲，创建时间、更新时间这类字段都是自动化操作，不希望手动更新 方式一：数据库级别 在表中添加create_time、update_time字段，数据类型为timestamp，默认为CURRENT_TIMESTAMP,update_time字段选择根据时间戳更新 在实体类中同步字段 再次测试更新和创建时间 方式二：代码级别 创建在表中添加create_time、update_time字段，数据类型为timestamp，无需默认值，更新时间戳 在实体类中添加字段注解 编写处理器，实现MetaObjectHandler接口，并在重写的方法中实现功能 注意：此类要加上@Component注解，必须加入到IOC容器中 Select通过id来查询用户 通过id查询多个用户 通过map封装的条件查询 分页查询在配置类中写入 测试方法中写入 其中new Page&lt;&gt;(current：2,size：5);中：current表示当前页。size表示页面大小 Delete根据id删除userMapper.deleteById(id); 根据id批量删除userMapper.deleteBatchIds(Arrays.asList(id1,id2,...)); 根据map封装的条件删除 逻辑删除 物理删除：从数据库中删除 逻辑删除：在数据库中没有被删除，通过一个变量使它失效 在application.yml中配置 在实体类中添加字段 条件构造器创建一个Wrapper对象：QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;(); 使用wrapper封装好的方法：wrapper.方法; 具体方法很多，参考官方文档 实例: "},{"title":"反正算是知识点但因为不知道怎么分类就随便起个名字吧","date":"2021-11-21T16:00:00.000Z","url":"/2021/11/22/20211122-%E6%AF%8F%E6%97%A5%E7%9F%A5%E8%AF%86%E7%82%B9/","categories":[["Java","/categories/Java/"]],"content":"GET和POST请求区别 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中 cookie、localStorage和sessionStorage区别生命周期cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效localStorage：除非被手动清除，否则将会永久保存。sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。 存放数据大小cookie：4KB左右localStorage和sessionStorage：可以保存5MB的信息。 http请求cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性cookie：需要程序员自己封装，源生的Cookie接口不友好localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 抽象类和接口的区别 抽象类可以同时有普通方法和抽象方法，接口中的所有方法都是抽象方法，不可自己实现。 抽象类可以有构造函数，但不能实例化。接口没有构造函数，不能实例化。 抽象类有普通成员变量，接口中只有隐式的public static final修饰的静态常量，并且必须赋初值。 一个实现类可以实现多个接口，但只能继承一个抽象类 Java8改动后 允许接口中定义默认方法(default关键字)和类方法。默认方法可以通过实现接口的类实例化的对象来调用。但静态方法只能用public修饰。 抽象方法和其他修饰符问题 abstract的method不可以同时是static的 abstract的method不可以同时是native的 abstract的method不可以同时是synchronized的 abstract的method不可以同时是final的 http常见状态码 200 ——客户端请求成功 301 ——Moved Permanently（永久移除)，请求的 URL 已移走。 Response 中应该包含一个 LocationURL, 说明资源现在所处的位置 302 ——found 重定向 400 ——Bad Request 客户端请求有语法错误， 不能被服务器所理解 401 ——Unauthorized 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 403 ——Forbidden 服务器收到请求，但是拒绝提供服务 404 ——Not Found 请求资源不存在， eg：输入了错误的 URL 500 ——Internal Server Error 服务器发生不可预期的错误 503 ——Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 static关键字作用 Static可以修饰内部类、方法、变量、代码块。 Static修饰的类是静态内部类。 Static修饰的方法是静态方法，表示该方法属于当前类的，而不属于某个对象的，静态方法也不能被重写，可以直接使用类名来调用。在static方法中不能使用this或者super关键字。 Static修饰变量是静态变量或者叫类变量，静态变量被所有实例所共享，不会依赖于对象。静态变量在内存中只有一份拷贝，在JVM加载类的时候，只为静态分配一次内存。 Static修饰的代码块叫静态代码块，通常用来做程序优化的。静态代码块中的代码在整个类加载的时候只会执行一次。静态代码块可以有多个，如果有多个，按照先后顺序依次执行。 基本数据类型和引用数据类型基本数据类型基本类型的访问是按值访问的，就是说你可以操作保存在变量中的实际的值。有如下特点：1、基本数据类型的值是不可变的（我们不能给基本数据类型添加属性和方法）；2、基本数据类型的比较是值的比较（只有他们的值相等的时候才是相等的）；3、基本数据类型的变量是存放在栈里面的 引用数据类型对象是属性和方法的集合，也就是说引用数据类型可以拥有属性和方法，属性又可以包括基本数据类型和引用数据类型。有如下特点：1、引用数据类型可以拥有属性和方法，且值是可变的；2、引用数据类型的值是同时保存在栈内存和堆内存的对象3、引用类型的比较是引用的比较 转换所有的基本类型都有对应引用类型，以long为例 long nativeLong = 0L; Long objectLong = Long.valueOf(nativeLong); nativeLong = objectLong.longValue();"},{"title":"垃圾回收器","date":"2021-11-18T16:00:00.000Z","url":"/2021/11/19/20211119-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/","categories":[["JVM-垃圾回收","/categories/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"]],"content":"GC分类与性能指标垃圾回收器概述 垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。 由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。 从不同角度分析垃圾收集器，可以将GC分为不同的类型。 垃圾回收器分类按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器 和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。 按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。 并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。 独占式垃圾回收器（Stop the World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。 按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。再分配对象空间使用指针碰撞 非压缩式的垃圾回收器不进行这步操作，分配对象空间使用空闲列表 按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。 评估GC的性能指标 吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间） 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。 收集频率：相对于应用程序的执行，收集操作发生的频率。 内存占用：Java堆区所占的内存大小。 快速：一个对象从诞生到被回收所经历的时间。 吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。 这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。 简单来说，主要抓住两点： 吞吐量 暂停时间 吞吐量(throughput)吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间） 比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。 吞吐量优先意味着应用程序能容忍较高的暂停时间。在单位时间内，STW的次数越少越好 暂停时间(pause time)指一个时间段内应用程序线程暂停，让GC线程执行的状态。 例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的 暂停时间优先意味着尽量让STW的时间最短,但总的GC时间可能会变长 总结 高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。 低暂停时间（低延迟）较好，是从最终用户的角度来看，不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有较低的暂停时间是非常重要的，特别是对于一个交互式应用程序（就是和用户交互比较多的场景）。 不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。 因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收。 相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。 在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。 现在标准：在最大吞吐量优先的情况下，降低停顿时间 不同的垃圾回收器概述 垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。 那么，Java常见的垃圾收集器有哪些？ 垃圾收集器发展史有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。 1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本 2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布· Parallel GC在JDK6之后成为HotSpot默认GC。 2012年，在JDK1.7u4版本中，G1可用。 2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。 2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。 2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental） 2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。 2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。 2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用 7个经典垃圾回收器 串行回收器：Serial、Serial old 并行回收器：ParNew、Parallel Scavenge、Parallel old 并发回收器：CMS、G1 新生代收集器：Serial、ParNew、Parallel Scavenge； 老年代收集器：Serial old、Parallel old、CMS； 整堆收集器：G1； 垃圾收集器的组合关系 两个收集器间有连线，表明它们可以搭配使用： Serial/Serial old Serial/CMS （JDK9废弃） ParNew/Serial Old （JDK9废弃） ParNew/CMS Parallel Scavenge/Serial Old （预计废弃） Parallel Scavenge/Parallel Old G1 其中Serial Old作为CMS出现”Concurrent Mode Failure”失败的后备预案。 （红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。 （绿色虚线）JDK14中：弃用Parallel Scavenge和Serial Old GC组合（JEP366） （青色虚线）JDK14中：删除CMS垃圾回收器（JEP363） 补充： 为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。 虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以我们选择的只是对具体应用最合适的收集器。 查看默认垃圾收集器 -XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器） 使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID JDK8在 JDK 8 下，设置 JVM 参数 -XX:+PrintCommandLineFlags 程序打印输出：-XX:+UseParallelGC 表示使用使用 ParallelGC ，ParallelGC 默认和 Parallel Old 绑定使用 通过命令行指令查看 命令行命令 JDK 8 中默认使用 ParallelGC 和 ParallelOldGC 的组合 Serial回收器 Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。 Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。 Serial收集器采用复制算法、串行回收和”Stop-the-World”机制的方式执行内存回收。 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial old收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。 Serial Old是运行在Client模式下默认的老年代的垃圾回收器，Serial Old在Server模式下主要有两个用途：①与新生代的Parallel Scavenge配合使用②作为老年代CMS收集器的后备垃圾收集方案 这个收集器是一个单线程的收集器，“单线程”的意义：它只会使用一个CPU（串行）或一条收集线程去完成垃圾收集工作。更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World） Serial 回收器的优势 优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。 在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。 在HotSpot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。 等价于新生代用Serial GC，且老年代用Serial Old GC 总结 这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核CPU才可以用。现在都不是单核的了。 对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java Web应用程序中是不会采用串行垃圾收集器的。 ParNew回收器 如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。 Par是Parallel的缩写，New：只能处理新生代 ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”Stop-the-World”机制。 ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。 补充： 对于新生代，回收次数频繁，使用并行方式高效。 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源） 例如：虽然ParNew收集器在多CPU环境下，由于可以利用多CPU，多核心等物理资源优势来更快速的完成垃圾回收，提升程序的吞吐量。但是在单个CPU环境下，并不比Serial收集器更高效。虽然Serial基于串行回收，但是由于CPU不需要频繁的做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。除了Serial外，目前只有ParNew能与CMS收集器配合工作 Parallel回收器Parallel Scavenge 回收器：吞吐量优先 HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。 那么Parallel收集器的出现是否多此一举？ 和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput），它也被称为吞吐量优先的垃圾收集器。 自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。（动态调整内存分配情况，以达到一个最优的吞吐量或低延迟） 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。 Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。 Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-the-World”机制。 补充： 在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在server模式下的内存回收性能很不错。 在Java8中，默认是此垃圾收集器。 Parallel Scavenge 回收器参数设置 -XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务。 -XX:+UseParallelOldGC：手动指定老年代都是使用并行回收收集器。 分别适用于新生代和老年代 上面两个参数分别适用于新生代和老年代。默认jdk8是开启的。默认开启一个，另一个也会被开启。（互相激活） -XX:ParallelGCThreads：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。 在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。 当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]/8] -XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。 为了尽可能地把停顿时间控制在XX:MaxGCPauseMillis 以内，收集器在工作时会调整Java堆大小或者其他一些参数。 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。 该参数使用需谨慎。 -XX:GCTimeRatio垃圾收集时间占总时间的比例，即等于 1 / (N+1) ，用于衡量吞吐量的大小。 取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1。 与前一个-XX:MaxGCPauseMillis参数有一定矛盾性，STW暂停时间越长，Radio参数就容易超过设定的比例。 -XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有自适应调节策略 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。 CMS回收器 在JDK1.5时期，Hotspot推出了一款在强交互应用中（就是和用户打交道的应用）几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。 CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。 CMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-the-World” 不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作（因为实现的框架不一样，没办法兼容使用），所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。 在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。 CMS工作原理CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记) 初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。 并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。 重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，并且也会导致“Stop-the-World”的发生，但也远比并发标记阶段的时间短。 并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的 CMS分析 尽管CMS收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。 由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。 另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。 CMS收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。 补充： 因为CMS在并发清除的时候，用Compact()方法（压缩缓冲区）整理内存的话，原来的用户线程使用的内存会受到影响。要保证用户的线程能继续执行，前提条件就是它运行的资源不受影响。标记-整理算法更适合STW这种场景下使用 CMS的优点与缺点 优点 并发收集 低延迟 缺点 会产生内存碎片，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。 CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。 CMS收集器无法处理浮动垃圾。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。 CMS参数配置 -XX:+UseConcMarkSweepGC：手动指定使用CMS收集器执行内存回收任务。 开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew（Young区）+CMS（Old区）+Serial Old（Old区备选方案）的组合。 -XX:CMSInitiatingOccupanyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。 JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92% 如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。 -XX:+UseCMSCompactAtFullCollection：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。 -XX:CMSFullGCsBeforeCompaction：设置在执行多少次Full GC后对内存空间进行压缩整理。 -XX:ParallelCMSThreads：设置CMS的线程数量。 CMS默认启动的线程数是 (ParallelGCThreads + 3) / 4，ParallelGCThreads是年轻代并行收集器的线程数，可以当做是 CPU 最大支持的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。 总结 如果你想要最小化地使用内存和并行开销，请选Serial GC； 如果你想要最大化应用程序的吞吐量，请选Parallel GC； 如果你想要最小化GC的中断或停顿时间，请选CMS GC。 JDK后续版本中CMS变化 JDK9新特性：CMS被标记为Deprecate了（JEP291） 如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。 JDK14新特性：删除CMS垃圾回收器（JEP363）移除了CMS垃圾收集器， 如果在JDK14中使用XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM G1回收器 G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。 与此同时，为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。 官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。 G1回收器的优势与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示： 并行与并发兼备 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况 分代收集 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。 将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代； G1的分代区域与内存结构不同： 空间整合 CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理 G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。 可预测的停顿时间模型（即：软实时soft real-time） 这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。 G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。 G1回收器的缺点 相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。 从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。 G1参数设置 -XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务 -XX:G1HeapRegionSize：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。 -XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标，JVM会尽力实现，但不保证达到。默认值是200ms -XX:+ParallelGCThread：设置STW工作线程数的值。最多设置为8 -XX:ConcGCThreads：设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。 -XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。 G1收集器的常见操作步骤G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优： 第一步：开启G1垃圾收集器 第二步：设置堆的最大内存 第三步：设置最大的停顿时间 G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。 G1的使用场景 面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜） 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案； 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。 用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好： 超过50%的Java堆被活动数据占用； 对象分配频率或年代提升频率变化很大； GC停顿时间过长（长于0.5至1秒） HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。 分区Region分区 Region：化整为零 使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过 XX:G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。 一个Region有可能属于Eden，Survivor或者Old/Tenured内存区域。但是一个Region只可能属于一个角色。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。 G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过0.5个Region，就放到H。 设置 H 的原因 对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。 Region细节 每个Region都是通过指针碰撞来分配空间 G1为每一个Region设 计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。 TLAB还是用来保证并发性 G1垃圾回收流程G1 GC的垃圾回收过程主要包括如下三个环节： 年轻代GC（Young GC） 老年代并发标记过程（Concurrent Marking） 混合回收（Mixed GC） （如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。） 顺时针，Young GC –&gt; Young GC+Concurrent Marking –&gt; Mixed GC顺序，进行垃圾回收 回收流程 应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。 当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。 举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。 Remembered Set（记忆集） 一个对象被不同区域引用的问题 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？ 在其他的分代收集器，也存在这样的问题（而G1更突出，因为G1主要针对大堆） 回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率 解决方法： 无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全堆扫描； 每个Region都有一个对应的Remembered Set 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作； 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）； 如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中； 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。 G1回收过程一：年轻代GC JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。 年轻代回收只回收Eden区和Survivor区 YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。 细致过程： 然后开始如下回收过程： 第一阶段，扫描根 根是指GC Roots，根引用连同RSet记录的外部引用作为扫描存活对象的入口。 第二阶段，更新RSet 第三阶段，处理RSet 识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。 第四阶段，复制对象。 此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象 如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。 如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。 第五阶段，处理引用 处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。 备注： 对于应用程序的引用赋值语句 oldObject.field（这个是老年代）=object（这个是新生代），JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。 那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。 G1回收过程二：并发标记过程 初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。正是由于该阶段时STW的，所以我们只扫描根节点可达的对象，以节省时间。 根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成，因为Young GC会使用复制算法对Survivor区进行GC。 并发标记（Concurrent Marking）： 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断。 在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。 同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。 再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的原始快照算法：Snapshot-At-The-Beginning（SATB）。 独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集 并发清理阶段：识别并清理完全空闲的区域。 G1回收过程三：混合回收过程当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。 混合回收的细节 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收。【意思就是一个Region会被分为8个内存段】 混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。 由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收。XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。 混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。 G1回收过程四：Full GC (可选) G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。 要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。 导致G1 Full GC的原因可能有两个： EVacuation的时候没有足够的to-space来存放晋升的对象； 并发处理过程完成之前空间耗尽。 G1补充从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。 G1 回收器的优化建议 年轻代大小 避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。我们让G1自己去调整 暂停时间目标不要太过严苛 G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间 评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。 垃圾回收器总结截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。 垃圾回收器选择Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？ 优先调整堆的大小让JVM自适应完成。 如果内存小于100M，使用串行收集器 如果是单核、单机程序，并且没有停顿时间的要求，串行收集器 如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择 如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器 官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。 最后需要明确一个观点： 没有最好的收集器，更没有万能的收集算法 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器 GC日志分析常用参数配置 GC 日志参数设置 通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表 -XX:+PrintGC ：输出GC日志。类似：-verbose:gc -XX:+PrintGCDetails ：输出GC的详细日志 -XX:+PrintGCTimestamps ：输出GC的时间戳（以基准时间的形式） -XX:+PrintGCDatestamps ：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800） -XX:+PrintHeapAtGC ：在进行GC的前后打印出堆的信息 -Xloggc:…/logs/gc.log ：日志文件的输出路径 GC日志补充说明 “[GC”和”[Full GC”说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World” 使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew” 使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation” 使用Parallel scavenge收集器在新生代的名字是”[PSYoungGen” 老年代的收集和新生代道理一样，名字也是收集器决定的 使用G1收集器的话，会显示为”garbage-first heap” Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。 [ PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K) 中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小） 括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小） user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核线程切换的原因，时间总和可能会超过real时间 垃圾回收器的新发展发展过程 GC仍然处于飞速发展之中，目前的默认选项G1 GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。 即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在serverless等新的应用场景下，Serial Gc找到了新的舞台。 比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除 现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12），其特点：主打低停顿时间 Shenandoash GCOpen JDK12的Shenandoash GC：低停顿时间的GC（实验性） Shenandoah无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。 Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。 Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。 这是RedHat在2016年发表的论文数据，测试内容是使用ES对200GB的维基百科数据进行索引。从结果看： 停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。 而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。 总结 Shenandoah GC的弱项：高运行负担下的吞吐量下降。 Shenandoah GC的强项：低延迟时间。 ZGC ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。 《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。 ZGC的工作过程可以分为4个阶段：并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射 等。 ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。 补充： JDK14之前，ZGC仅Linux才支持。 尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOS上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。 现在mac或Windows上也能使用ZGC了，示例如下： -XX:+UnlockExperimentalVMOptions-XX：+UseZGC "},{"title":"垃圾回收相关概念","date":"2021-11-17T16:00:00.000Z","url":"/2021/11/18/20211118-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/","categories":[["JVM-垃圾回收","/categories/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"]],"content":"System.gc()理解 在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC,同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。 然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(不能确保立即生效) JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc() 手动GC理解不可达对象的回收行为 JVM参数：-Xms256m -Xmx256m -XX:+PrintGCDetails -XX:PretenureSizeThreshold=15m 1、调用 localvarGC1() 方法 执行 System.gc() 仅仅是将年轻代的 buffer 数组对象放到了老年代，buffer对象仍然没有回收 2、调用 localvarGC2() 方法 由于 buffer 数组对象没有引用指向它，执行 System.gc() 将被回收 3、调用 localvarGC3() 方法 虽然出了代码块的作用域，但是 buffer 数组对象并没有被回收 此时局部变量表大小为2，但表中只有一个索引为this。第二个即为buffer在占用。执行 System.gc() 时，栈中还有 buffer 变量指向堆中的字节数组，所以没有进行GC。 4、调用 localvarGC4() 方法 此时局部变量表长度为 2 ，这说明了出了代码块时，buffer 就出了其作用域范围，此时没有为 value 开启新的槽，value 变量直接占据了 buffer 变量的槽（Slot），导致堆中的字节数组没有引用再指向它，执行 System.gc() 时被回收。 5、调用 localvarGC5() 方法 局部变量除了方法范围就是失效了，堆中的字节数组铁定被回收 内存溢出与内存泄露内存溢出 内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。 由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。 大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。 Javadoc中对OutofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。 内存溢出原因分析首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。 原因有二： Java虚拟机的堆内存设置不够。 比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用） 对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。 随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。 这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。 例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。 在java.nio.Bits.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。 当然，也不是在任何情况下垃圾收集器都会被触发的 比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。 内存泄漏 也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。 但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。 尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutofMemory异常，导致程序崩溃。 注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。 左边的图：Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的对象。 右边的图：后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开（图示中的Forgotten Reference Memory Leak），从而导致没有办法被回收。 内存泄漏情景 单例模式 单例的生命周期和应用程序是一样长的，所以在单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。 一些提供close()的资源未关闭导致内存泄漏 数据库连接 dataSourse.getConnection()，网络连接socket和io连接必须手动close，否则是不能被回收的。 Stop The World Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。 可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿，为什么需要停顿所有 Java 执行线程呢？ 分析工作必须在一个能确保一致性的快照中进行 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证 被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。 注意： STW事件和采用哪款GC无关，所有的GC都有这个事件。 哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。 STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。 开发中不要用System.gc() ，这会导致Stop-the-World的发生。 垃圾回收的并行与并发并发：一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行 并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换。 并行：当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，我们称之为并行（Parallel）。 其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行 并发与并行对比 并发，指的是多个事情，在同一时间段内同时发生了。 并行，指的是多个事情，在同一时间点上（或者说同一时刻）同时发生了。 并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。 只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。 垃圾回收中的并发与并行 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。 如ParNew、Parallel Scavenge、Parallel Old 串行（Serial） 相较于并行的概念，单线程执行。 如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收（单线程） 并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下： 并发（Concurrent）：指 用户线程与垃圾收集线程同时执行 （但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。 比如用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上； 典型垃圾回收器：CMS、G1 HotSpot的算法实现细节根节点枚举固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。 2、迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点 枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。现在可达性分析算法耗时 最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还 是必须在一个能保障一致性的快照中才得以进行——这里“一致性”的意思是整个枚举期间执行子系统 看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化 的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有 用户线程的其中一个重要原因，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。 3、由于目前主流Java虚拟机使用的都是准确式垃圾收集，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有 执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot 的解决方案里，是使用一组称为OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也 会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信 息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。 4、Exact VM因它使用准确式内存管理（Exact Memory Management，也可以叫Non-Con- servative/Accurate Memory Management）而得名。准确式内存管理是指虚拟机可以知道内存中某个位 置的数据具体是什么类型。譬如内存中有一个32bit的整数123456，虚拟机将有能力分辨出它到底是一 个指向了123456的内存地址的引用类型还是一个数值为123456的整数，准确分辨出哪些内存是引用类 型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。【这个不是特别重要，了解一下即可】 安全点与安全区域安全点(safepoint) 程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。 Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。 GC发生时，检查所有线程都跑到最近的安全点停顿下来方法 抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。 主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。 安全区域(safe Region) Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？ 例如线程处于Sleep状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。 安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。 执行流程 当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程 当线程即将离开Safe Region时，会检查JVM是否已经完成根节点枚举（即GC Roots的枚举），如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止； 记忆集与卡表跨代引用一般的垃圾回收算法至少会划分出两个年代，年轻代和老年代。但是单纯的分代理论在垃圾回收的时候存在一个巨大的缺陷：为了找到年轻代中的存活对象，却不得不遍历整个老年代，反过来也是一样的。 如果只遍历年轻代，但堆中老年代引用指向年轻代其中一个引用，那么被老年代引用指向的那个引用也会被回收。 为了解决这种跨代引用的问题，最笨的办法就是遍历老年代的对象，找出这些跨代引用来。这种方案存在极大的性能浪费。因为从两个分代假说里面，其实隐含了一个推论：跨代引用是极少的。也就是为了找出那么一点点跨代引用，我们却得遍历整个老年代！ 因此，为了避免这种遍历老年代的性能开销，通常的分代垃圾回收器会引入一种称为记忆集的技术。简单来说，记忆集就是用来记录跨代引用的表。 记忆集与卡表概述 为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建 立了名为记忆集（Remembered Set）的数据结构，用以避免把整个老年代加进GC Roots扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（Partial GC）行为的 垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题，因此我们有必要进一步 理清记忆集的原理和实现方式，以便在后续章节里介绍几款最新的收集器相关知识时能更好地理解。 记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。如果我们不考虑效率和成本的话，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构。 这种记录全部含跨代引用对象的实现方案，无论是空间占用还是维护成本都相当高昂。而在垃圾 收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针 就可以了，并不需要了解这些跨代指针的全部细节。那设计者在实现记忆集的时候，便可以选择更为 粗犷的记录粒度来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范 围以外的）的记录精度： 字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。 其中，第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，这也是 目前最常用的一种记忆集实现形式，一些资料中甚至直接把它和记忆集混为一谈。前面定义中提到记 忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的 具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。 关于卡表与记忆集的关系，读者不妨按照Java语言中HashMap与Map的关系来类比理解。 卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的 引用 在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为： 强引用（Strong Reference） 软引用（Soft Reference） 弱引用（Weak Reference） 虚引用（Phantom Reference） 这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。 Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用 强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁可报OOM，也不会GC强引用 软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。 弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。 虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 强引用 在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。 当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。 只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。只要强引用的对象是可达的，jvm宁可报OOM，也不会回收强引用。 对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。 相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。 总结强引用具备以下特点： 强引用可以直接访问目标对象。 强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。 强引用可能导致内存泄漏。 软引用软引用（Soft Reference）：内存不足即回收 软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。注意，这里的第一次回收是不可达的对象 软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。 垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。 类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。 一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象 在JDK1.2版之后提供了SoftReference类来实现软引用 弱引用 弱引用（Weak Reference）发现即回收 弱引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。 但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。 弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。 软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。 在JDK1.2版之后提供了WeakReference类来实现弱引用 弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。 虚引用虚引用（Phantom Reference）：对象回收跟踪 也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个 一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。 它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null 。即通过虚引用无法获取到我们的数据 为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。 由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。 在JDK1.2版之后提供了PhantomReference类来实现虚引用。 终结器引用 它用于实现对象的finalize() 方法，也可以称为终结器引用 无需手动编码，其内部配合引用队列使用 在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象 "},{"title":"垃圾回收概述和相关算法","date":"2021-11-16T16:00:00.000Z","url":"/2021/11/17/20211117-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0%E5%92%8C%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/","categories":[["JVM-垃圾回收","/categories/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"]],"content":"垃圾回收概述 Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C++语言没有垃圾收集技术，需要程序员手动的收集。 垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。 关于垃圾收集有三个经典问题： 哪些内存需要回收？ 什么时候回收？ 如何回收？ 垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战 垃圾 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。 外文：An object is considered garbage when it can no longer be reached from any pointer in the running program. 如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。 GC的作用 对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。 早期垃圾回收 在早期的C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码： 这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。 有了垃圾回收机制后，上述代码极有可能变成这样 现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。 Java垃圾回收机制自动内存管理优点： 自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险 没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。 自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发 出现的问题： 对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。 此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。 回收区域 垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收， 其中，Java堆是垃圾收集器的工作重点 从次数上讲： 频繁收集Young区 较少收集Old区 基本不收集Perm区（元空间） 垃圾回收相关算法标记阶段标记阶段目的垃圾标记阶段：主要是为了判断对象是否存活 在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。 当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。 判断对象存活一般有两种方式：引用计数算法和可达性分析算法。 引用计数算法 引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。 缺点： 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。 循环引用 当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成内存泄漏 总结 引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。 具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。 Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。 Python如何解决循环引用？ 手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。 可达性分析算法可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。 相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection） 实现思路 所谓”GCRoots”根集合就是一组必须活跃的引用 可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain） 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。 可以是GC Roots的元素 虚拟机栈中引用的对象 比如：各个线程被调用的方法中使用到的参数、局部变量等。 本地方法栈内JNI（通常说的本地方法）引用的对象 方法区中类静态属性引用的对象 比如：Java类的引用类型静态变量 方法区中常量引用的对象 比如：字符串常量池（StringTable）里的引用 所有被同步锁synchronized持有的对象 Java虚拟机内部的引用。 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。 总结 除了堆空间的周边，比如：虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收（PartialGC）。 如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。 由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。 注意： 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。 这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。 对象的finalization机制对象销毁前的回调函数 Java语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。 finalize() 方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。 Object类中finalize()源码 永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点： 在finalize()时可能会导致对象复活。 finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。 一个糟糕的finalize()会严重影响GC的性能。比如finalize是个死循环 从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数。 finalize()方法对应了一个finalize线程，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收 对象状态由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。 如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下： 可触及的：从根节点开始，可以到达这个对象。 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。 以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。 具体过程判定一个对象objA是否可回收，至少要经历两次标记过程： 如果对象objA到GC Roots没有引用链，则进行第一次标记。 进行筛选，判断此对象是否有必要执行finalize()方法 如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。 如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。 finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。 清除阶段垃圾清除阶段 当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是 标记-清除算法（Mark-Sweep） 复制算法（Copying） 标记-压缩算法（Mark-Compact） 标记-清除算法标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。 执行过程当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。 注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收 标记-清除算法的缺点 标记清除算法的效率不算高 在进行GC的时候，需要停止整个应用程序，用户体验较差 这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表 这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。 关于空闲列表是在为对象分配内存的时候提过： 如果内存规整 采用指针碰撞的方式进行内存分配 如果内存不规整 虚拟机需要维护一个空闲列表 采用空闲列表分配内存 复制算法为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。 核心思想将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收 新生代里面就用到了复制算法，Eden区和S0区存活对象整体复制到S1区 复制算法的优缺点优点 没有标记和清除过程，实现简单，运行高效 复制过去以后保证空间的连续性，不会出现“碎片”问题。 缺点 此算法的缺点也是很明显的，就是需要两倍的内存空间。 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小 应用场景 如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，效率较高 老年代大量的对象存活，那么复制的对象将会有很多，效率会很低 在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。 标记-压缩算法标记-压缩（或标记-整理、Mark - Compact）算法 复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。 标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。 1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。 执行过程 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。 标记-压缩算法和标记-清除算法的比较 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。 二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。 可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。 优点 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。 消除了复制算法当中，内存减半的高额代价。 缺点 从效率上来说，标记-整理算法要低于复制算法。 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针） 移动过程中，需要全程暂停用户应用程序。即：STW 垃圾回收算法小结 从效率上讲，复制算法最好，但会浪费太多内存 而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。 标记清除 标记整理 复制 速率 中等 最慢 最快 空间开销 少（但会堆积碎片） 少（不堆积碎片） 通常需要活对象的2倍空间（不堆积碎片） 移动对象 否 是 是 分代收集算法为什么要使用分代收集算法 前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。 分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。 在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关: 比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。 但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。 目前几乎所有的GC都采用分代收集算法执行垃圾回收的 在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。 年轻代（Young Gen） 年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。 这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。 老年代（Tenured Gen） 老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。 这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。 Mark阶段的开销与存活对象的数量成正比。 Sweep阶段的开销与所管理区域的大小成正相关。 Compact阶段的开销与存活对象的数据成正比。 以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。 分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代 增量收集算法和分区算法增量收集算法上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在Stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。 基本思想 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。 总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作 增量收集算法的缺点 使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。 分区算法 一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。 注意：这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。"},{"title":"StringTable(字符串常量池)","date":"2021-11-15T16:00:00.000Z","url":"/2021/11/16/20211116-StringTable(%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)/","categories":[["JVM","/categories/JVM/"]],"content":"String的基本特性 String：字符串，使用一对 “” 引起来表示 String被声明为final的，不可被继承 String：代表不可变的字符序列。简称：不可变性。 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值 String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小 String在jdk8及以前内部定义了final char value[]用于存储字符串数据。JDK9时改为byte[] JDK9改动原因 String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。 从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费。 之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 byte[] 数组 外加一个编码标识存储。该编码表示如果你的字符是ISO-8859-1或者Latin-1，那么只需要一个字节存。如果你是其它字符集，比如UTF-8，你仍然用两个字节存 结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间 同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改 String的底层结构字符串常量池是不会存储相同内容的字符串的 String的String Pool（字符串常量池）是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。 使用-XX:StringTablesize可设置StringTable的长度 在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求 在JDK7中，StringTable的长度默认值是60013，StringTablesize设置没有要求 在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009 String的内存分配 在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。 常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。 直接使用双引号声明出来的String对象会直接存储在常量池中。比如：String info=&quot;atguigu.com&quot;; 如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈 Java 6及以前，字符串常量池存放在永久代 Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内 所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。 字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。 Java8元空间，字符串常量在堆 StringTable为什么要调整 为什么要调整位置？ 永久代的默认空间大小比较小 永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space 堆中空间足够大，字符串可被及时回收 在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。 此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。 String的基本操作Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。 程序启动时已经加载了 2293 个字符串常量，加载了字符串常量 “1”~“10”，之后的字符串”1” 到 “10”不会再次加载 字符串拼接操作 常量与常量的拼接结果在常量池，原理是编译期优化 常量池中不会存在相同内容的变量 拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder 如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为： 如果存在，则返回字符串在常量池中的地址 如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址 字符串拼接的底层细节 字节码指令 从字节码角度来看：为变量 s4 赋值时，直接使用 #16 符号引用，即字符串常量 “ab” 体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！ 原因： StringBuilder的append()的方式： 自始至终中只创建过一个StringBuilder的对象 使用String的字符串拼接方式： 创建过多个StringBuilder和String（调的toString方法）的对象，内存占用更大； 如果进行GC，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。 改进的空间： 在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器实例化： StringBuilder s = new StringBuilder(highLevel); //new char[highLevel] 这样可以避免频繁扩容 intern()的使用说明 intern是一个native方法，调用的是底层C的方法 字符串常量池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。（这是源码里的大概翻译） 如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如： 也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true 通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool） new String()说明new String(ab)会创建几个对象 字节码 0 new #2 &lt;java/lang/String&gt;：在堆中创建了一个 String 对象 4 ldc #3 &lt;ab&gt; ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话） new String(a)+new String(b)会创建几个对象 字节码 字节码指令分析： 0 new #2 &lt;java/lang/StringBuilder&gt; ：拼接字符串会创建一个 StringBuilder 对象 7 new #4 &lt;java/lang/String&gt; ：创建 String 对象，对应于 new String(“a”) 11 ldc #5 &lt;a&gt; ：在字符串常量池中放入 “a”（如果之前字符串常量池中没有 “a” 的话） 19 new #4 &lt;java/lang/String&gt; ：创建 String 对象，对应于 new String(“b”) 23 ldc #8 &lt;b&gt; ：在字符串常量池中放入 “b”（如果之前字符串常量池中没有 “b” 的话） 31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt; ：调用 StringBuilder 的 toString() 方法，会生成一个 String 对象 实例 总结String的intern()使用 JDK6中： 如果字符串常量池有值，则不会放入。返回已有的串池中的对象的地址 如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址 JDK7及以后： 如果字符串常量池有值，则不会放入。返回已有的串池中的对象的地址 如果没有，则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址。 G1中的String去重操作String去重操作的操作背景 注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的 背景：对许多Java应用（有大的也有小的）做的测试得出以下结果： 堆存活数据集合里面String对象占了25% 堆存活数据集合里面重复的String对象有13.5% String对象的平均长度是45 许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：str1.equals(str2)= true。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。 String 去重的的实现 当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。 使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。 如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。 如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。 命令行选项 UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。 PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息 stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象 "},{"title":"对象的实例化内存布局与访问定位","date":"2021-11-10T16:00:00.000Z","url":"/2021/11/11/20211111-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/","categories":[["JVM","/categories/JVM/"]],"content":"对象的实例化 对象的创建方式 new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法 Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且权限必须为 public Constructor的newInstance(Xxxx)：反射的方式，可以调用空参的，或者带参的构造器 使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法 使用序列化：从文件中，从网络中获取一个对象的二进制流，序列化一般用于Socket的网络传输 第三方库 Objenesis 对象创建的步骤 字节码文件为 判断对象对应的类是否加载、链接、初始化 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。 如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。 为对象分配内存 首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小 如果内存规整：采用指针碰撞分配内存 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。 意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。 如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。 标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域 如果内存不规整 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。 意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）” 选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定 标记清除算法清理过后的堆内存，就会存在很多内存碎片。 处理并发问题 采用CAS+失败重试保证更新的原子性 每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制） 在Eden区给每个线程分配一块区域 初始化分配到的空间 所有属性设置默认值，保证对象实例字段在不赋值可以直接使用 给对象属性赋值的顺序： 属性的默认值初始化 显示初始化/代码块初始化（并列关系，谁先谁后看代码编写的顺序） 构造器初始化 设置对象的对象头将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。 执行init方法进行初始化 在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量 因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。 从字节码角度看init方法 字节码文件 init() 方法的字节码指令： 属性的默认值初始化：id = 1001; 显示初始化/代码块初始化：name = &quot;匿名客户&quot;; 构造器初始化：acct = new Account(); 对象的内存布局 内存布局总结 图解内存布局 对象的访问定位JVM通过栈帧中的对象引用访问到其内部的对象实例过程 定位，通过栈上reference访问 对象的两种访问方式：句柄访问和直接指针 句柄访问 缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低 优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改 直接指针(HotSpot采用) 优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据 缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值 "},{"title":"直接内存","date":"2021-11-10T16:00:00.000Z","url":"/2021/11/11/20211111-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/","categories":[["JVM","/categories/JVM/"]],"content":"直接内存 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。 直接内存是在Java堆外的、直接向系统申请的内存区间。 来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存 通常，访问直接内存的速度会优于Java堆。即读写性能高。 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。 Java的NIO库允许Java程序使用直接内存，用于数据缓冲区 BIO与NIO非直接缓存区(BIO)原来采用BIO的架构，在读写本地文件时，需要从用户态切换成内核态 直接缓冲区(NIO)NIO 直接操作物理磁盘，省去了中间过程 使用NIO时，操作系统划出的直接缓存区可以被Java代码直接访问，只有一份。NIO适合对大文件的读写操作 直接内存与OOM 直接内存也可能导致OutofMemoryError异常 由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。 直接内存的缺点为： 分配回收成本较高 不受JVM内存回收管理 直接内存大小可以通过MaxDirectMemorySize设置 如果不指定，默认与堆的最大值-Xmx参数值一致 简单理解： java process memory=java heap+native memory"},{"title":"Java8新特性","date":"2021-11-10T16:00:00.000Z","url":"/2021/11/11/20211111-Java8%E6%96%B0%E7%89%B9%E6%80%A7/","categories":[["JVM","/categories/JVM/"]],"content":"Lambda表达式lambda表达式格式格式一 例如：(o1,o2)-&gt;Integer.compare(o1,o2); -&gt;：lambda操作符或箭头操作符 -&gt;左边：lamdda形参列表(其实就是接口中的抽象方法的形参列表) -&gt;右边：lambda体(其实就是重写的抽象方法的方法体) 格式二Lambda需要一个参数，但是没有返回值 格式三数据类型可以省略，因为可由编译器推断得出，称为”类型判断” 格式四Lambda若只需要一个参数时，参数的小括号可以省略 格式五需要两个或以上的参数，多条执行语句，并且可以有返回值 格式六当Lambda体只有一条语句的时候，return和大括号若有，都可以省略 总结-&gt;左边：Lambda形参列表的参数类型可以省略(类型推断)；如果Lambda形参列表只有一个参数，其一对()也可以省略 -&gt;右边：Lambda体应该使用一对{}包裹：如果Lambda体只有一条执行语句(可能是return语句)，可以省略这一对{}和return关键字 lambda表达式的本质：作为接口的实例 函数式接口如果一个接口中，之声明了一个抽象方法，则此接口就称为函数式接口 可以通过Lambda表达式来创建该接口的对象。(若Lambda表达式抛出一个受检异常(即：非运行时异常)，那么该异常需要在目标接口的抽象方法上进行声明)。 可以在一个接口上使用@FunctionalInterface注解，这样做可以检查他是否是一个函数式接口。同时javadoc也会包含一条声明，说明这个接口是一个函数式接口 在java.util.function包下定义了Java8的丰富的函数式接口 Java内置四大核心函数式接口 函数式接口 参数类型 返回类型 用途 Consumer&lt;T&gt;消费型接口 T void 对类型为T的对象应用操作，包含方法：void accept(T t) Supplier&lt;T&gt;供给型接口 无 T 返回类型为T的对象，包含方法:T get() Function&lt;T,R&gt;函数型接口 T R 对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法:R apply(T t) Predicate&lt;T&gt;断定型接口 T boolean 确定类型为T的对象是否满足某约束，并返回boolean值。包含方法:boolean test(T t) 消费型接口 lambda写法 断定型接口 方法引用方法引用本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以，方法引用也是函数式接口的实例。 当要传递给Lambda体的操作，已经是有实现的方法了，可以使用方法引用 格式：类(或对象) :: 方法名 情况一对象 :: 实例方法 情况二类 :: 静态方法 情况三类 :: 实例方法 构造器引用 数组引用 StreamAPIStreamAPI(java.util.stream)把真正的函数式编程风格引入到java中。这是目前对Java类库最好的补充，因为StreamAPI可以极大提供Java程序员的生产力，写出高效率，干净，简洁的代码。 Stream是Java8处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用StreamAPI对集合数据进行操作，就类似于使用SQL执行的数据库查询。也可以使用StreamAPI来并行执行操作。简言之，StreamAPI提供了一种高效且易于使用的数据处理方式。 使用场景实际开发中，项目多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Redis等，这些NoSQL的数据就需要Java层面去处理。 Stream和Collection集合的区别：Collection是一种静态的内存数据结构，而Stream是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU实现计算。 注意： Stream不会自己储存元素 Stream不会改变源对象，相反，他们会返回一个持有结果的新Stream Stream操作是延迟执行的。这意味着它们会等到需要结果的时候才执行 Stream操作的三个步骤 创建Stream 一个数据源(如：集合、数组)，获取一个流 中间操作 一个中间操作链，对数据源的数据进行处理 终止操作(终端操作) 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用 创建Stream通过集合 通过数组 通过Stream的of() 创建无限流 Stream的中间操作筛选与切片 filterfilter(Predicate p)-接收Lambda，从流中排除某些元素 limitlimit(n)-截断流，使其元素不超过给定数量 skipskip(n)-跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流，与limit(n)互补 distinctdistinct()-筛选，通过流所生成元素的hashCode()和equals()去除重复元素 注意，实体类需要实现hashCode()和equals()方法 映射mapmap(Function f)--接受一个函数作为参考，将元素转换为其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素 flatmapflatMap(Function f)--接受一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 将“aa” “bb” “cc”拆分为 a a b b c c 如果用map来完成 使用flatmap 排序sortedsorted()-自然排序 注意：如果是实体类要实现Comparator接口 sorted(Comparator com)sorted(Comparator com)-定制排序 sorted(Comparator com)sorted(Comparator com)-定制排序 Stream的终止操作终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至void 流进行了终止操作后，不能再次使用 匹配与查找 allMatchallMatch(Predicate p)--检查是否匹配所有元素 anyMatch(Predicate p)anyMatch(Predicate p)--检查是否至少匹配一个元素 noneMatch(Predicate p)noneMatch(Predicate p)--检查是否没有匹配的元素 findFirstfindFirst--返回第一个元素 findAnyfindAny--返回当前流中的任意元素 countcount--返回流中元素的总个数 max(Comparator c)max(Comparator c)--返回流中最大的值 min(Comparator c)min(Comparator c)--返回流中最小值 forEachforEach(Consumer c)--内部迭代 注意：和集合的forEach不同 归约reduce(T identity,BinaryOperator)reduce(T identity,BinaryOperator)--可以将流中元素反复结合起来，得到一个值，返回 T reduce(BinaryOperator) 收集collect(Collector c)collect(Collector c)--将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做总汇的方法 Collector接口中的方法的实现决定了如何对流执行收集的操作(如收集到List、Set、Map) 另外，Collection实用类提供了很多静态方法，可以方便地创建常见收集器实例 Optional类以前，为了解决空指针异常，Google公司引入了Optional类，通过使用检查空值的方式来防止代码污染，鼓励程序员写更干净的代码。 Optional&lt;T&gt;类(java.util.Optional)是一个容器类，他可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用null表示一个值不存在，现在Optional可以更好地表达这个概念。并且可以避免空指针异常。 Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在，则isPresent()方法会返回true，调用get()方法会返回该对象。 创建Optional类对象的方法Optional.of(T t):创建一个Optional实例，t必须为非空； Optional.empty():创建一个空的Optional实例 Optional.ofNullable(T t):t可以为null 判断Optional容器中是否包含对象boolean isPresent():判断是否包含对象 void ifPresent(Consumer&lt;? super T&gt; consumer):如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。 获取Optional容器的对象T get():如果调用对象包含值，返回该值，否则抛异常 T orElse(T other):如果有值则将其返回，否则返回指定的other对象 T orElseGet(Supplier&lt;? extends T&gt; other):如果有值则将其返回，否则返回由Supplier接口实现提供的对象 T orElse Throw(Supplier&lt;? extends X&gt; exceptionSupplier):如果有之则将其返回，否则抛出由Supplier接口实现提供的异常。"},{"title":"执行引擎","date":"2021-11-10T16:00:00.000Z","url":"/2021/11/11/20211111-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/","categories":[["JVM","/categories/JVM/"]],"content":"概述 执行引擎是Java虚拟机核心的组成部分之一。 “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。 JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。 那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。 前端编译：从Java程序-字节码文件的这个过程叫前端编译 执行引擎这里有两种行为：一种是解释执行，一种是编译执行（这里的是后端编译）。 执行引擎工作过程 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。 从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行、即时编译的等效过程，输出的是执行过程。 Java代码编译和执行过程解释执行和即时编译大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤： 前面橙色部分是编译生成生成字节码文件的过程（javac编译器来完成，也就是前端编译器），和JVM没有关系。 后面绿色（解释执行）和蓝色（即时编译）才是JVM需要考虑的过程 javac编译器(前端编译器)流程： 源代码→词法分析器→Token流→语法分析器→语法树/抽象语法树→语义分析器→注解抽象语法树→字节码生成器→JVM字节码 Java字节码的执行是由JVM执行引擎来完成，流程为： JVM字节码→JIT编译器、JVM字节码→字节码解释器 JIT编译器中流程为： 机器无关优化→中间代码→机器相关优化→中间代码→寄存器分配器→中间代码→目标代码生成器→目标代码 解释器、JIT编译器 解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。 JIT（Just In Time Compiler）编译器：就是虚拟机将源代码一次性直接编译成和本地机器平台相关的机器语言，但并不是马上执行。 java是半编译半解释型语言 JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。 现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。 JIT编译器将字节码翻译成本地代码后，就可以做一个缓存操作，存储在方法区的JIT 代码缓存中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化。 机器码&amp;指令&amp;汇编语言机器码 各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。 机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。 用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。 机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。 指令和指令集指令 由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。 指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好 由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。 指令集不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。如常见的 x86指令集，对应的是x86架构的平台 ARM指令集，对应的是ARM架构的平台 汇编语言 由于指令的可读性还是太差，于是人们又发明了汇编语言。 在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。 在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。 由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译（汇编）成机器指令码，计算机才能识别和执行。 高级语言 为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言 当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。 字节码 字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码 字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。 字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。 字节码典型的应用为：Java bytecode 解释器 JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式由高级语言直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法（也就是产生了一个中间产品字节码）。 解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。 当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。 解释器的分类 在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。 字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。 而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。 在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。 Interpreter模块：实现了解释器的核心功能 Code模块：用于管理HotSpot VM在运行时生成的本地机器指令 现状 由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃。 为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。 不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。 JIT编译器Java代码执行的分类 第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行 第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行 HotSpot VM是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。 在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C/C++ 程序一较高下的地步。 解释器在JVM的作用既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。 JRockit虚拟机的确没有解释器，因为他只部署在服务器上，一般已经有时间让他进行指令编译的过程，对于相应来说要求不高，等即时编译器的编译完成后，就会提供更好的性能。 首先明确两点： 当程序启动后，解释器可以马上发挥作用，响应速度快，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间，但编译为本地代码后，执行效率高。 所以： 尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。 在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。 同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。 当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。 注意解释执行与编译执行在线上环境微妙的辩证关系。机器在热机状态（已经运行了一段时间叫热机状态）可以承受的负载要大于冷机状态（刚启动的时候叫冷机状态）。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。 在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—阿里团队 JIT编译器相关概念 Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。 也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。 还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势） 典型的编译器： 前端编译器：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。 JIT编译器：HotSpot VM的C1、C2编译器。 AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。 热点代码及探测方式 是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，需要根据代码被调用执行的频率而定。 关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。 一个被多次调用的方法，或者是一-个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement)编译。 一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。 目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。 采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。 方法调用计数器用于统计方法的调用次数 回边计数器则用于统计循环体执行的循环次数 方法调用计数器 这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。 这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。 当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本 如果存在，则优先使用编译后的本地代码来执行 如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。 如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。 如果未超过阈值，则使用解释器对字节码文件解释执行 热度衰减 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄） 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。 另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。 回边计数器它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。 HotSpotVM设置程序执行方法缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示： -Xint：完全采用解释器模式执行程序； -Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行 -Xmixed：采用解释器+即时编译器的混合模式共同执行程序。 HotSpot JIT分类在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示： -client：指定Java虚拟机运行在Client模式下，并使用C1编译器； C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。 -server：指定Java虚拟机运行在server模式下，并使用C2编译器。 C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++） C1和C2编译器不同的优化策略 在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程 去虚拟化：对唯一的实现方法进行内联 冗余消除：在运行期间把一些不会执行的代码折叠掉 C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化： 标量替换：用标量值代替聚合对象的属性值 栈上分配：对于未逃逸的对象分配对象在栈而不是堆 同步消除：清除同步操作，通常指synchronized 分层编译策略 分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。 不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。 一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高 C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器 Graal 编译器 自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器 编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的） 目前，带着实验状态标签，需要使用开关参数去激活才能使用 -XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler AOT编译器 jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler） Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。 所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。 .java -&gt; .class -&gt; (使用jaotc) -&gt; .so AOT编译器编译器的优缺点 最大的好处： Java虚拟机加载已经预编译成二进制库，可以直接执行。 不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验 缺点： 破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包 降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。 还需要继续优化中，最初只支持Linux X64 java base "},{"title":"JVM常见面试题","date":"2021-11-09T16:00:00.000Z","url":"/2021/11/10/20211110-JVM%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","categories":[["JVM","/categories/JVM/"]],"content":"JVM面试题 百度 三面：说一下JVM内存模型吧，有哪些区？分别干什么的？ 蚂蚁金服： Java8的内存分代改进 JVM内存分哪几个区，每个区的作用是什么？ 一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？ 二面：Eden和survior的比例分配 小米： jvm内存分区，为什么要有新生代和老年代 字节跳动： 二面：Java的内存分区 二面：讲讲vm运行时数据库区 什么时候对象会进入老年代？ 京东： JVM的内存结构，Eden和Survivor比例。 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。 天猫： 一面：Jvm内存模型以及分区，需要详细到每个区放什么。 一面：JVM的内存模型，Java8做了什么改 拼多多： JVM内存分哪几个区，每个区的作用是什么？ 美团： java内存分配 jvm的永久代中会发生垃圾回收吗？ 一面：jvm内存分区，为什么要有新生代和老年代？ "},{"title":"方法区","date":"2021-11-09T16:00:00.000Z","url":"/2021/11/10/20211110-%E6%96%B9%E6%B3%95%E5%8C%BA/","categories":[["JVM","/categories/JVM/"]],"content":"栈、堆、方法区的交互关系从线程共享与否的角度来看 ThreadLocal：保证多个线程在并发环境下的安全性 对象的访问定位 Person 类的 .class 信息存放在方法区中 person 变量存放在 Java 栈的局部变量表中 真正的 person 对象存放在 Java 堆中 在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的 方法区的理解方法区的位置 《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。 所以，方法区可以看作是一块独立于Java堆的内存空间。 基本理解方法区中主要存放的是Class，而对中主要存放的是实例化的对象 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次。 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误： java.lang.OutofMemoryError:PermGen space 或者 加载大量的第三方的jar包 Tomcat部署的工程过多（30~50个） 大量动态的生成反射类 关闭JVM就会释放这个区域的内存。 HotSpot方法区演进 在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类 本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit / IBM J9 中不存在永久代的概念。 现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOm（超过-XX:MaxPermsize上限） 而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存。 永久代、元空间二者并不只是名字变了，内部结构也调整了 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常 设置方法区大小与OOM方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。 Java7及以前(永久代) 通过-XX:Permsize来设置永久代初始分配空间。默认值是20.75M -XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M 当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。 Java8及以后(元空间) 元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 指定 默认值依赖于平台，Windows下，-XX:MetaspaceSize 约为21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace -XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。 方法区OOMOOMTest 类继承 ClassLoader 类，获得 defineClass() 方法，可自己进行类的加载 不设置元空间的上限 使用默认的 JVM 参数，元空间不设置上限 输出结果： 设置元空间的上限 JVM 参数 -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m 输出结果： 如何解决OOM 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow） 内存泄漏就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。 方法区的内部结构 《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。 信息类型对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息： 这个类型的完整有效名称（全名=包名.类名） 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类） 这个类型的修饰符（public，abstract，final的某个子集） 这个类型直接接口的一个有序列表 域(Field)信息 即为成员变量 JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。 域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集） 方法(Method)信息JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序： 方法名称 方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class 方法参数的数量和类型（按顺序） 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集） 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外） 异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引 non-final类型的类变量 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分 类变量被类的所有实例共享，即使没有类实例时，你也可以访问它 如下代码所示，即使我们把order设置为null，也不会出现空指针异常 这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例 结果 static final 全局常量就是使用 static final 进行修饰 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。 运行时常量池 方法区，内部包含了运行时常量池 字节码文件，内部包含了常量池。（之前的字节码文件中已经看到了很多Constant pool的东西，这个就是常量池） 要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。 要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。 常量池 一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外。还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。 字面量： 10 ， “我是某某”这种数字和字符串都是字面量 为什么需要常量池一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池 虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。 比如这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。可以将”hello”等所需用到的结构信息记录在常量池中，并通过引用的方式，来加载、调用所需的结构 如果代码多的话，引用的结构将会更多，这里就需要用到常量池。 常量池中内容 数量值 字符串值 类引用 字段引用 方法引用 总结常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。 运行时常量池 运行时常量池（Runtime Constant Pool）是方法区的一部分。 常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。（运行时常量池就是常量池在程序运行时的称呼） 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。 JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。 运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。 运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。 方法区使用举例 字节码 字节码指令执行流程 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 符号引用→直接引用 上面代码调用 System.out.println() 方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载 如果没有加载，则执行加载，执行时，将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值） 方法区演进细节永久代演进过程 首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一 Hotspot中方法区的变化： JDK1.6及以前 有永久代（permanent generation），静态变量存储在永久代上 JDK1.7 有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中 JDK1.8 无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。 JDK6：方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存） JDK7：方法区由永久代实现，使用 JVM 虚拟机内存 JDK8：方法区由元空间实现，使用物理机本地内存 永久代为什么会被替换 随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。 这项改动是很有必要的，原因有： 为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。 对永久代进行调优是很困难的。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低 Full GC 有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻**。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。 字符串常量池字符串常量池 StringTable 为什么要调整位置？ JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。 这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。 方法区的垃圾回收 有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。 先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。 回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收） 下面也称作类卸载 1、判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件： 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 2、Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息 3、在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。 运行时数据区总结"},{"title":"堆","date":"2021-11-07T16:00:00.000Z","url":"/2021/11/08/2021118-%E5%A0%86/","categories":[["JVM","/categories/JVM/"]],"content":"核心概述堆与进程 堆针对一个JVM进程来说是唯一的。也就是一个进程只有一个JVM实例，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和一个方法区。 但是进程包含多个线程，他们是共享同一堆空间的。 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。 Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，并且堆内存的大小是可以调节的。 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。 《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated） 从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换） 数组和对象可能永远不会存储在栈上（不一定），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。 也就是触发了GC的时候，才会进行回收 如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。 堆内存细分现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为： Java7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区 Young Generation Space 新生区 Young/New 又被划分为Eden区和Survivor区 Old generation space 养老区 Old/Tenure Permanent Space 永久区 Perm Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间 Young Generation Space 新生区，又被划分为Eden区和Survivor区 Old generation space 养老区 Meta Space 元空间 Meta 约定：新生区 &lt;–&gt; 新生代 &lt;–&gt; 年轻代 、 养老区 &lt;–&gt; 老年区 &lt;–&gt; 老年代、 永久区 &lt;–&gt; 永久代 Java7 Java8 堆空间内部结构，JDK1.8之前从永久代 替换成 元空间 JVisualVM可视化查看堆内存找到jdk的bin目录下的JVisualVM.exe文件并打开，点击工具 -&gt; 插件 -&gt; 安装Visual GC插件。运行代码即可 设置堆内存大小与OOM设置堆内存 Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xms”和”-Xmx”来进行设置。 -Xms用于表示堆区的起始内存，等价于**-XX:InitialHeapSize** -Xmx则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize** 一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。 通常会将-Xms和-Xmx两个参数配置相同的值 原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。 如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM 默认情况下: 初始内存大小：物理电脑内存大小/64 最大内存大小：物理电脑内存大小/4 电脑内存大小为8G，不足8G的原因是操作系统自身还占据了一些。 设置参数 使用 jps / jstat -gc 进程id jps：查看java进程 jstat：查看某进程内存使用情况 1、 25600+25600+153600+409600 = 614400K 614400 /1024 = 600M 2、 25600+153600+409600 = 588800K 588800 /1024 = 575M 3、 并非巧合，S0区和S1区两个只有一个能使用，另一个用不了 OOM 设置虚拟机参数: -Xms600m -Xmx600m 输出结果： 原因：大对象导致堆内存溢出 年轻代与老年代存储在JVM中的Java对象可以被划分为两类： 2、Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen） 3、其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区） 配置新生代与老年代在堆结构的占比 默认**-XX:NewRatio**=2，表示新生代占1，老年代占2，新生代占整个堆的1/3 可以修改**-XX:NewRatio**=4，表示新生代占1，老年代占4，新生代占整个堆的1/5 在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1， 当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如-XX:SurvivorRatio=8 几乎所有的Java对象都是在Eden区被new出来的。 绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。 可以使用选项”-Xmn”设置新生代最大内存大小，但这个参数一般使用默认值就可以了。 对象分配过程为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。 具体过程 new的对象先放伊甸园区。此区有大小限制。 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。 然后将伊甸园中的剩余对象移动到s0(Survivor From)区。同时给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。 如果再次触发垃圾回收，此时GC将会把 Eden和Survivor From中的对象进行一次垃圾收集，把存活的对象放到 Survivor To（S1）区，同时让存活的对象年龄 + 1 下一次再进行GC的时候， 1、这一次的s0区为空，所以成为下一次GC的S1区 2、这一次的s1区则成为下一次GC的S0区 3、也就是说s0区和s1区在互相转换。 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。 当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作，也就是将年轻代中的对象晋升到老年代中。可以设置次数。默认是15次。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：**-XX:MaxTenuringThreshold**=N 进行设置 在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理 若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。 特殊情况说明对象分配的特殊情况 如果来了一个新对象，先看看 Eden 是否放的下？ 如果 Eden 放得下，则直接放到 Eden 区 如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？ 将对象放到老年区又有两种情况： 如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代 那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM 如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区 常用调优工具 JDK命令行 Eclipse：Memory Analyzer Tool Jconsole Visual VM（实时监控，推荐） Jprofiler（IDEA插件） Java Flight Recorder（实时监控） GCViewer GCEasy GC分类 JVM调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上 JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC） 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为： 新生代收集（Minor GC/Young GC）：只是新生代（Eden，s0，s1）的垃圾收集 老年代收集（Major GC/Old GC）：只是老年代的圾收集。 目前，只有CMS GC会有单独收集老年代的行为。 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为 整堆收集（Full GC）：收集整个java堆和方法区的垃圾收集。 YoungGC年轻代GC(Minor GC)触发机制 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满。Survivor满不会主动引发GC，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存） 因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。 Minor GC会引发STW（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 分代式GC策略执行条件： Major/Full GC老年代GC(MajorGC)触发机制 指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了 出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程） 也就是在老年代空间不足时，会先尝试触发Minor GC（哈？我有点迷？），如果之后空间还不足，则触发Major GC Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。 如果Major GC后，内存还不足，就报OOM了 Full GC触发机制触发Full GC执行的情况有如下五种： 调用System.gc()时，系统建议执行FullGC，但是不必然执行 老年代空间不足 方法区空间不足 通过Minor GC后进入老年代的平均大小大于老年代的可用内存 由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小 说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些 堆空间分代思想经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。 新生代：有Eden、两块大小相同的survivor（又称为from/to或s0/s1）构成，to总为空。 老年代：存放新生代中经历多次GC仍然存活的对象。 其实不分代完全可以，分代的唯一理由就是优化GC性能。 如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。（性能低） 而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多） 对象内存分配策略 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。 对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代 对象晋升老年代的年龄阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置 针对不同年龄段的对象分配原则如下所示： 优先分配到Eden：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢 大对象直接分配到老年代：尽量避免程序中出现过多的大对象 长期存活的对象分配到老年代 动态对象年龄判断：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 空间分配担保： -XX:HandlePromotionFailure 。 TLAB为对象分配内存(保证线程安全)TLAB（Thread Local Allocation Buffer） 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。 据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。 为什么需要TLAB 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。 1、每个线程都有一个TLAB空间 2、当一个线程的TLAB存满时，可以使用公共区域（蓝色）的 TLAB说明 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。 在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“**-XX:TLABWasteTargetPercent**”设置TLAB空间所占用Eden空间的百分比大小。 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。 1、哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定 —-这是《深入理解JVM》–第三版里说的 2、和这里讲的有点不同。我猜测说的意思是某一次分配，如果TLAB用完了，那么这一次先在Eden区直接分配。空闲下来后再加锁分配新的TLAB（TLAB内存较大，分配时间应该较长） TLAB分配过程 堆空间参数设置常用参数设置 空间分配担保在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。 如果大于，则此次Minor GC是安全的 如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。 如果HandlePromotionFailure=true，那么会继续检查 老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小 。 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的； 如果小于，则进行一次Full GC。 如果HandlePromotionFailure=false，则进行一次Full GC。 历史版本 在JDK6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。 JDK6 Update 24(Java7)之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。即 HandlePromotionFailure=true 堆是否为分配对象的唯一选择？在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述： 随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。 此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。 逃逸分析 如何将堆上的对象分配到栈，需要使用逃逸分析手段。 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。 逃逸分析的基本行为就是分析对象动态作用域： 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。 逃逸分析举例 1、没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC） 2、下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配 3、如果想要StringBuffer sb不发生逃逸，可以这样写 逃逸分析参数设置 在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析 如果使用的是较早的版本，开发人员则可以通过： 选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析 通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果 总结 开发中能使用局部变量的，就不要使用在方法外定义。 代码优化使用逃逸分析，编译器可以对代码做如下优化： 栈上分配：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配 同步省略：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。 分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。 栈上分配 JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。 常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。 栈上分配举例 输出结果： 1、JVM 参数设置 -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails 2、日志打印：发生了 GC ，耗时 114ms 开启逃逸分析的情况 输出结果： 1、参数设置 -Xmx128m -Xms128m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails 2、日志打印：并没有发生 GC ，耗时5ms 。 同步省略(同步消除) 线程同步的代价是相当高的，同步的后果是降低并发性和性能。 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。 如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。 例如下面的代码 代码中对hollis这个对象加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成： 字节码分析 注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，同步省略操作是在解释运行时发生的 标量替换分离对象或标量替换 标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。 相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。 标量替换举例 代码 以上代码，经过标量替换后，就会变成 可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。 那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。 标量替换为栈上分配提供了很好的基础。 标量替换参数设置 参数 -XX:+ElimilnateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上。 代码示例 未开启标量替换 1、JVM 参数 -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations 2、日志 开启标量替换 1、JVM 参数 -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations 2、日志：时间减少很多，且无GC 上述代码在主函数中调用了1亿次alloc()方法，进行对象创建由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码： 这里设置参数如下： 参数 -server：启动Server模式，因为在server模式下，才可以启用逃逸分析。 参数 -XX:+DoEscapeAnalysis：启用逃逸分析 参数 -Xmx10m：指定了堆空间最大为10MB 参数 -XX:+PrintGC：将打印GC日志。 参数 -XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配 逃逸分析的不足 关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。 其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。 虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。 注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle Hotspot JVM中并未这么做（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上。 目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。 堆是分配对象的唯一选择么？ 综上：对象实例都是分配在堆上。What the fuck？ 总结 年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。 老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。 当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上； 如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上； 如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。 当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。 当GC发生在老年代时则被称为Major GC或者Full GC。 一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。 "},{"title":"虚拟机栈","date":"2021-11-06T16:00:00.000Z","url":"/2021/11/07/2021117-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/","categories":[["JVM","/categories/JVM/"]],"content":"虚拟机栈 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。 优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。 内存中的栈与堆首先栈是运行时的单位，而堆是存储的单位。即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里 虚拟机栈基本内容Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用，栈是线程私有的 虚拟机栈的生命周期 生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了 虚拟机栈的作用 主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。 局部变量，它是相比于成员变量来说的（或属性） 基本数据类型变量 VS 引用类型变量（类、数组、接口） 虚拟机栈的特点 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。 JVM直接对Java栈的操作只有两个： 每个方法执行，伴随着进栈（入栈、压栈） 执行结束后的出栈工作 对于栈来说不存在垃圾回收问题 栈不需要GC，但是可能存在OOM 虚拟机栈的异常 Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackoverflowError 异常。 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutofMemoryError 异常。 设置栈内存的大小可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 栈的存储单位 每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在 在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。 栈运行原理 JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循先进后出（后进先出）原则 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为当前栈帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current Method），定义这个方法的类就是当前类（Current Class） 执行引擎运行的所有字节码指令只针对当前栈帧进行操作。 如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。 Java方法有两种返回函数的方式。 一种是正常的函数返回，使用return指令。 另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。 但不管使用哪种方式，都会导致栈帧被弹出。 栈帧的内部结构每个栈帧中存储着： 局部变量表（Local Variables） 操作数栈（Operand Stack）（或表达式栈） 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用） 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义） 一些附加信息 并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的 局部变量表 局部变量表也被称之为局部变量数组或本地变量表 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。 对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。 进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。 局部变量表中的变量只在当前方法调用中有效。 在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。 当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。 Slot 参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。 局部变量表，最基本的存储单元是Slot（变量槽），局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。 在局部变量表里， 32位以内的类型只占用一个slot （包括returnAddress类型）， 64位的类型占用两个slot （1ong和double）。 byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true long和double则占据两个slot JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量） 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。（this也相当于一个变量） slot的重复利用栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。 静态变量与局部变量的对比 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。 我们知道成员变量有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。 注意： 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。 操作数栈 每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为表达式栈（Expression Stack） 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop） 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈， 比如：执行复制、交换、求和等操作 作用 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为maxstack的值。 栈中的任何一个元素可以是任意的Java数据类型 32bit的类型占用一个栈单位深度 64bit的类型占用两个栈单位深度 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。只不过操作数栈是用数组这个结构来实现的而已 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。 另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。 示例 1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。 2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了（局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this） 3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中 4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作 iload_1：取出局部变量表中索引为1的数据入操作数栈 5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置 注意： 因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8 但是存储在局部变量的时候，会转成 int 类型的变量：istore_4 m改成800之后，byte存储不了，就成了short型，sipush 800 栈顶缓存技术栈顶缓存技术：Top Of Stack Cashing 基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读/写次数多，效率不高。 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。 寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多 动态链接动态链接（或指向运行时常量池的方法引用） 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking），比如：invokedynamic指令 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用 使用常量池优点 因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。 常量池的作用：就是为了提供一些符号和常量，便于指令的识别 方法的调用静态链接与动态连接在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关 静态链接： 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接 动态链接： 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。 早期绑定与晚期绑定静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。 静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。 早期绑定： 早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。 晚期绑定： 如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 多态与绑定 随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。 Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。 虚方法与非虚方法虚方法与非虚方法的区别 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。 其他方法称为虚方法。 子类对象的多态的使用前提： 类的继承关系 方法的重写 虚拟机中调用方法的指令 普通指令： invokestatic：调用静态方法，解析阶段确定唯一方法版本 invokespecial：调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本 invokevirtual：调用所有虚方法 invokeinterface：调用接口方法 动态调用指令 invokedynamic：动态解析出需要调用的方法，然后执行 前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。 关于invokedynamic指令 JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。 但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。 Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。 动态语言和静态语言 动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。 说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。 Java：String info = “mogu blog”; (Java是静态类型语言的，会先编译就进行类型检查) JS：var name = “shkstart”; var name = 10; （运行时才进行检查） Java语言中重写的本质 找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。 如果在类型C中找到与常量中的描述符合，名称都相符的方法，则进行访问权限校验。 如果通过则返回这个方法的直接引用，查找过程结束 如果不通过，则返回java.lang.IllegalAccessError 异常 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。 上面的过程称为动态分派 IllegalAccessError介绍 程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。 比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突 虚方法表 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，可以看到如果子类找不到，还要从下往上找其父类，非常耗时】 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。 虚方法表什么时候被创建？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。 可以理解为： 如果son类在调用toString时，son没重写过，son的父类Father也没重写过，那就直接调用Object类的toString。直接在虚方法表里指明toString直接指向Object类。下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程 方法返回地址 方法返回地址、动态链接、一些附加信息 也叫做帧数据区 存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式： 正常执行完成 出现未处理的异常，非正常退出 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。 本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。 方法退出的两种方式 当一个方法开始执行后，只有两种方式可以退出这个方法， 正常退出： 执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口； 一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。 在字节码指令中，返回指令包含： ireturn：当返回值是boolean，byte，char，short和int类型时使用 lreturn：Long类型 freturn：Float类型 dreturn：Double类型 areturn：引用类型 return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法 异常退出： 在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口。 方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码 异常处理表： 反编译字节码文件，可得到 Exception table from ：字节码指令起始地址 to ：字节码指令结束地址 target ：出现异常跳转至地址为 11 的指令执行 type ：捕获异常的类型 一些附加信息栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。 栈的相关问题栈溢出的情况？SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM 调整栈的大小，能保证不出现溢出么不能保证不溢出，只能保证SOF出现的几率小 分配的栈内存越大越好吗不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的 垃圾回收是否涉及到虚拟机栈不会 位置 是否有Error 是否存在GC PC计数器 无 不存在 虚拟机栈 有，SOF 不存在 本地方法栈(在HotSpot的实现中和虚拟机栈一样) 堆 有，OOM 存在 方法区 有 存在 方法中定义的局部变量是否线程安全具体问题具体分析 如果只有一个线程才可以操作此数据，则必是线程安全的。 如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。 具体问题具体分析： 如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。 "},{"title":"类加载子系统","date":"2021-11-05T16:00:00.000Z","url":"/2021/11/06/2021116-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/","categories":[["JVM","/categories/JVM/"]],"content":"内存结构概述简图 完整图 注意：方法区只有HotSpot虚拟机有，J9，JRockit都没有 类加载器子系统类加载器子系统作用： 类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。 ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射） 类加载器ClassLoader字节码文件(xxx.class)存在于本地硬盘上，在执行的时候需要加载到JVM中，根据这个文件实例化出n个一模一样的实例。当字节码文件加载到JVM中，被称为DNA元数据模板，放在方法区中。在字节码文件通过JVM来成为元数据模板的时候，需要一个运输工具，也就是类装载器ClassLoader 类加载过程如下代码 首先，执行main()方法(静态方法)就需要先加载main()方法所在类HelloLoader，加载成功，则进行链接、初始化等操作。完成后调用HelloLoader类中的静态方法main。加载失败则抛出异常 加载阶段加载： 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 加载class文件的方式： 从本地系统中直接加载 通过网络获取，典型场景：Web Applet 从zip压缩包中读取，成为日后jar、war格式的基础 运行时计算生成，使用最多的是：动态代理技术 由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见 从加密文件中获取，典型的防Class文件被反编译的保护措施 链接阶段链接分为三个子阶段： 验证(Verrification) 准备(Preparation) 解析(Resolution) 验证 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 例如，使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现了不合法的字节码文件，那么将会验证不通过 准备 为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值 这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化 注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中 解析 将常量池内的符号引用转换为直接引用的过程 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等 初始化阶段类的初始化时机 创建类的实例 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（比如：Class.forName(“com.atguigu.Test”)） 初始化一个类的子类 Java虚拟机启动时被标明为启动类的类 JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化 除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法） Clinit() 初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程 此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法 &lt;clinit&gt;()方法中的指令按语句在源文件中出现的顺序执行 &lt;clinit&gt;()不同于类的构造器。（关联：构造器是虚拟机视角下的&lt;init&gt;()） 若该类具有父类，JVM会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕 虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁 注：当我们代码中包含static变量的时候，就会有clinit方法 类加载器的分类概述 JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader） 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个 当尝试获取引导类加载器，获取到的值为 null时 ，并不代表引导类加载器不存在，因为引导类加载器用 C/C++ 语言，我们获取不到 系统类加载器是全局唯一的 虚拟机自带的加载器启动类加载器 这个类加载使用C/C++语言实现的，嵌套在JVM内部 它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类 并不继承自java.lang.ClassLoader，没有父加载器 加载扩展类和应用程序类加载器，并作为他们的父类加载器 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 扩展类加载器 Java语言编写，由sun.misc.Launcher$ExtClassLoader实现 派生于ClassLoader类 父类加载器为启动类加载器 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载 系统类加载器也称为应用程序类加载器 Java语言编写，由sun.misc.LaunchersAppClassLoader实现 派生于ClassLoader类 父类加载器为扩展类加载器 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载 通过classLoader.getSystemclassLoader()方法可以获取到该类加载器 用户自定义类加载器应用场景 隔离加载类（假设现在Spring框架，和RabbittMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间件之间是隔离的） 修改类加载的方式 扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方） 防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密） 自定义类加载器 开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。 ClassLoader介绍ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器） 方法名称 描述 getParent() 返回该类加载器的超类加载器 loadClass(String name) 加载名称为name的类，返回结果为java.lang.Class类的实例 findClass(String name) 查找名称为name的类，返回结果为java.lang.Class类的实例 findLoadedClass(String name) 查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例 defineClass(String name,byte[] b,int off,int len) 把字节数组b中的内容转换为一个Java类，返回结果为Java.lang.Class类的实例 resolveClass(Class&lt;?&gt; c) 连接指定的一个Java类 获取ClassLoader途径方式一：获取当前类的ClassLoader clazz.getClassLoader() 方式二：获取当前线程上下文的ClassLoader Thread.currentThread().getContextClassLoader() 方式三：获取系统的ClassLoadeer ClassLoader.getSystemClassLoader() 方式四：获取调用者的ClassLoader DriverManager.getCallerClassLoader() 双亲委派机制Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行； 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器； 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常 优势 避免类的重复加载 保护程序安全，防止核心API被随意篡改 自定义类：自定义java.lang.String 没有被加载。 自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类） 沙箱安全机制 自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。 这样可以保证对java核心源代码的保护，这就是沙箱安全机制。 判断两个class对象是否相同在JVM中表示两个class对象是否为同一个类存在两个必要条件： 类的完整类名必须一致，包括包名 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同 换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的 对类加载器的引用 JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的 如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中 当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的 "},{"title":"运行时数据区","date":"2021-11-05T16:00:00.000Z","url":"/2021/11/06/2021116-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/","categories":[["JVM","/categories/JVM/"]],"content":"运行时数据区 通过：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区 运行时数据区结构运行时数据区与内存 内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。 通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁 线程的内存空间 Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。 白色的为单独线程私有的，蓝色的为多个线程共享的。即： 线程独有：独立包括程序计数器、栈、本地方法栈 线程间共享：堆、堆外内存（永久代或元空间、代码缓存） Runtime类每个JVM只有一个Runtime实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。 线程JVM线程 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收 操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法 JVM系统线程 如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用public static void main(String[])的main线程以及所有这个main线程自己创建的线程。 这些主要的后台系统线程在Hotspot JVM里主要是以下几个： 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销 周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行 GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持 编译线程：这种线程在运行时会将字节码编译成到本地代码 信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理 程序计数器(PC寄存器) JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。 这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 它是唯一一个在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域 作用PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。 使用PC寄存器存储字节码指令地址有什么用？ 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行 JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令 PC寄存器为什么被设定为私有的？ 多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，不能保证准确性。为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。 CPU时间片 CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。 在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。 但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。 本地方法接口 简单地讲，一个Native Method是一个Java调用非Java代码的接囗一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。 “A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现） 在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。 本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。 为什么使用Native MethodJava使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，使用Native Method可以解决问题。 与Java环境外交互有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因。 与操作系统的交互 JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。 然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。 通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。 还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。 Sun’s Java Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。 例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。 现状目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等 本地方法栈 Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。 本地方法栈，也是线程私有的。 允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同） 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。 本地方法一般是使用C语言或C++语言实现的。 它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。 注意事项 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区 它甚至可以直接使用本地处理器中的寄存器 直接从本地内存的堆中分配任意数量的内存 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。 在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。 "},{"title":"Java虚拟机体系结构","date":"2021-11-03T16:00:00.000Z","url":"/2021/11/04/2021114-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","categories":[["JVM","/categories/JVM/"]],"content":"虚拟机虚拟机概念所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机 Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机硬件的仿真(模拟)，提供了一个可运行完整操作系统的软件平台 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令 无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。 Java虚拟机Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。 JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。 Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部 作用Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里 特点 一次编译，到处运行 自动内存管理 自动垃圾回收 位置JVM是运行在操作系统之上的，它与硬件没有直接的交互 由内到外为：硬件→操作系统→JVM→字节码文件→用户 JVM整体结构简图 完整图 HotSpot VM是目前市面上高性能虚拟机的代表作之一 它采用解释器与即时编译器并存的架构 Java代码执行流程首先Java源码(xxx.java文件)会通过Java编译器生成字节码文件(xxx.class文件)。 Java编译器的处理过程为：词法分析→语法分析→语法/抽象语法树→语义分析→注解抽象语法树→字节码生成器 字节码文件经过JVM处理后交给操作系统处理，处理过程为： 类加载器→字节码校验器→翻译字节码(解析执行)&amp;JIT编译器(编译执行) JVM的架构模型Java编译器输入的指令流基本上是一种基于栈的指令集架构，另外一种指令集架构则是基于寄存器的指令集架构 栈的指令集架构特点 设计和实现更简单，适用于资源受限的系统 避开了寄存器的分配难题：使用0地址指令方式分配 指令流中的指令大部分都是0地址指令，其执行过程依赖于操作栈。指令集更小，编译器更容易实现 不需要硬件支持，可移植性更好，更好实现跨平台 寄存器的指令集架构特点 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机 完全依赖硬件，与硬件的耦合度高，可移植性差 性能优秀和执行更高效 花费更少的指令去完成一项操作 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主 例如： 执行2+3逻辑操作，其指令分别如下： 基于栈的计算流程(以Java虚拟机为例)： 共8个指令 基于寄存器的计算流程： 2个指令 总结由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。栈的优点：跨平台，指令集小，编译器容易实现，缺点是性能比寄存器差一些。 JVM的生命周期虚拟机的启动Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。 虚拟机的执行 一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序 程序开始执行时它才运行，程序结束时它就停止 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程 虚拟机的退出 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统用现错误而导致Java虚拟机进程终止 某线程调用Runtime类或System类的exit()方法，或Runtime类的halt()方法，并且Java安全管理器也允许这次exit()或halt()操作。 除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。 JVM发展历程Sun Classic VM 早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是世界上第一款商用Java虚拟机，JDK1.4时完全被淘汰。 这款虚拟机内部只提供解释器，没有即时编译器，因此效率比较低。【即时编译器会把热点代码的本地机器指令缓存起来，那么以后使用热点代码的时候，效率就比较高】 如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作，解释器和编译器不能配合工作。 我们将字节码指令翻译成机器指令也是需要花时间的，如果只使用JIT，就需要把所有字节码指令都翻译成机器指令，就会导致翻译时间过长，也就是说在程序刚启动的时候，等待时间会很长。 而解释器就是走到哪，解释到哪。 现在Hotspot内置了此虚拟机。 Exact VM 为了解决上一个虚拟机问题，jdk1.2时，Sun提供了此虚拟机。 Exact Memory Management：准确式内存管理 也可以叫Non-Conservative/Accurate Memory Management 虚拟机可以知道内存中某个位置的数据具体是什么类型。 具备现代高性能虚拟机的维形 热点探测（寻找出热点代码进行缓存） 编译器与解释器混合工作模式 只在Solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换 HotSpot VM HotSpot历史 最初由一家名为“Longview Technologies”的小公司设计 1997年，此公司被Sun收购；2009年，Sun公司被甲骨文收购。 JDK1.3时，HotSpot VM成为默认虚拟机 目前Hotspot占有绝对的市场地位，称霸武林。 不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot Sun/oracle JDK和openJDK的默认虚拟机 因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。（比如其他两个商用虚机都没有方法区的概念） 从服务器、桌面到移动端、嵌入式都有应用。 名称中的HotSpot指的就是它的热点代码探测技术。 通过计数器找到最具编译价值代码，触发即时编译或栈上替换 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡 JRockit(商用三大虚拟机之一) 专注于服务器端应用：它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。 大量的行业基准测试显示，JRockit JVM是世界上最快的JVM：使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。 优势：全面的Java运行时解决方案组合 JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要 Mission Control服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。 2008年，JRockit被Oracle收购。 Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。 高斯林：目前就职于谷歌，研究人工智能和水下机器人 IBM的J9(三大商用虚拟机之一) 全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9 市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。 目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。 2017年左右，IBM发布了开源J9VM，命名为openJ9，交给Eclipse基金会管理，也称为Eclipse OpenJ9 OpenJDK -&gt; 是JDK开源了，包括了虚拟机 KVM和CDC/CLDC Hotspot Oracle在Java ME产品线上的两款虚拟机为：CDC/CLDC HotSpot Implementation VM KVM（Kilobyte）是CLDC-HI早期产品 目前移动领域地位尴尬，智能机被Android和iOS二分天下。 KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场 智能控制器、传感器 老人手机、经济欠发达地区的功能手机 所有的虚拟机的原则：一次编译，到处运行。 Azul VM 前面三大“高性能Java虚拟机”使用在通用硬件平台上 这里Azul VW和BEA Liquid VM是与特定硬件平台绑定、软硬件配合的专有虚拟机：高性能Java虚拟机中的战斗机。 Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机。 每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。 2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。 Liquid VM 高性能Java虚拟机中的战斗机。 BEA公司开发的，直接运行在自家Hypervisor系统上 Liquid VM即是现在的JRockit VE（Virtual Edition）。Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。 随着JRockit虚拟机终止开发，Liquid vM项目也停止了。 Apache Marmony Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。 它是IElf和Intel联合开发的开源JVM，受到同样开源的Open JDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK 虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。 Micorsoft JVM 微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。 只能在window平台下运行。但确是当时Windows下性能最好的Java VM。 1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了Sun很多钱。微软WindowsXP SP3中抹掉了其VM。现在Windows上安装的jdk都是HotSpot。 Taobao JVM 由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。 基于OpenJDK开发了自己的定制版本AlibabaJDK，简称AJDK。是整个阿里Java体系的基石。 基于OpenJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。 创新的GCIH（GCinvisible heap）技术实现了off-heap，即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。 GCIH中的对象还能够在多个Java虚拟机进程中实现共享 使用crc32指令实现JvM intrinsic降低JNI的调用开销 PMU hardware的Java profiling tool和诊断协助功能 针对大数据场景的ZenGC taobao vm应用在阿里产品上性能高，硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能 目前已经在淘宝、天猫上线，把Oracle官方JvM版本全部替换了。 Dalvik VM 谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。 Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”，它没有遵循 Java虚拟机规范 不能直接执行Java的Class文件 基于寄存器架构，不是jvm的栈架构。 执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。 它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。 Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。 Graal VM（未来虚拟机） 2018年4月，Oracle Labs公开了GraalvM，号称 “Run Programs Faster Anywhere”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。 GraalVM在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等 支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件 工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。 如果说HotSpot有一天真的被取代，Graalvm希望最大。但是Java的软件生态没有丝毫变化。 总结具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以Oracle HotSpot VM为默认虚拟机。"},{"title":"Nginx","date":"2021-10-23T16:00:00.000Z","url":"/2021/10/24/20211024-Nginx/","tags":[["并发","/tags/%E5%B9%B6%E5%8F%91/"],["服务器","/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"]],"categories":[["Nginx","/categories/Nginx/"]],"content":"Nginx简介Nginx是高性能的Http和反向代理的服务器，占用内存少，有处理高并发的能力，能经受高负载考验 Nginx 可以作为静态页面的 web 服务器，同时还支持 CGI 协议的动态语言，比如 perl、php 等。但是不支持 java。Java 程序只能通过与 tomcat 配合完成。Nginx 专为性能优化而开发， 性能是其最重要的考量,实现上非常注重效率 正向代理如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访 问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理 反向代理反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器整体对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。 负载均衡普通流程为：客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服 务器处理完毕后，再将结果返回给客户端。 这种架构模式适合系统相对单一，并发请求相对较少的情况。但随着访问量的增长以及业务的复杂程度增加，会导致服务器响应客户端的请求缓慢，并发量特别大的时候，还可能会导致服务器直接崩溃。 通过增加服务器的物理配置可以缓解这一情况，但是面对如双十一的商品的瞬时访问量来讲，现有的顶级物理配置也是不够的。因此，可以通过增加服务器的数量(集群)来解决。通过增加服务器的数量，将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，每个服务器分开承担负载，即为负载均衡 动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力 Nginx原理master&amp;&amp;worker nginx启动后会有一个Master进程和多个Worker进程，Master进程主要用来管理Worker进程，包括： 接收信号，将信号分发给Worker进程，监听Worker进程的工作状态，当worker进程非正常退出时，会启动新的Worker进程。基本的网络事件会交给Worker进程处理。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的 。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。Worker数量是可以设置的，一般与服务器的CPU数相等最为适宜。 Master接收到重新加载的信号 当Master接收到重新加载的信号(./nginx -s reload)时，Master会重新加载配置文件，然后启动新的进程，使用新的Worker进程来接受请求，老的Worker进程将不再接收新的，处理完正在处理的请求就会退出 worker进程处理用户的请求 首先Master会根据配置文件生成一个监听相应端口的socket，然后再faster出多个worker进程，这样每个worker就可以接受从socket过来的信息（一般来讲，每个Worker都有一个socket，但是这些socket监听的地址是一样的）。当一个连接过来的时候，每一个Worker都能接收到通知，但是只有一个Worker可以连接成功，其余的Worker就会连接失败，也就是惊群效应。因此，nginx提供了一个共享锁accept_mutex，有这个共享锁，就会只有一个worker去接受这个连接。当一个Worker进程在接受这个连接之后，就开始读取请求，解析请求，处理请求，产生数据，返回客户端，断开连接。 Nginx详细配置1、全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。 2、events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。 3、http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。 4、server块：配置虚拟主机的相关参数，一个http中可以有多个server。 5、location块：配置请求的路由，以及各种页面的处理情况 1、1.$remote_addr 与$http_x_forwarded_for 用以记录客户端的ip地址； 2.$remote_user ：用来记录客户端用户名称； 3.$time_local ： 用来记录访问时间与时区；4.$request ： 用来记录请求的url与http协议； 5.$status ： 用来记录请求状态；成功是200， 6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；7.$http_referer ：用来记录从那个页面链接访问过来的； 8.$http_user_agent ：记录客户端浏览器的相关信息； 2、惊群现象：一个网路连接到来，多个睡眠的进程被同事叫醒，但只有一个进程能获得链接，这样会影响系统性能。 3、每个指令必须有分号结束。"},{"title":"MySQL存储引擎","date":"2021-09-28T16:00:00.000Z","url":"/2021/09/29/2021929-MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","tags":[["存储引擎","/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"]],"categories":[["mysql","/categories/mysql/"]],"content":"Mysql表类型和存储引擎MySQL的表类型由存储引擎决定，常用的包括MyISAM、InnoDB、Memory MySQL数据表主要支持六种类型，分别是：CSV、Memory、ARCHIVE、MRG_MYISAM、MYISAM、InnoBDB 这六种分为两类，事务安全型(transaction-safe)和非事务安全型(non-transaction-safe) 主要的存储引擎/表类型特点 特点 Myisam InnoDB Memory Archive 批量插入的速度 高 低 高 非常高 事务安全 支持 全文索引 支持 锁机制 表锁 行锁 表锁 行锁 存储限制 无 64TB 有 没有 B树索引 支持 支持 支持 哈希索引 支持 支持 集群索引 支持 数据缓存 支持 支持 索引缓存 支持 支持 支持 数据可压缩 支持 支持 空间使用 低 高 N/A 非常低 内存使用 低 高 中等 低 支持外键 支持 MyISAM不支持事务、也不支持外键，但访问速度快，对事物完整性没有要求 InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是比起MyISAM存储引擎，InnoDB写的处理效率差一些并且会占用更多的磁盘空间以保留数据和索引 MEMORY存储引擎使用存在内存中的内容来创建表。每个MEMORY表只实际对应一个磁盘文件。MEMORY类型的表访问非常快，因为它的数据是存放在内存中的，并且默认使用HASH索引。但是一旦MySQL服务关闭，表中的数据就会丢失掉，表的结构还在 总结 如果应用不需要事务，处理的只是基本的CRUD操作，那么MyISAM可以满足 如果需要支持事务，选择InnoDB Memory存储引擎就是将数据存储在内存中，由于没有磁盘I/O的等待，速度极快，但由于是内存存储引擎，所做的任何修改在服务器重启后都将消失(用法：用户的在线状态) 行锁行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁 适用场景：有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用 特点：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高 表锁适用场景：以查询为主，只有少量按索引条件更新数据的应用 特点：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低"},{"title":"MyBatis","date":"2021-09-26T16:00:00.000Z","url":"/2021/09/27/2021927-MyBatis/","tags":[["mybatis","/tags/mybatis/"],["ssm","/tags/ssm/"]],"categories":[["MyBatis","/categories/MyBatis/"]],"content":"MyBatis使用（接口式编程） 创建maven工程，导入依赖 创建bean对象Employee和dao层接口EmployeeMapper，接口中创建待实现的方法 在resource目录下创建mybatis-config.xml(全局配置文件)，创建一个SqlSessionFactory对象，配置数据源(dataSource)信息 resource目录下新建mapper包，创建EmployeeMapper.xml(SQL映射文件)，里面配置了每一个sql，以及sql的封装规则。其中namespace是用来绑定接口的，即面向接口编程。当绑定接口后，可以不用写接口的实现类，mybatis会通过该绑定自动找到要执行的sql语句.接口中的方法需要与映射文件中的SQL语句的id一一对应. 将SQL映射文件注册到全局配置文件中 编写测试类 SqlSession代表和数据库的一次会话，用完必须关闭 SqlSession和connection一样，都是非线程安全的，每次使用都应该去获取新的对象 mapper接口没有实现类，将接口和xml文件绑定后，mybatis会为接口自动的创建一个代理对象，通过代理对象来执行增删改查方法 全局配置文件MyBatis官方中文文档 properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） SQL映射文件CRUD 接口中定义CRUD方法 SQL映射文件中加入相应的SQL语句 测试类实现方法 获取自增主键的值mysql支持自增主键、自增主键的值的获取 useGeneratedKeys=”true”，开启使用自增主键获取主键值策略 keyProperty：指定对应的主键属性，也就是mybatis获取到主键的值后，将这个值封装给JavaBean的哪个属性 参数处理单个参数：mybatis不会做特殊处理，#{参数名}，取出参数值 多个参数：mybatis会做特殊处理。多个参数会被封装成一个map key:param1…paramN,或者参数的索引 value:传入的参数值 #{}就是从map中获取指定的key的值 命名参数：明确指定封装参数时map的key：@Param(“id”) 多个参数会被封装成一个map，key为使用@Param注解指定的值，value:参数值 #{指定的key}取出对应的参数值 POJO：如果多个参数正好是业务逻辑的数据模型，就可以直接传入POJO #{属性名}：取出传入的POJO的属性值 Map：如果多个参数不是业务模型中的数据，没有对应的POJO，不经常使用，也可以传入Map #{key}：取出map中对应的值 如果多个参数不是业务模型中的数据，但是要经常使用，推荐来编写一个TO(Transfer) TO：如果多个参数不是业务模型中的的数据，但是要经常使用，推荐来编写一个TO(Transfer Object)数据传输对象 #{}和${}的区别#{}：是以预编译的形式，将参数设置到sql语句中，实现的是向prepareStatement中的预处理语句中设置参数值，防止SQL注入 ${}：取出的值直接拼装在sql语句中，无法阻止SQL注入 大多数情况下，取参数的值都应该去使用#{} MyBatis执行流程 mybatis应用程序通过SqlSessionFactoryBuilder从mybatis-config.xml配置文件（也可以用Java文件配置的方式，需要添加@Configuration）来构建SqlSessionFactory（SqlSessionFactory是线程安全的） SqlSessionFactory的实例直接开启一个SqlSession，再通过SqlSession实例获得Mapper对象并运行Mapper映射的SQL语句，完成对数据库的CRUD和事务提交，之后关闭SqlSession。 "},{"title":"ConcurrentHashMap","date":"2021-09-24T16:00:00.000Z","url":"/2021/09/25/2021925-ConcurrentHashMap/","tags":[["并发编程","/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"],["集合","/tags/%E9%9B%86%E5%90%88/"],["线程安全","/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"]],"categories":[["Java","/categories/Java/"]],"content":"ConcurrentHashMap（JDK7） 底层结构Segment数组+HashEntry数组+链表(HashEntry节点) Segment数组中存储Segment对象，每个Segment中存储一个HashEntry数组，数组中存储每个HashEntry链表的头节点 还有两个主要的内部类： class Segment内部类，继承ReetranLock。 方法： class HashEntry内部类 用来封装散列映射为表中的键值对，key，hash和 next 域都被声明为 final 型，value 域被声明为 volatile 型 在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入 主要方法get() 第一次哈希，找到对应的Segment，调用Segment中的get方法 第二次哈希，找到对应的链表 在链表中查找值。 put() 首先确定段的位置，调用Segment中的put()方法 加锁 检查当前Segment数组中包含的HashEntry节点的个数，如果超过阈值就重新hash 然后再次hash确定放的链表 在对应的链表中查找是否相同节点，如果有直接覆盖，如果没有将其放置链表尾部 通过分段锁对数组进行了分割分段(Segment)，每一把锁只锁容器中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率 ConcurrentHashMap和 hashTable的保证线程安全的机制区别? Hashtable通过synchronized修饰方法 来保证线程安全ConcurrentHashMap通过Segment（继承了ReentrantLock）调用父类的锁对象加锁来实现 ConcurrentHashMap(JDK8)底层结构Node数组+链表/红黑树 Node数组用来存放树或者链表的头结点，当一个链表中的数量到达一个数目时，会使查询速率降低，所以到达一定阈值时，会将一个链表转换为一个红黑二叉树，加快查询的速率 主要属性 jdk1.8中虽然不在使用分段锁，但是仍然有Segment这个类，但是没有实际作用 内部类结构Node：ConcurrentHashMap存储结构的基本单元，实现了Map.Entry接口，用于存储数据。Node的val和next都用volatile修饰，保证可见性。它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。 TreeNode：继承于Node，但是数据结构换成了二叉树结构，它是红黑树的数据的存储结构，用于红黑树中存储数据，当链表的节点数大于8时会转换成红黑树的结构，他就是通过TreeNode作为存储结构代替Node来转换成红黑树 主要方法构造方法 构造方法并没有直接new出来一个Node的数组，只是检查数值之后确定了容量大小。 put方法 检查Key或者Value是否为null 得到key的Hash值 如果Node数组为空，此时才开始初始化initTable() 如果找的对应的下标位置为空，直接new一个节点并放入然后break 如果对应头节点不为空，进入同步代码块 判断此头结点的Hash值，是否大于0，大于0说明是链表的头节点在此链表中寻找。 如果有相同hash值并且key相同，就直接覆盖，返回旧值 结束 如果没有则就直接放置在链表的尾部 此头节点的Hash值小于0，则说明此节点是红黑二叉树的根节点调用树的添加元素方法判断当前数组是否要转变为红黑树 get() 首先获取到Key的hash值 然后找到对应的数组下标处的元素 如果此元素是我们要找的，直接返回 如果此元素是null 返回null 如果Key的值&lt; 0 ,说明是红黑树 如何保证线程安全jdk7分段锁 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率 jdk8使用的是优化的synchronized 关键字同步代码块 和 cas操作了维护并发。 为什么要用synchronized，cas不是已经可以保证操作的线程安全吗？ CAS也是适用一些场合的，比如资源竞争小时，是非常适用的，不用进行内核态和用户态之间的线程上下文切换，同时自旋概率也会大大减少，提升性能，但资源竞争激烈时（比如大量线程对同一资源进行写和读操作）并不适用，自旋概率会大大增加，从而浪费CPU资源，降低性能"},{"title":"SpringMVC执行过程","date":"2021-09-24T16:00:00.000Z","url":"/2021/09/25/2021925-SpringMVC%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/","tags":[["springmvc","/tags/springmvc/"]],"categories":[["springmvc","/categories/springmvc/"]],"content":"SpringMVC执行流程 用户发送请求，其中url被DispatcherServlet捕获 DispatcherServlet调用HandlerMapping来匹配对应的映射，HandlerMapping核心实现类RequestMappingHandlerMapping会找出Spring容器中被@Controller注解修饰的bean以及被@RequestMapping注解修饰的类和方法 匹配到会返回一个HandlerExecutionChain执行链对象（包括处理器对象和处理器拦截器），没匹配到会检查是否配置了&lt; mvc:default-servlet-handler/&gt;，如果没有配置就会404报错，控制台显示没有找到请求地址。如果配置了就会转到配置的目标资源 将执行链返回给DispatcherServlet HandlerInterceptor拦截调用preHandle方法 DispatcherServlet根据处理器调用相应的HandlerAdapter执行操作，其核心实现类RequestMappingHandlerAdapter解析方法的参数和处理方法的返回值会处理如@RequestParam、@RequestBody、@ResponseBody等注解修饰的参数或返回值，其中有ModelAndViewMethodReturnValueHandler作为实现类之一处理返回值类型为ModelAndView的方法 执行处理器Handler 执行完成返回ModelAndView 处理器适配器将Handler执行结果ModelAndView返回给DispatcherServlet HandlerInterceptor拦截调用postHandle方法 如果前面发生异常使用HandlerExceptionResolver策略解决 前端控制器将ModelAndView传给视图解析器，解析后返回View对象 DispatcherServlet对View进行渲染视图(即，将模型数据model填充到视图中) DispatcherServlet响应给用户 HandlerInterceptor拦截调用afterCpompletion方法 "},{"title":"Redis6","date":"2021-09-18T16:00:00.000Z","url":"/2021/09/19/2021919-Redis6/","tags":[["NoSQL","/tags/NoSQL/"],["redis","/tags/redis/"],["集群","/tags/%E9%9B%86%E7%BE%A4/"]],"categories":[["redis","/categories/redis/"]],"content":"NoSQL数据库NoSQL数据库，泛指非关系型数据库。NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。 不遵循SQL标准 不支持ACID 远超于SQL的性能 适用场景 对数据高并发的读写 海量数据的读写 对数据高可扩展性 不适用场景 需要事务支持 基于sql的结构化查询存储，处理复杂的关系，需要即时查询 用不到SQL和用SQL也不行的情况 Redis后台启动修改redis.conf文件将里面的daemonize no改成yes，让服务在后台启动。 调用redis.conf文件：redis -server/目标文件夹/redis.conf 用客户端访问：redis-cli 多个端口可以使用：redis-cli -p 端口号 测试验证：ping 单实例关闭：redis-cli shutdown（也可以进入终端后关闭：shutdown） 多实例关闭,指定端口关闭：redis-cli -p 端口号 shutdown 介绍Redis是单线程+多路IO复用技术 多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池） 常用数据类型键(key) 数据库操作select命令切换数据库 dbsize查看当前数据库的key的数量 flushdb清空当前库 flushall通杀全部库 字符串(String)String是Redis最基本的类型，一个key对应一个value。一个Redis中字符串value最多可以是512M String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。 数据结构String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配 当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M 列表(List)单键多值 Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差 List的数据结构为快速链表quickList。 首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。 它将所有的元素紧挨着一起存储，分配的是一块连续的内存。 当数据量比较多的时候才会改成quicklist。 因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。 Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。 集合(Set)Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。 Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的*复杂度都是***O(1)**。 一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变 数据结构Set数据结构是dict字典，字典是用哈希表实现的。 Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。 哈希(Hash)Redis hash 是一个键值对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 类似Java里面的Map&lt;String,Object&gt; 用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储 主要有以下2种存储方式： 数据结构Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。 有序集合Zset(sorted set)Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。 不同之处是有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。 因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。 访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。 数据结构SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。 zset底层使用了两个数据结构 （1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。 （2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。 发布和订阅Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 发布订阅命令行实现 打开一个客户端订阅channel1：SUBSCRIBE channel1 打开另一个客户端，给channel1发布消息hello：publish channel1 hello 打开第一个客户端可以看到发送的消息 注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息 新数据类型Bitmaps现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011 合理地使用操作位能够有效地提高内存使用率和开发效率。 Redis提供了Bitmaps这个“数据类型”可以实现对位的操作： Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作 Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量 命令setbit格式： setbit&lt; key&gt;&lt; offset&gt;&lt; value&gt;：设置Bitmaps中某个偏移量的值（0或1） 实例： 每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。 设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图 unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps 注： 很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。 在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。 getbit格式： getbit&lt; key&gt;&lt; offset&gt;：获取键的第offset位的值（从0开始算） 实例： 获取id=8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过 注：因为100根本不存在，所以也是返回0 bitcount统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。 格式: bitcount[start end] ：统计字符串从start字节到end字节比特值为1的数量 实例： 计算2022-11-06这天的独立访问用户数量 start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19 注：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置 bitop格式： bitop and(or/not/xor) [key…]：bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中 Bitmaps与set对比 但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0 HyperLogLog在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。 但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题 解决基数问题有很多种方案: 数据存储在MySQL表中，使用distinct count计算不重复个数 使用Redis提供的hash、set、bitmaps等数据结构来处理 以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的 Redis推出了HyperLogLog，降低一定的精度来平衡存储空间。 Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。 在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 基数：比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 共有5个，基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数 命令pfadd格式： pfadd &lt; key&gt;&lt; element&gt; [element …]：添加指定元素到 HyperLogLog 中 将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL(近似基数统计)估计的近似基数发生变化，则返回1，否则返回0 pfcount格式： pfcount&lt; key&gt; [key …] ：计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可 pfmerge格式： pfmerge&lt; destkey&gt;&lt; sourcekey&gt; [sourcekey …] ：将一个或多个HLL合并后的结果存储在另一个HLL中 GeospatialRedis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作 命令geoadd格式 geoadd&lt; key&gt;&lt; longitude&gt;&lt; latitude&gt;&lt; member&gt; [longitude latitude member…] ：添加地理位置（经度，纬度，名称） 实例： 两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。 当坐标位置超出指定范围时，该命令将会返回一个错误。 已经添加的数据，是无法再次往里面添加的 geopos格式： geopos &lt; key&gt;&lt; member&gt; [member…] ：获得指定地区的坐标值 geodist格式： geodist&lt; key&gt;&lt; member1&gt;&lt; member2&gt; [m|km|ft|mi ] 获取两个位置之间的直线距离 单位： m 表示单位为米[默认值]。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位 georadius格式： georadius&lt; key&gt;&lt; longitude&gt;&lt; latitude&gt;radius m|km|ft|mi ：以给定的经纬度为中心，找出某一半径内的元素 Redis_Jedis_测试导入需要的依赖 注意事项： 禁用Linux的防火墙：Linux(CentOS7)里执行命令 systemctl stop/disable firewalld.service redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no 创建动态的工程 创建测试程序 模拟验证码 整合SpringBoot1、 在pom.xml文件中引入redis相关依赖 2、application.properties配置redis配置 3、添加redis配置类 4、测试 Redis事务Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断 Redis事务的主要作用就是串联多个命令防止别的命令插队 Multi、Exec、discard从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。 组队的过程中可以通过discard来放弃组队 错误处理组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消 如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。 事务冲突WATCH key [key …]在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务**执行之前这个(**或这些) key 被其他命令所改动，那么事务将被打断。 unwatch取消 WATCH 命令对所有 key 的监视。 如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了 Redis事务三特性 单独的隔离操作 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断 没有隔离级别的概念 队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行 不保证原子性 事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 Redis持久化RDB(Redis DataBase)在指定的时间间隔内将内存中的数据集快照写入磁盘， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里 备份执行过程Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到 一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失 Fork Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程 l 在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术” 一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程 初始化流程 在redis.conf中配置文件名称，默认为dump.rdb rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下 命令save ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。 bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。 可以通过lastsave 命令获取最后一次成功执行快照的时间 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义 优势 适合大规模的数据恢复 对数据完整性和一致性要求不高更适合使用 节省磁盘空间 恢复速度快 AOF(Append Only File)以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 持久化流程 客户端的请求写命令会被append追加到AOF缓冲区内 AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中 AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量 Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的 AOF默认不开启，可以在redis.conf中配置文件名称，默认为 appendonly.aof AOF文件的保存路径，同RDB的路径一致 AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失） AOF启动/修复/恢复 AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载 正常恢复 修改默认的appendonly no，改为yes 将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir) 恢复：重启redis然后重新加载 异常恢复 修改默认的appendonly no，改为yes 如遇到AOF文件损坏，通过/usr/local/bin/redis-check-aof–fix appendonly.aof进行恢复 备份被写坏的AOF文件 恢复：重启redis，然后重新加载 AOF同步频率设置appendfsync always 始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好 appendfsync everysec 每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。 appendfsync no redis不主动进行同步，把同步时机交给操作系统。 Rewrite压缩AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof 流程 bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行 主进程fork出子进程执行重写操作，保证主进程不会阻塞 子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失 子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。主进程把aof_rewrite_buf中的数据写入到新的AOF文件 使用新的AOF文件覆盖旧的AOF文件，完成AOF重写 优势 备份机制更稳健，丢失数据概率更低 可读的日志文本，通过操作AOF稳健，可以处理误操作 劣势 比起RDB占用更多的磁盘空间 恢复备份速度要慢 每次读写都同步的话，有一定的性能压力 存在个别Bug，造成恢复不能 官方推荐两个都启用。 如果对数据不敏感，可以选单独用RDB。 不建议单独用 AOF，因为可能会出现Bug。 如果只是做纯内存缓存，可以都不用 主从复制主机数据更新后根据配置和策略， 自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主 读写分离 容灾回复 使用拷贝多个redis.conf文件include(写绝对路径) 开启daemonize yes Pid文件名字pidfile 指定端口port Log文件名字 dump.rdb名字dbfilename Appendonly 关掉或者换名字 例： include /myredis/redis.conf pidfile /var/run/redis_6379.pid port 6379 dbfilename dump6379.rdb 新建redis6379.conf、redis6380.conf、redis6381.conf 启动三台redis服务器 查看系统进程，查看三台服务是否启动：ps -ef|grep redis 查看三台主机运行情况： info replication 打印主从复制的相关信息 使用：slaveof &lt; ip&gt;&lt; port&gt;：成为某个实例的从服务器 在6380和6381上执行: slaveof 127.0.0.1 6379 在主机上写，在从机上可以读取数据 主机挂掉，重启就行，一切如初 从机重启需重设：slaveof 127.0.0.1 6379 复制原理 Slave启动成功连接到master后会发送一个sync命令 Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中 增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步 但是只要是重新连接master,一次完全同步（全量复制)将被自动执行 哨兵模式能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库 自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错 sentinel monitor mymaster 127.0.0.1 6379 1 其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。 启动哨兵： /usr/local/bin redis做压测可以用自带的redis-benchmark工具 执行redis-sentinel /myredis/sentinel.conf 当主机挂掉，从机选举中产生新的主机 根据优先级别：slave-priority 原主机重启后会变为从机。 复制延时由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重 Redis集群Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N Redis 集群通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求 删除时持久化数据将rdb,aof文件都删除掉 配置基本信息开启daemonize yes Pid文件名字 指定端口 Log文件名字 Dump.rdb名字 Appendonly 关掉或者换名字 cluster-enabled yes 打开集群模式 cluster-config-file nodes-6379.conf 设定节点配置文件名 cluster-node-timeout 15000 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。 合体为集群 cd /opt/redis-6.2.1/src –replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组 登录 -c 采用集群策略连接，设置数据会自动切换到相应的写主机 通过 cluster nodes命令查看集群信息 一个集群至少要有三个主节点。 选项 –cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。 分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上 slots一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。 集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群可以有主节点， 其中： 节点 A 负责处理 0 号至 5460 号插槽。 节点 B 负责处理 5461 号至 10922 号插槽。 节点 C 负责处理 10923 号至 16383 号插槽。 集群中录入值在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。 redis-cli客户端提供了 –c 参数实现自动重定向。 如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向 不在一个slot下的键值，是不能使用mget,mset等多键操作 可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去 查询集群中的值CLUSTER GETKEYSINSLOT 返回 count 个 slot 槽中的键。 故障恢复如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉 如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。 redis.conf中的参数 cluster-require-full-coverage 集群的Jedis开发即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。 无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据 优点实现扩容 分摊压力 无中心配置相对简单 不足多键操作是不被支持的 多键的Redis事务是不被支持的。lua脚本不被支持 由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。 Redis应用问题缓存穿透key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库 解决方案一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义 对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟 设置可访问的名单（白名单）： 使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。 采用布隆过滤器：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。) 进行实时监控：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务 缓存击穿key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大量并发的请求可能会瞬间把后端DB压垮。 解决方案key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。 预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长 实时调整：现场监控哪些数据热门，实时调整key的过期时长 使用锁： 就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。 先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key 当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key； 当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法 缓存雪崩key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key 解决方案缓存失效时的雪崩效应对底层系统的冲击非常可怕！ 解决方案： 构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等） 使用锁或队列： 用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况 设置过期标志更新缓存： 记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。 将缓存失效时间分散开： 比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 分布式锁随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！ 分布式锁主流的实现方案： 基于数据库实现分布式锁 基于缓存（Redis等） 基于Zookeeper 每一种分布式锁解决方案都有各自的优缺点： 性能：redis最高 可靠性：zookeeper最高 使用redis实现分布式锁 使用setnx上锁，通过del释放锁 锁一直没有释放，设置key过期时间，自动释放 也可以上锁时同时设置过期时间 问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放 解决：设置过期时间，自动释放锁 首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放） 在set时指定过期时间（推荐） 问题：可能会释放其他服务器的锁。 场景：如果业务逻辑的执行时间是7s。执行流程如下 index1业务逻辑没执行完，3秒后锁被自动释放。 index2获取到锁，执行业务逻辑，3秒后锁被自动释放。 index3获取到锁，执行业务逻辑 index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。 最终等于没锁的情况。 解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁 "},{"title":"常用类","date":"2021-07-29T16:00:00.000Z","url":"/2021/07/30/2021730-%E5%B8%B8%E7%94%A8%E7%B1%BB/","tags":[["包装类","/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/"],["String","/tags/String/"],["Date","/tags/Date/"]],"categories":[["Java","/categories/Java/"]],"content":"包装类针对八种基本数据类型相应的引用类型—包装类 基本数据类型 包装类 boolean Boolean char Character byte Byte short Short int Integer long Long float Float double Double jdk5之前的手动装箱和拆箱方式： jdk5之后可以自动装箱和自动拆箱 包装类型和String类型的相互转换包装类型→String类型 String类型→包装类型 String类 String对象用于保存字符串，也就是一组字符序列 字符串常量对象使用双引号括起的字符序列 字符串的字符使用Unicode编码，一个字符(不区分字母还是汉字)占两个字节 String类有很多构造器，构造器的重载 String类实现了接口Serializable[String可以串行化：可以在网络传输]和Comparable[String对象可以比较大小] String是final类，不能被其他的类继承 String有属性 private final char value[] 用于存放字符串内容 一定要注意：value是一个final类型，不可以修改(指引用地址，单个字符内容可以改变) 创建String对象方式一：直接赋值String s=”xxx”; 先从常量池查看是否有”xxx”数据空间，如果有,直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址 方式二：调用构造器String s2=new String(“xxx”); 先在堆中创建空间，里面维护了value属性，指向常量池的xxx空间。如果常量池没有”xxx”,重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址 StringBuffer类 java.lang.StringBuffer类代表可变的字符序列，可以对字符串内容进行增删 很多方法与String相同，但StringBuffer是可变长度 StringBuffer是一个容器 StringBuffer的直接父类是AbstractStringBuffer StringBuffer实现了Serializable，即StringBuffer的对象可以串行化 在父类中 AbstractStringBuffer有属性 char[] value,不是final。该value数组存放字符串的内容，因此存放在堆中的 StringBuffer是一个final类，不能被继承 因为StringBuffer字符内容是存在char[] value，所以在变化(增加/删除)时，不用每次都更换地址(即不是每次都创建新的对象),所以效率高于String 构造器 构造方法摘要 StringBuffer() 构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符 StringBuffer(CharSequence seq) 构造一个字符串缓冲区，它包含与指定的CharSequence相同的字符 StringBuffer(int capacity) 构造一个不带字符，但具有指定初始容量的字符串缓冲区。即对char[]大小进行指定 StringBuffer(String str) 构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容 String→StringBuffer方式一：使用构造器 方式二：使用append方法 StringBuffer→String方式一：使用StringBuffer提供的toString方法 方式二：使用构造器 StringBuilder类 一个可变的字符序列。此类提供一个与StringBuilder兼容的API，但不保证同步。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类，因为在大多数实现中，它比StringBuffer要快 在StringBuilder上的主要操作是append和insert方法,可重载这些方法，以接受任意类型的数据。 StringBuilder类继承AbstractStringBuilder 实现了Serializable，说明StringBuilder对象是可以串行化的 StringBuilder是final类，不能被继承 StringBuilder对象字符序列仍然是存放在其父类中的 char[] value;。因此，字符序列是在堆中 StringBuilder的方法，没有做互斥的处理，即没有synchronized关键字，因此在单线程的情况下使用 String、StringBuffer、StringBuilder的比较 StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样 String：不可变字符序列，效率低，但是复用率高 StringBuffer：可变字符序列、效率较高(增删)、线程安全 StringBuilder：可变字符序列、效率最高、线程不安全 String使用注意说明： string a=”a”;//创建了一个字符串 s+=”b”;//实际上原来的“a”字符串对象已经丢弃了，现在又产生了一个字符串s+=”b”(也就是”ab”)。如果多次执行这些多次改变串内容的操作，会导致大量副本字符串对象留在内存中，降低效率。这样的操作放到循环中，会极大影响程序性能。 结论：如果要对String做大量修改，不要使用String 效率：StringBuilder&gt;StringBuffer&gt;String String、StringBuffer、StringBuilder的选择 如果字符串存在大量的修改操作，一般用StringBuffer或StringBuilder 如果字符串存在大量的修改操作,并在单线程的情况，使用StringBuilder 如果字符串存在大量的修改操作,并存在多线程的情况，使用StringBuffer 如果字符串很少修改，被多个对象引用，使用String,比如配置信息等 "},{"title":"面向对象编程(OOP)","date":"2021-07-21T16:00:00.000Z","url":"/2021/07/22/2021722-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(OOP)/","tags":[["Java基础","/tags/Java%E5%9F%BA%E7%A1%80/"],["OOP","/tags/OOP/"]],"categories":[["Java","/categories/Java/"]],"content":"基本概念面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装。 优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 缺点： 性能比面向过程差 三大特性 封装 隐藏对象的属性和实现细节，仅对外提供公共访问方式，将便于隔离，便于使用，提高复用性和安全性 继承 提高代码复用性；继承是多态的前提 多态 父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性 五大基本原则 单一职责原则SRP（Single Responsibility Principle） 类的功能要单一，不能包罗万象，跟杂货铺似的 开放封闭原则OCP(Open－Close Principle) 一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意 里氏替换原则LSP(the Liskov Substitution Principle LSP) 子类可以替换父类出现在父类能够出现的任何地方 依赖倒置原则DIP(the Dependency Inversion Principle DIP) 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象 接口分离原则ISP(the Interface Segregation Principle ISP) 设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好 创建对象 访问属性对象名.属性名 类和对象的内存分配机制 p2.age是多少？画出内存图 Java内存结构分析 栈：一般存放基本数据类型（局部变量） 堆：存放对象(Cat cat，数组等) 方法区：常量池（常量，比如字符串），类加载信息 创建对象流程： 先加载类信息（属性和方法信息，只会加载一次） 在堆中分配空间，进行默认初始化 把地址赋给对象名，对象名指向对象 成员方法方法调用机制原理 成员方法的好处： 提高代码复用性 可以将实现的细节封装起来，然后供其他用户来调用 使用细节 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数 方法不能嵌套定义 一个方法最多有一个返回值 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象) 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值，而且要求返回值类型必须和 return 的值类型一致或兼容 如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return; 基本数据类型的传参机制基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参 引用数据类型的传参机制引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参 方法递归 执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 方法的局部变量是独立的，不会相互影响，比如n变量 如果方法中使用的是引用类型变量(比如数组，对象)，就会共享该引用类型的数据 递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕 方法重载（OverLoad）java 中允许同一个类中，多个同名方法的存在，但要求形参列表不一致 好处：减轻起名、记名的麻烦 使用细节 方法名：必须相同 形参列表：必须不同(形参类型或个数或顺序，至少有一样不同，参数名无要求) 返回类型：无要求 可变参数基本概念java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。 就可以通过可变参数实现 基本语法访问修饰符 返回类型 方法名(数据类型… 形参名) { } 注意事项和使用细节 可变参数的形参可以为0个或任意多个 可变参数的实参可以为数组 可变参数的本质就是数组 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后 一个形参列表中只能出现一个可变参数 作用域 在java编程中，主要的变量就是属性(成员变量)和局部变量 我们说的局部变量一般是指在成员方法中定义的变量 java中作用域的分类 全局变量：也就是属性，作用域为整个类体 局部变量：也就是除了属性之外的其他变量，作用域为定义他的代码块中 全局变量(属性)可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值。 使用细节 属性和局部变量可以重名，访问时遵循就近原则 在同一个作用域中，例如在同一个成员方法中，两个局部变量不能重名 属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中 作用域范围不同 全局变量/属性：可以被本类使用，或其他类使用(通过对象调用) 局部变量：只能在本类中对应的方法中使用 修饰符不同 全局变量/属性：可以被本类使用，或其他类使用(通过对象调用) 局部变量：只能在本类中对应的方法中使用 修饰符不同 全局变量/属性可以加修饰符 局部变量不可以加修饰符 构造方法/构造器基本语法[修饰符] 方法名(形参列表){ 方法体; } 使用细节 构造器的修饰符没有限制 构造器没有返回值 方法名和类名字必须一样 参数列表和成员方法一样的规则 构造器的调用，由系统完成 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化 一个类可以定义多个不同的构造器，即构造器重载 构造器是完成对象初始化，并不是创建对象 如果没有手动定义构造器，系统会自动生成一个默认无参构造器 一旦定义自己的构造器，默认构造器就会被覆盖，就不能再使用，除非显式定义一下。 对象创建流程分析 加载类信息，只会加载一次 在堆中分配空间(地址) 完成对象初始化 默认初始化——&gt;显式初始化——&gt;构造器初始化 把对象在堆中的地址，返回给p(p是对象名，也可以理解成是对象的引用) this关键字java虚拟机会给每个对象分配this，代表当前对象。 哪个对象调用，this就代表哪个对象 使用细节 this 关键字可以用来访问本类的属性、方法、构造器 this 用于区分当前类的属性和局部变量 访问成员方法的语法：this.方法名(参数列表); 访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句) this 不能在类定义的外部使用，只能在类定义的方法中使用 访问修饰符 修饰符 同类 同包 子类 不同包 private √ × × × default √ √ × × protected √ √ √ × public √ √ √ √ 注意事项 修饰符可以用来修饰类中的属性，成员方法以及类 只有默认的和public才能修饰类，并且遵循上述访问权限的特点 成员方法的访问规则和属性相同 面向对象编程三大特征封装封装就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作 优点 隐藏实现细节：方法(连接数据库)⬅调用(传入参数) 可以对数据进行验证，保证安全合理 步骤 将属性进行私有化private[不能直接修改属性] 提供一个公共的set方法，用于对属性判断并赋值 提供一个公共的get方法，用于获取属性的值 继承继承可以解决代码复用.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来 声明继承父类即可 子类会自动拥有父类定义的属性和方法 父类又叫超类，基类 子类又叫派生类 优点 代码的复用性提高了 代码的扩展性和维护性提高了 细节问题 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问 子类必须调用父类的构造器， 完成父类的初始化 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无 参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过 如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表) super 在使用时，必须放在构造器第一行(super 只能在构造器中使用) super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器 java 所有类都是 Object 类的子类, Object 是所有类的基类 父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类) 子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系 super关键字super 代表父类的引用，用于访问父类的属性、方法、构造器 访问父类的属性，但不能访问父类的private属性：super.属性名 访问父类的方法，但不能访问父类的private方法：super.方法名 访问父类的构造器：super(参数列表)（只能放在构造器的第一句，只能出现一次） 优点 分工明确，父类属性由父类初始化，子类的属性由子类初始化 当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果 super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员，如果多个基类中都有同名的成员，使用super访问遵循就近原则。当然也要遵循访问权限的相关规则 super 和 this 的比较 No. 区别 this super 1 访问属性 访问本类中的属性，如果本类没有此属性则从父类中继续查找 从父类开始查找属性 2 调用方法 访问本类中的方法，如果本类没有此方法则从父类继续查找 从父类开始查找方法 3 调用构造器 调用本类构造器，必须放在构造器的首行 调用父类构造器，必须放在子类构造器的首行 4 特殊 表示当前对象 子类中访问父类对象 多态方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的 具体体现方法的多态重载中传入不同的参数，就会调用不同sum方法。 重写中不同对象调用同一方法，就会执行不同的内容 对象的多态 一个对象的编译类型和运行类型可以不一致 编译类型在确认对象时，就确定了，不能改变 运行类型是可以变化的 编译类型看定义时=号的左边，运行类型看=号的右边 例如 Animal是Dog的父类 表示animal编译类型是Animal，运行类型是Dog 注意事项 多态的前提是：两个对象存在继承关系 多态的向上转型 本质：父类的引用指向了子类的对象 语法：父类类型 引用名=new 子类类型(); 特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员(需遵守访问权限)，不能调用子类中特有成员（因为在编译阶段，能调用哪些成员，是由编译类型来决定的）；最终运行效果看子类的具体实现（即调用方法时，按照从子类(运行类型)开始查找方法） 多态向下转型 语法：子类类型 引用名=(子类类型) 父类引用; 只能强转父类的引用，不能强转父类的对象 要求父类的引用必须指向的是当前目标类型的对象 当向下转型后，可以调用子类类型中所有的成员 属性不能重写，属性的值看编译类型 instanceOf 比较操作符：用于判断对象的运行类型是否为xx类型或xx类型的子类型 动态绑定机制 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用 多态数组数组的定义类型为父类类型，里面保存的实际元素类型为子类类型 多态参数方法定义的形参类型为父类类型，实参类型允许为子类类型 方法重写/覆盖当子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么子类方法会覆盖父类方法 使用细节 子类的形参列表、方法名称要和父类的完全一样 子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类 子类方法不能缩小父类方法的访问权限 重写与重载 名称 发生范围 方法名 形参列表 返回类型 修饰符 重载(overload) 本类 必须一样 类型、个数、顺序至少有一个不同 无要求 无要求 重写(override) 子父类 必须一样 相同 子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类 子类方法不能缩小父类方法的访问范围 Object类详解equals方法&amp;====是一个比较运算符 既可以判断基本类型，又可以判断引用类型 判断基本类型判断的实质的值是否相等 判断引用类型判断的是地址是否相等，即判定是不是同一个对象 equals是Object类中的方法，只能判断引用类型。默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等，例如String、Integer hashcode方法 提高具有哈希结构的容器的效率 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的 两个引用，如果指向的是不同对象，则哈希值是不一样的 哈希值主要根据地址号来的，不能完全将哈希值等价于地址 toString方法 默认返回：全类名+@+哈希值的16进制，子类往往重写toString方法，用于返回对象的属性信息 重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式 当直接输出一个对象时，toString会被默认的调用 finalize方法 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法 垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制 类变量和类方法类变量类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量 定义语法： 访问修饰符 static 数据类型 变量名； static 访问修饰符 数据类型 变量名； 访问类变量： 类名.类变量名 或者 对象名.类变量名 使用细节 当需要让类中的所有对象都共享同一个变量时，就可以考虑使用类变量 类变量与实例变量区别：类变量是该类的所有对象共享的，实例变量是每个对象独享的 实例变量不能通过 类名.类变量名 方式访问 类变量是在类加载时初始化，即使没有创建对象，只要类加载了，就可以使用类变量了 类变量的生命周期是随类的加载开始，随着类的消亡销毁 类方法类方法也叫静态方法 格式： 访问修饰符 static 返回类型 方法名(){} static 访问修饰符 返回类型 方法名(){} 调用： 类名.类方法名 对象名.类方法名 使用场景当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率 例如：工具类中的方法 utils(Math类、Arrays类) 使用细节 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区 类方法中无this参数，普通方法中隐含着this的参数 类方法可以通过类名调用，也可以通过对象名调用 普通方法和对象有关，需要通过对象名调用，不能通过类名调用 类方法中不能使用和对象有关的关键字比如this、super 类方法中只能访问静态变量或静态方法 普通成员方法既可以访问非静态成员，也可以访问静态成员 mian方法解释mian方法的形式：public static void main(String[] args){} main方法时虚拟机调用 java虚拟机调用类的mian()方法,所以该方法的访问权限必须是public 虚拟机在执行mian()方法时不必创建对象，所以该方法必须使static 该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数 注意： 在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性 不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员 代码块代码块又称为初始化块，属于类中的成员[即，是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来 但和方法不同，没有方法名，没有返回值，没有参数，只有方法体，而且不用通过对象或类的显式调用，而是加载类时，或创建对象时隐式调用 格式[修饰符]{代码}; 说明注意： 修饰符可选，只能写static 代码块分为两类，使用static修饰的叫静态代码块，否则为普通代码块 逻辑语句可以为任何逻辑语句 ;号可以写也可以省略 理解 相当于另一种形式的构造器(对构造器的补充机制)，可以做初始化的操作 场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性 使用细节 static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行 类什么时候加载 创建对象实例时(new) 创建子类对象实例，父类也会被加载 使用类的静态成员时(静态属性、静态方法) 普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行 创建一个对象时，在一个类的调用顺序： 调用静态代码块和静态属性初始化 调用普通代码块和普通属性初始化 调用构造方法 构造器的最前面其实隐含了super()和调用普通代码块 当创建一个子类对象时(继承关系)，他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序 父类的静态代码块和静态属性(优先级一样，按定义顺序执行) 子类的静态代码块和静态属性(优先级一样，按定义顺序执行) 父类的普通代码块和普通属性(优先级一样，按定义顺序执行) 父类的构造方法 子类的普通代码块和普通属性(优先级一样，按定义顺序执行) 子类的构造方法 静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任意成员 final关键字final可以修饰类、属性、方法和局部变量 使用final场合： 当不希望类被继承时 当不希望父类的某个方法被子类覆盖/重写时 当不希望类的某个属性的值被修改 当不希望某个局部变量被修改 使用细节 final修饰的属性又叫常量，一般用XX_XX_XX来命名 final修饰的属性在定义时,必须赋初值，并且以后不能再修改，可以赋初值的位置： 定义时 在构造器中 代码块中 如果final修饰的属性是静态的，则初始化的位置只能是定义时或静态代码块中 final类不能继承，但是可以实例化对象 如果类不是final，但是含有final方法，则该方法虽然不能重写，但是可以被继承 一般来说，如果已经是final类，就没必要再将方法修饰成final方法 final不能修饰构造方法 final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理 包装类和String,都是final类 抽象类当父类的某些方法需要声明，但又不确定如何实现的时候，可以将其声明为抽象方法，那么这个类就是抽象类 用abstract关键字来修饰一个类的时候，这个类就叫做抽象类，修饰方法的时候就叫抽象方法 抽象类的价值更多作用是在于设计，是设计者设置好后，让子类继承并实现抽象类() 使用细节 抽象类不能被实例化 抽象类不一定要包含abstract方法 一旦类包含了abstract方法，那这个类必须声明为抽象类 abstract只能修饰类和方法，不能修饰属性和其他的 抽象类可以有任意成员[抽象类本质还是类]，比如：非抽象方法、构造器、静态属性等等 抽象方法不能有主体，即不能实现 如果一个类继承了抽象类，则必须实现所有抽象类的所有抽象方法，除非他自己也声明为abstract类 抽象方法不能使用private、final、static来修饰，因为这些关键词都是和重写相违背的 接口接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法实现出来 interface 接口名{} class 类名 implements 接口{必须实现接口的方法} 接口是更加抽象的抽象的类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体【jdk7】。接口体现了程序设计的多态和高内聚低耦合的设计思想 注意：jdk8后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现 使用细节 接口不能被实例化 接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰 一个普通类实现接口，就必须将该接口的所有方法实现 抽象类实现接口，可以不用实现接口的方法 一个类可以实现多个接口 接口中的属性只能是final的，而且是public static final修饰符，必须初始化（比如：int a=1实际上是public static final int a=1） 接口中属性访问形式：接口名.属性名 接口不能继承其他的类，但是可以继承多个其他接口 接口的修饰符只能是public和默认，这点和类的修饰符是一样的 接口和继承继承的价值在于：解决代码的复用性和可维护性 接口的价值主要在于：设计好各种规范(方法)，让其他类去实现这些方法。即，更加的灵活 接口比继承更加灵活，继承是满足is-a的关系，接口是满足like-a的关系 接口在一定程度上实现代码解耦【即：接口规范性+动态绑定机制】 内部类一个类的内部又完整的嵌套了另一个类结构。被嵌套的类被称为内部类，嵌套其他类的类称为外部类，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系 如果定义在局部位置(方法中/代码块):局部内部类（有类名）&amp;匿名内部类（没有类名） 定义在成员的位置:成员内部类（没用static修饰）&amp;静态内部类（使用static修饰） 局部内部类局部内部类是定义在外部类的局部位置，比如方法中，并且有类名。 可以直接访问外部类的所有成员，包含私有的 不能添加访问修饰符，因为它是一个局部变量，局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量可以使用final 作用域：仅仅在定义它的方法或代码块中 局部内部类访问外部类的成员[访问方式：直接访问] 外部类访问局部内部类的成员[访问方式：创建对象，再访问（注意：必须在作用域中）] 外部其他类不能访问局部内部类(因为局部内部类地位是一个局部变量) 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员则可以使用（外部类名.this.成员）去访问 匿名内部类匿名内部类既是一个类的定义，也是一个对象。 匿名内部类只会加载一次， 成员内部类成员内部类是定义在外部类的成员位置，并且没有static修饰 可以直接访问外部类的所有成员，包含私有的 可以添加任意访问修饰符 作用域和外部其他成员一样，为整个类体 成员内部类访问外部类[直接访问] 外部类访问成员内部类[先创建对象，再访问] 静态内部类静态内部类是定义在外部类的成员位置，并且有static修饰 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员 可以添加任意访问修饰符，因为他的地位就是一个成员 作用域：同其他成员，为整个类体 静态内部类访问外部类[直接访问所有静态成员] 外部类访问静态内部类[创建对象再访问] "},{"title":"七大设计原则","date":"2021-07-14T16:00:00.000Z","url":"/2021/07/15/2021715-%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","tags":[["设计原则","/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"]],"categories":[["设计模式","/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"content":"设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础(即：设计模式为什么这样设计的依据) 单一职责原则对类来说的，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。 当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2 实例例如：建立一个Vehicle类，实现run方法 飞机不能在公路运行，因此可以建三个不同的交通工具类，来满足需求 改进后 注意事项和细节 降低类的复杂度，一个类只负责一项职责 提高类的可读性，可维护性 降低变更引起的风险 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违 反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则 接口隔离原则客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上 按隔离原则应当这样处理： 将接口Interface1拆分为独立的几个接口， 类A和类C分别与他们需要的接口建立依赖 关系。也就是采用接口隔离原则 改进后： 依赖倒转原则 高层模块不应该依赖于底层模块，二者都应该依赖其抽象 抽象不应该依赖细节，细节应该依赖于抽象 依赖倒转(倒置)的中心思想是面向接口编程 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定 多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成 例如：完成Person接收消息的功能 改进后： 依赖关系传递的三种方式 主方法 注意事项和细节 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在 一个缓冲层，利于程序扩展和优化 继承时遵循里氏替换原则 里氏替换原则面向对象中的继承性的思考和说明 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契 约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实 现的方法任意修改，就会对整个继承体系造成破坏 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵 入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承， 则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子 类的功能都有可能产生故障 问题提出：在编程中，如何正确的使用继承? =&gt; 里氏替换原则 里氏替换原则内容 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序 P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1 的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可 以通过聚合，组合，依赖来解决问题 在实际编程中，我们常常会通过重写父类的方法完 成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运 行多态比较频繁的时候。通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉， 采用依赖，聚合，组合等关系代替 例如： 开闭原则 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用 方)。用抽象构建框架，用实现扩展细节。 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已 有的代码来实现变化。 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则 根据此类图设计一段代码 优点：比较好理解，简单易操作 缺点：违反了设计模式的ocp原则，即对扩展开放(提供方)，对修改关闭(使用方)。 即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码 改进思路： 把创建Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可， 这样我们有新的图形种类时，只需要让新的图形类继承Shape，并实现draw方法即可。使用方的代码就不需要改动，满足了开闭原则 迪米特原则 一个对象应该对其他对象保持最少的了解 类与类的关系越密切，耦合度越大 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的 越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内 部。对外除了提供的public 方法，不对外泄露任何信息 迪米特法则还有个更简单的定义：只与直接的朋友通信 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系， 我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而 出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部 实例 有一个学校，下属有各个学院和 总部，现要求打印出学校总部员 工ID和学院员工的id 改进： 前面设计的问题在于SchoolManager中，CollegeEmployee类并不是 SchoolManager类的直接朋友 (分析) 按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合 注意事项和细节 迪米特法则的核心是降低类之间的耦合 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低 类间(对象间)耦合关系， 并不是要求完全没有依赖关系 合成复用原则原则是尽量使用合成/聚合的方式，而不是使用继承 核心思想 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代 码混在一起。 针对接口编程，而不是针对实现编程。 为了交互对象之间的松耦合设计而努力 "},{"title":"二叉平衡树(AVL树)","date":"2021-06-28T16:00:00.000Z","url":"/2021/06/29/2021-6-29-%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91(AVL%E6%A0%91)/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"平衡二叉树 问题分析 左子树全部为空，从形式上看，更像一个单链表 插入速度没有影响 查询速度明显降低(因为需要依次比较), 不能发挥BST 的优势，因为每次还需要比较左子树，其查询速度比 单链表还慢 解决方案-平衡二叉树(AVL) 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高 具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等 左旋转要求: 给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8} 步骤 创建一个新的节点，值等于当前根结点的值 把新节点的左子树设置成当前节点的左子树 把新结点的右子树，设置成当前节点的右子树的左子树 吧当前节点的值，换成右子节点的值 把当前节点的右子树设置成右子树的右子树 把当前节点的左子树设置为新节点 右旋转要求: 给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6} 步骤： 创建一个新的节点，值等于当前根结点的值 把新节点的右子树设置为当前节点的右子树 把新节点的左子树设置成当前节点的左子树的右子树 把当前节点的值换为左子节点的值 把当前节点的左子树设置成左子树的左子树 把当前节点的右子树设置成新节点 双旋转有时，单旋转并不能完成平衡二叉树的转换 步骤 当符合右旋转的条件时 如果它的左子树的右子树的高度大于它的左子树的高度 先对当前这个节点的左节点进行左旋转 再对当前节点进行右旋转的操作即可 "},{"title":"二叉排序树","date":"2021-06-28T16:00:00.000Z","url":"/2021/06/29/2021-6-29-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"二叉排序树对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右节点的值比当前节点大（如果有相同的值，可以将该节点放在左子节点或右子节点） 应用实例一个数组{7，3，10，12，5，1，9}创建成对应的二叉排序树，并进行中序遍历二叉排序树 添加、遍历节点添加Node节点 创建二叉排序树 测试 删除节点有三种情况 删除叶子节点(比如：2，5，9，12) 删除只有一颗子树的节点(比如：1) 删除有两棵子树的节点(比如：7，3，10) 删除叶子节点思路分析 找到要删除的节点targetNode 找到targetNode的父节点parent 确定targetNode是parent的左子节点还是右子节点 根据第三步的情况对应删除 左子节点 parent.left=null; 右子节点 parent.right=null; 删除只有一棵子树的节点思路分析 找到要删除的节点targetNode 找到targetNode的父节点parent 确定targetNode的子节点是左子节点还是右子节点 targetNode是parent的左子节点还是右子节点 如果targetNode有左子节点 如果targetNode是parent的左子节点:parent.left=targetNode.left 如果targetNode是parent的右子节点:parent.right=targetNode.left 如果targetNode有右子节点 如果targetNode是parent的左子节点:parent.left=targetNode.right 如果targetNode是parent的右子节点:parent.right=targetNode.right 删除有两棵子树的节点思路分析 找到要删除的节点targetNode 找到targetNode的父节点parent 从targetNode的右子树找到最小节点 用一个临时变量temp将最小节点的值保存 删除该最小节点 targetNode.value=temp; 代码实现 node类中添加方法 在BinarySortTree中添加 测试 "},{"title":"图","date":"2021-06-28T16:00:00.000Z","url":"/2021/06/29/2021-6-29-%E5%9B%BE/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"图线性表局限于一个直接前驱和一个直接后继的关系，树也只能有一个直接前驱，也就是父节点。当需要表示多对多的关系时，就会用到图 图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点 图包括：顶点、边、路径 图分为：无向图、有向图(顶点之间的连接有方向)、带权图(边带权值) 图的表示方式分为：二维数组表示（邻接矩阵）；链表表示（邻接表） 邻接矩阵邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的行和列表示的是1….n个点 邻接表邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成 实例用代码实现以下结构 思路分析 存储顶点String使用ArrayList 保存矩阵：int[][] edges 代码实现 深度优先遍历基本思想深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点 这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问 深度优先搜索是一个递归的过程 步骤以同一个图为例： 访问初始结点v，并标记结点v为已访问 查找结点v的第一个邻接结点w 若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123） 查找结点v的w邻接结点的下一个邻接结点，转到步骤3 广度优先遍历基本思想图的广度优先搜索(Broad First Search) 。 类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点 步骤 访问初始结点v并标记结点v为已访问 结点v入队列 当队列非空时，继续执行，否则算法结束 出队列，取得队头结点u 查找结点u的第一个邻接结点w 若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤 若结点w尚未被访问，则访问结点w并标记为已访问 结点w入队列 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6 "},{"title":"多路查找树","date":"2021-06-28T16:00:00.000Z","url":"/2021/06/29/2021-6-29-%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"多路查找树二叉树问题分析二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如1亿)， 就存在如下问题： 构建二叉树时，需要多次进行i/o操作(海量数据存在数据库或文件中),节点海量构建二叉树时，速度有影响 节点海量，会造成二叉树高度很大，会降低操作速度 多叉树 在二叉树中，每个节点有数据项，最多有两个子节点。如果每个节点可以有更多的数据项和更多的子节点，就是多叉树 2-3树，2-3-4树都属于多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化 B树B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入 将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素, B树(B+)广泛应用于文件存储系统以及数据库系统中 B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4 B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据 搜索有可能在非叶子结点结束 其搜索性能等价于在关键字全集内做一次二分查找 2-3树 2-3树所有的叶子节点都在同一层(只要是B树都满足这个条件) 有2个子节点的节点叫2节点，2节点要么没有子节点，要么有2个子节点 有3个子节点的节点叫3节点，3节点要么没有子节点，要么有3个子节点 2-3树是由2节点和3节点狗=构成的树 B+树B+树是B树的变体，也是一种多路搜索树 B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的 不可能在非叶子结点命中 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层 更适合文件索引系统 B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然 B*树B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针 B树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2 从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高 "},{"title":"10大常用算法","date":"2021-06-28T16:00:00.000Z","url":"/2021/06/29/2021-06-29-10%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"二分查找算法(非递归) 前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 1)二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 &lt; 100 &lt; 2^7) 代码实现数组 {1,3, 8, 10, 11, 67, 100}, 编程实现二分查找， 要求使用非递归的方式完成 分治算法 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)…… 分治算法可以求解的一些经典问题： 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔 基本步骤分治法在每一层递归上都有三个步骤 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 合并：将各个子问题的解合并为原问题的解 汉诺塔汉诺塔游戏的演示和思路分析 如果是有一个盘， A-&gt;C 如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘 先把 最上面的盘 A-&gt;B 把最下边的盘 A-&gt;C 把B塔的所有盘 从 B-&gt;C 代码实现 动态规划算法动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 ) 动态规划可以通过填表的方式来逐步推进，得到最优解 背包问题 要求达到的目标为装入的背包的总价值最大，并且重量不超出 要求装入的物品不能重复 思路分析背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用) 这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包 算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i] [j]表示在前i个物品中能够装入容量为j的背包中的最大价值 KMP算法 KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法 Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法 KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间 字符串匹配问题有一个字符串 str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2=”ABCDABD” 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 要求：使用KMP算法完成判断，不能使用简单的暴力匹配算法 KMP算法相关文章链接 贪心算法贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果 集合覆盖问题假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号 思路分析目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合： 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） 将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉 重复第1步直到覆盖了全部的地区 普利姆算法最小生成树（MST） 给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 N个顶点，一定有N-1条边 包含全部顶点 N-1条边都在图中 主要应用于普利姆算法&amp;克鲁斯卡尔算法 普利姆算法介绍普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图 步骤 设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1 若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1 重复步骤2，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边 修路问题 有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里 如何修路保证各个村庄都能连通，并且总的修建公路总里程最短? 克鲁斯卡尔算法 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法 基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路 具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止 图解： 假设，用数组R保存最小生成树结果 克鲁斯卡尔算法需解决的问题： 问题一 对图的所有边按照权值大小进行排序。 问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路 问题一，使用排序算法即可解决 问题二，处理方式是：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路 城市公交站问题 新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通 各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短? "},{"title":"哈夫曼树","date":"2021-06-21T16:00:00.000Z","url":"/2021/06/22/2021-6-22-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"哈夫曼树给定n个权值作为n个叶子节点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree) 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1 结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树 WPL最小的就是赫夫曼树 实例将数列[13，7，8，3，29，6，1]，转成一颗哈夫曼树 思路分析 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树 取出根节点权值最小的两颗二叉树 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树 哈夫曼编码哈夫曼编码是哈夫曼树在电讯通信中的经典应用之一 哈夫曼编码广泛的用于数据文件压缩。其压缩率通常在20%-90%之间 哈夫曼码是可变字长编码(VLC)的一种Huffman于1952年提出一种编码方法，称之为最佳编码 通信领域中信息的处理方式-定长编码 将字符转换为ASCII码二进制形式来传递信息 通信领域中信息的处理方式-变长编码 统计各字符对应的个数，按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小 比如一串字符中出现了：d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 “ ”:9 ，那么每个字符对应的编码为：0=“ ” , 1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d 字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码 通信领域中信息的处理方式-赫夫曼编码 d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 “ ”:9 按照上面字符出现的次数构建一颗哈夫曼树，次数作为权值 注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的, 比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树为： "},{"title":"哈希表","date":"2021-06-08T16:00:00.000Z","url":"/2021/06/09/202169-%E5%93%88%E5%B8%8C%E8%A1%A8/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"哈希表散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 实例有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的id时,要求查找到该员工的所有信息. 要求： 不使用数据库,速度越快越好=&gt;哈希表(散列) 添加时，保证按照id从低到高插入 使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息]。实现增删改查。 代码实现"},{"title":"二叉树","date":"2021-06-08T16:00:00.000Z","url":"/2021/06/09/202169-%E4%BA%8C%E5%8F%89%E6%A0%91/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"二叉树数组存储方式优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低 链式存储方式优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好) 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 树存储方式能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度 树的常用术语 节点 根节点 父节点 子节点 叶子节点(没有子节点的节点) 节点的权(节点值) 路径(从root节点找到该节点的路线) 层 子树 树的高度(最大层数) 森林：多颗子树构成森林 二叉树概念树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树 二叉树的子节点分为左节点和右节点 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树 二叉树遍历步骤前序遍历: 先输出当前节点(初始的时候就是root节点) 如果左子节点不为空，则递归继续前序遍历 如果右子节点不为空，则递归继续前序遍历 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树 如果当前节点的左子节点不为空，则递归中序遍历 输出当前节点 如果当前节点的右子节点不为空，则递归中序遍历 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点 如果当前节点的左子节点不为空，则递归后序遍历 如果当前节点的右子节点不为空，则递归后序遍历 输出当前节点 代码实现 二叉树查找思路分析前序查找 先判断当前节点的no是否等于要查找的 如果相等则返回该节点 如果不等，则判断当前节点的左子节点是否为空，如果不为空，则递归前序查找 如果左递归前序查找，找到节点，则返回，否则继续判断，当前的节点的右子节点是否为空，如果不为空则继续向右递归前序查找 中序查找 判断当前节点的左子节点是否为空，如果不为空，则递归中序查找 如果找到，则返回，如果没有找到，就和当前节点比较，如果是则返回当前节点，否则继续进行右递归的中序查找 如果右递归中序查找，找到就返回，否则返回null 后序查找 判断当前节点的左子节点是否为空，如果不为空，则递归后序查找 如果找到就返回，如果没有找到，就判断当前节点的右子节点是否为空，如果不为空，则右递归进行后序查找，如果找到就返回 和当前节点进行比较，如果是则返回，否则返回null 代码实现 二叉树删除 如果删除的节点是叶子节点，则删除该节点 如果删除的节点是非叶子节点，则删除该子树 代码实现 顺序存储二叉树从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换为树，树也可以转换成数组。 特点： 顺序二叉树通常只考虑完全二叉树 第n个元素的左子节点为n*2+1 第n个元素的右子节点为n*2+2 第n个元素的父节点为(n-1)/2 n：表示二叉树中的第几个元素(按0开始编号) 实例给出一个数组[1,2,3,4,5,6,7],要求以二叉树前序遍历形式进行遍历。 前序遍历的结果应当为[1,2,4,5,6,7] 代码实现 线索化二叉树基本介绍 当对此二叉树进行中序遍历时，数列为[8,3,10,1,6,14]。但是，6、8、10、14这几个节点的左右指针，并没有完全的利用上 可以利用线索化二叉树来让各个节点指向自己的前后节点 n个节点的二叉链表中含有n+1【公式2n-（n-）=n+】个空指针域。利用二叉链表中的空指针域，存放指向该节点在某种遍历次序下的前驱和后继节点的指针(附加的指针称为线索) 这种加上了线索的二叉树表称为线索链表，相应的二叉树称为线索二叉树。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后续线索二叉树三种 一个节点的前一个节点，称为前驱节点 一个结点的后一个节点，称为后继节点、 应用实例将图片的二叉树进行中序线索二叉树。中序遍历的数列为[8,3,10,1,14,6] 当线索化二叉树后，Node节点的 属性 left 和 right ，有如下情况 left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点 right指向的是右子树，也可能是指向后继节点，比如 ① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点 代码实现 遍历线索化二叉树代码实现 堆排序堆排序是利用“堆”这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O（nlogn）,它也是不稳定排序。 堆是具有以下性质的完全二叉树：每个节点的值都大于或等于其左右孩子节点的值，成为大顶堆。反之，称为小顶堆 大顶堆 我们对堆中的结点按层进行编号，映射到数组中 小顶堆与之相反 一般升序用大顶堆，降序用小顶堆 基本思想 将待排序序列构造成一个大顶堆 此时，整个序列的最大值就是堆顶的根节点 将其与末尾元素进行交换，此时末尾就是最大值 将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行 实例将数组[4,6,8,5,9]使用堆排序法，将数组升序排序 "},{"title":"查找算法","date":"2021-06-03T16:00:00.000Z","url":"/2021/06/04/202164-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"线性查找算法从给定的数组中逐个查找，直到找到目标，返回该数值下标 代码实现 二分查找算法代码实现 插值查找算法插值查找算法原理介绍插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找 将折半查找中的求mid索引的公式，low表示左边索引，high表示右边索引，key就是需要查找的值‘findVal’ 将 改成 代码实现 注意： 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快 关键字分布不均匀的情况下，该方法不一定比折半查找要好 斐波那契查找算法（黄金分割法）黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比 斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618 斐波那契原理斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1（F代表斐波那契数列） 对F(k-1)-1的理解由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1** 。该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如上图所示。从而中间位置为mid=low+F(k-1)-1 类似的，每一子段也可以用相同的方式分割 但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可 代码实现请对一个有序数组进行斐波那契查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标 "},{"title":"递归","date":"2021-06-01T16:00:00.000Z","url":"/2021/06/02/202162-%E9%80%92%E5%BD%92/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"递归概念简单地说，递归就是方法自己调用自己，每次调用时传入不同的变量。 递归有助于解决复杂的问题，同时可以让代码变得简洁 递归调用机制递归调用规则 当程序执行到一个方法时，就会开辟一个独立的空间(栈) 每个空间的数据(局部变量)，是独立的 代码演示 递归可以解决的问题 各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等 将用栈解决的问题–&gt;第归代码比较简洁 递归需要遵守的规则 1)执行一个方法时，就创建一个新的受保护的独立空间(栈空间) 方法的局部变量是独立的，不会相互影响 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError 当一个方法执行完毕，或者遇到return，就会返回。遵守谁调用就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕 迷宫问题模拟小球绕过迷宫走到终点的过程 用数组来模拟迷宫先创建一个二维数组来模拟迷宫，大小为8行7列 main方法中： 使用递归回溯给小球找路 map表示地图 i、j 表示从地图的哪个位置开始出发(1,1) 如果小球能到[6][5]位置，则说明通路找到 约定：当map[i][j]为0表示该点没有走过，为1表示墙，为2表示通路可以走，为3表示该点已经走过，但是走不通 再走迷宫时，需要指定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 主类中： 使用递归回溯找路main方法中： 八皇后问题（回溯算法）问题介绍八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 思路分析 第一个皇后先放第一行第一列 第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适 继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到 然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 代码实现说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，arr[i] = val , val 表示第i+1个皇后，放在第i+1行的第val+1列 定义变量 方法：将皇后摆放位置输出 方法：检测该皇后是否和前面已经摆放的皇后冲突 方法：放置皇后 main方法测试 "},{"title":"排序算法","date":"2021-06-01T16:00:00.000Z","url":"/2021/06/02/202162-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"排序算法介绍排序也称排序算法 (Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。 排序的分类 内部排序： 指将需要处理的所有数据都加载到内部存储器中进行排序 外部排序： 数据量过大，无法全部加载到内存中，需要借助外部存储进行排序 算法的时间复杂度度量一个程序(算法)执行时间的两种方法事后统计的方法这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快 事前估算的方法通过分析某个算法的时间复杂度来判断哪个算法更优 时间频度一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n) 例如： 计算1-100所有数字之和，设计两种算法 T(n)=n+1;(表示运行了n+1次) T(n)=1 计算时间复杂度 结论： 2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略1)2n+20 和 2n 随着n 变大，执行曲线无限接近, 20可以忽略 3n+10 和 3n 随着n 变大，执行曲线无限接近, 10可以忽略 结论： 1)2n^2+3n+10 和 2n^2 随着n 变大, 执行曲线无限接近, 可以忽略 3n+10 1)n^2+5n+20 和 n^2 随着n 变大,执行曲线无限接近, 可以忽略 5n+20 结论： 随着n值变大，5n^2+7n 和 3n^2 + 2n ，执行曲线重合, 说明 这种情况下, 5和3可以忽略 而n^3+5n 和 6n^3+4n ，执行曲线分离，说明多少次方式关键 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度 T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。 计算时间复杂度的方法： 用常数1代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1 修改后的运行次数函数中，只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n² 去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²） 常见的时间复杂度 常数阶O(1)无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1) 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度 对数阶O(log2n) 在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n) 。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) 线性阶O(n) 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度 线性对数阶O(nlogN) 线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN) 平方阶O(n²) 平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(nn)，即 O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(mn) 立方阶O(n³)、K次方阶O(n^k)参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似 平均时间复杂度和最坏时间复杂度 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。 平均时间复杂度和最坏时间复杂度是否一致，和算法有关 算法的空间复杂度类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间 冒泡排序冒泡排序介绍冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 代码实现 冒泡排序优化因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较 选择排序选择排序介绍选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的 选择排序思想选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]–arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]–arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]–arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]–arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]–arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列 代码实现 插入排序插入排序介绍插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的 插入排序思想插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表 代码实现 希尔排序介绍简单插入排序存在的问题数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是： {2,3,4,5,6,6} {2,3,4,5,5,6} {2,3,4,4,5,6} {2,3,3,4,5,6} {2,2,3,4,5,6} {1,2,3,4,5,6} 说明当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响 希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。 希尔排序法基本思想希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 代码实现(交换式) 代码实现(移位式) 快速排序介绍快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 代码实现 归并排序介绍归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 代码实现 基数排序介绍基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法 基数排序(Radix Sort)是**桶排序**的扩展 基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较 基本思想将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列 将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序 代码实现"},{"title":"链表&栈","date":"2021-05-28T16:00:00.000Z","url":"/2021/05/29/%E9%93%BE%E8%A1%A8&%E6%A0%88/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"链表链表是有序的列表，但是在内存中储存如下 链表是以结点的方式来存储，是链式存储 每个节点包含data域，next域：指向下一个节点 链表的节点不一定是连续存储 链表分带头节点的链表和没有头节点的链表 单链表单链表（带头结点）逻辑结构示意图 应用实例使用带head头的单向链表实现 –水浒英雄排行榜管理 添加添加英雄时，直接添加到链表的尾部 先创建一个head头节点，作用就是表示单链表的头 后面每添加一个节点，就直接加入到链表的最后 遍历 通过一个辅助变量遍历，帮助遍历整个链表 代码实现 添加（优化）添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，添加失败，并给出提示) 首先找到新添加的节点的位置, 是通过辅助变量(指针), 通过遍历来解决 新的节点.next = temp.next 将temp.next = 新的节点 代码实现加入实现方法 测试 修改思路 先找到该节点，通过遍历 修改英雄的属性 temp.name=newHeroNode.name; temp nickname=newHeroNode.nickname 加入实现方法 测试 删除节点思路分析 我们先找到 需要删除的这个节点的前一个节点 temp temp.next = temp.next.next 被删除的节点，将不会有其它引用指向，会被垃圾回收机制回收 代码实现加入实现方法 测试 练习一求单链表中有效结点的个数 测试 练习二查找单链表中倒数第k个节点 测试 练习三将单链表反转 测试 练习四 逆序打印单链表 测试 双向链表管理单向列表的缺点 单向链表，查找的方向只能是一个方向，而双向链 表可以向前或者向后查找 单向链表不能自我删除，需要靠辅助节点 ，而双向 链表，则可以自我删除，所以前面我们单链表删除 时节点，总是找到temp,temp是待删除节点的前一 个节点 应用实例使用带head头的双向链表实现 –水浒英雄排行榜 代码实现 单向环形链表 约瑟夫问题Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。 提示： 用一个不带头节点的循环链表来处理Josephu问题：先构成一个有n个节点的单循环链表，然后由k节点起从1开始计数，计到m时，对应节点从链表中删除，然后再从被删除节点的下一个节点又从1开始计数，直到最后一个结点从链表中删除算法结束。 思路分析构建一个单向环形链表 先创建第一个节点, 让 first 指向该节点，并形成环形 后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可 遍历环形链表 先让一个辅助指针(变量) curBoy，指向first节点 然后通过一个while循环遍历 该环形链表即可 curBoy.next == first 结束 步骤： 需求创建一个辅助指针(变量)helper,事先应该指向环形链表的最后这个节点 取出节点前，先让 first 和 helper 移动 k - 1次 这时就可以将first 指向节点取出 first = first .next helper.next = first 原来first 指向的节点就没有任何引用，就会被回收 栈（stack）介绍 栈是一个先入后出的有序列表 栈是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊的线性表。允许插入和删除的一端，为变化的一端，成为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom) 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除 入栈 出栈 应用场景 子程序的调用，在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中 处理递归调用：和子程序的调用类似，只是除了存储下一个指令的地址外，也将参数、区域变量等数据存入堆栈中 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决) 二叉树的遍历 图形的深度优先(depth-first)搜索法 数组模拟栈的使用使用数组模拟栈的使用，由于栈是一种有序列表，可以使用数组的结构来存储栈的数据内容 思路分析 使用数组来模拟 定义一个top来表示栈顶，初始化为-1 入栈的操作：当有数据加入到栈时，top++;stack[top]=data; 出栈的操作：int value=stack[top];top–,return value 代码实现 链表模拟栈的使用栈实现综合计算器(中缀表达式)思路分析 通过一个 index 值（索引），来遍历我们的表达式 创建两个栈，一个存放数字，一个存放操作符. 如果我们发现是一个数字,就直接入数栈. 如果发现扫描到是一个符号, 就分如下情况: 如果发现当前的符号栈为 空，就直接入栈 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符， 就需要从数栈中pop出两个数,再从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈. 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行. 最后在数栈只有一个数字，就是表达式的结果. 代码实现 前缀、中缀、后缀表达式(逆波兰表达式)前缀表达式(波兰表达式)前缀表达式又称为逆波兰表达式，前缀表达式的操作符位于操作数之前 例如：(3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 前缀表达式的计算机求值从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 针对前缀表达式求值步骤如下: 从右至左扫描，将6、5、4、3压入堆栈 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈 最后是-运算符，计算出35-6的值，即29，由此得出最终结果 中缀表达式中缀表达式就是常见的运算表达式 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式) 后缀表达式后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后 例如：(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 – 后缀表达式的计算机求值从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 步骤： 初始化两个栈：运算符栈s1和储存中间结果的栈s2； 从左至右扫描中缀表达式； 遇到操作数时，将其压s2； 遇到运算符时，比较其与s1栈顶运算符的优先级： 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈； 否则，若优先级比栈顶运算符的高，也将运算符压入s1； 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较； 遇到括号时： 如果是左括号“(”，则直接压入s1 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 重复步骤2至5，直到表达式的最右边 将s1中剩余的运算符依次弹出并压入s2 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 例如：1 + ( ( 2 + 3 )× 4) - 5转为后缀表达式 图示： 逆波兰计算器（计算后缀表达式）输入一个后缀表达式(逆波兰表达式)，使用栈(Stack)，计算其结果 支持对整数的计算 思路分析例如：(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 – 步骤： 从左至右扫描，将3和4压入堆栈； 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈； 将5入栈； 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 将6入栈； 最后是-运算符，计算出35-6的值，即29，由此得出最终结果 代码实现 逆波兰计算器(中缀转后缀表达式后计算)思路分析和后缀表达式的计算机求值步骤相同 代码实现"},{"title":"稀疏数组&队列","date":"2021-05-26T16:00:00.000Z","url":"/2021/05/27/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84&%E9%98%9F%E5%88%97/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["数据结构","/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"]],"categories":[["Java","/categories/Java/"]],"content":"数据结构和算法概述关系程序=数据结构+算法 数据结构是算法的基础 实际问题五子棋程序 棋盘：二维数组=&gt;（稀疏数组）=&gt;写入文件【存档功能】 读取文件=&gt;稀疏数组=&gt;二维数组=&gt;棋盘【接上局】 约瑟夫(Josephu)问题(丢手帕问题) 问题为：设编号为1，2，3…n的·n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m的那个人出列，他的下一位又从1开始报数，数到m的那个人又出列，以此类推，直到所有人出列为止，由此产生一个出队编号的序列 提示：用一个不带头结点的循环链表来处理Josephu问题：先构成一个有n个结点的单循环链表(单向环形链表)，然后由k结点起从1开始计数，计到m时，对应节点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。 总结：完成约瑟夫问题，需要使用到单向循环链表 其他算法常见问题 修路问题=&gt;最小生成树（加权值）【数据结构】+普利姆算法 最短路径问题=&gt;图+佛洛依德算法 汉诺塔=&gt;分支算法 八皇后问题=&gt;回溯法 线性结构&amp;非线性结构数据结构包括：线性结构和非线性结构 线性结构最常用的数据结构，特点是数据元素之间存在一对一的线性关系。 线性结构有两种不同的存储结构：**顺序存储结构(数组)和链式存储结构(链表)**。 顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息 线性结构常见的有：数组、队列、链表和栈 非线性结构非线性结构包括：二维数组、多维数组、广义表、树结构、图结构 稀疏数组和队列稀疏(sparsearray)数组实际需求五子棋程序中，存盘退出和继续上盘的功能 分析问题可以将五子棋盘看成是一个二维数组来记录棋盘。但是，该二维数组中，很多棋盘上对应的位置并没有数据，因此记录了很多为没有意义的数据。 处理方法当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 记录数组一共有几行几列，有多少个不同的值 把具有不同值的元素的行列及值记录在一个小规模数组中，从而缩小程序规模 应用实例 使用稀疏数组，来保留类似前面的二维数组(棋盘，地图等等) 把稀疏数组存盘，并且可以从新恢复原来的二维数组数 思路分析二维数组转稀疏数组的思路 遍历原始的二维数组，得到有效数据的个数sum 根据sum就可以创建稀疏数组sparseArr int[sum+1] [3] 将二维数组的有效数据存入到稀疏数组 稀疏数组转原始的二维数组的思路 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 再读取稀疏数组后几行的数据，并赋给原始的二维数组即可 代码实现 队列介绍队列是一个有序列表，可以用数组或是链表来实现 遵循先入先出的原则：先存入的队列的数据，要先取出。后存入的数据要后取出 数组模拟队列思路队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下，其中MaxSize是该队列的最大容量 因为队列的输出、输入是分别从前后端来处理的，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据输入而改变 当我们将数据存入队列时称为“addQueue”,addQueue的处理需要有两个步骤： 将位置向后移：rear+1，当front==rear时，队列数据为空。 若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear==maxSize-1，表示队列数据已满 代码实现 问题分析&amp;优化问题：假溢出现象 因为队列遵从从队尾存入数据，从队头取数据，所以出队部分的空间就不能继续存入新的数据，此时队列有多余的空间，却不能存入值，这种现象就叫做假溢出现象 将这个数组使用算法，改进成一个环形队列（取模：%） 优化：数组模拟环形队列环形队列思想将普通队列想象成逻辑上的首位相连的圆环，把这个叫循环队列，在循环队列中，当队列为空时，有front=rear，而当所有队列空间全占满时，也有front=rear。为了区别这两种情况，规定循环队列最多只能有MaxSize-1个队列元素，当循环队列中只剩下一个空存储单元时，队列就已经满了。因此，队列判空的条件是front=rear，而队列判满的条件是front=(rear+1)%MaxSize。 分析思路 front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，初值为0 rear变量的含义做一个调整：rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定，初值为0 队列满时条件为：(rear+1)%maxSize==front 当队列为空时：rear==front 这样分析时，队列中有效数据的个数：(rear+maxSize-front)%maxSize 这样就可以修改得到一个数组模拟的环形队列 代码实现"},{"title":"SSM整合","date":"2021-05-24T16:00:00.000Z","url":"/2021/05/25/SSM%E6%95%B4%E5%90%88/","categories":[["SSM","/categories/SSM/"]],"content":"SSM整合导包Spring SpringMVC MyBatis 其他 写配置web.xml配置 Spring配置 SpringMVC MyBatis配置整合关键配置(写在Spring.xml中) 目录结构"},{"title":"Mybatis","date":"2021-05-16T16:00:00.000Z","url":"/2021/05/17/Mybatis/","categories":[["ssm","/categories/ssm/"]],"content":"简介 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录 JDBC中，SQL夹在Java代码块里，耦合度高导致硬编码内伤。–维护不易且实际开发需求中sql是有变化，频繁修改的情况多见。 Hibernate和JPA中，长难复杂SQL，对于Hibernate而言处理也不容易。内部自动生产的SQL，不容易做特殊优化。基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。导致数据库性能下降。 对于核心开发人员而言，核心sql还是需要自己优化，sql和java代码分开，功能边界清晰，一个专注业务，一个专注数据。 环境搭建 创建一个java工程 创建测试库，测试表，以及封装数据的javaBean，和操作数据库的dao接口 用MyBatis操作数据库 导包 mybatis-3.4.1.jar mysql-connector-java-8.0.23.jar log4j-1.2.17.jar（日志包：在MyBatis关键的环节就会有日志打印，依赖类路径下的log4j.xml配置文件） 写配置 第一个配置文件：称为mybatis的全局配置文件，指导mybatis如何正确运行，比如连接向哪个数据库 第二个配置文件：编写每一个方法都如何向数据库发送sql语句，如何执行。相当于接口的实现类 将mapper的namespace属性改为接口的全类名 配置细节 此时写的dao接口实现文件，mybatis默认是不知道的，需要在全局配置文件中注册 测试 根据全局配置文件先创建一个 sqlSessionFactory中获取sqlSession对象操作数据库即可 目录结构： 全局配置文件：mybatis-config.xml；指导mybatis正确运行的一些全局设置 SQL映射文件：EmployeeDao.xml；相当于是对Dao接口的一个实现描述细节： 获取到的是接口的代理对象；mybatis自动创建的 SqlSessionFactory和SqlSession： SqlSessionFactory创建SqlSession对象，Factory只new一次就行 SqlSession：相当于connection和数据库进行交互的，和数据库的一次会话，就应该创建一个新的sqlSession 全局配置文件（Configuration配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） properties(属性)和Spring的context：property-placeholder作用相同：引用外部配置文件 resource:从类路径下开始引用 url:引用磁盘路径或者网络路径的资源 daconfig.properties中： settings(设置)settings这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为 typeAliases(类型命名)类型别名:为常用的类型（javaBean）起别名 mappers(映射器)写好的sql映射文件需要使用mappers注册进来 class:直接引用接口的全类名(需要将xml放在和dao接口同目录下，而且文件名和接口名一致)resource:在类路径下找sql映射文件url:可以从磁盘或者网络路径引用 EmployeeDao.xml class的另一种用法： EmployeeDaoAnnotation.xml 推荐配合使用， 重要的dao可以写配置简单的dao直接标注解 SQL映射文件映射文件指导着MyBatis如何进行数据库增删改查，有着非常重要的意义 映射文件中能写的所有标签： cache:命名空间的二级缓存配置 cache-ref:其他命名空间缓存配置的引用 resultMap:自定义结果集映射 parameterMap:已废弃！老式风格的参数映射 sql:抽取可重用语句块 delete、update、insert、select:增删改查 delete、update、insert属性： 参数获取自增主键若数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），则可以设置 useGeneratedKeys=”true”**，然后再把 **keyProperty 设置到目标属性上。 因为employee在new对象的时候就是null值，所以获取id时也为空值。 让MyBatis自动的将自增id赋给传入的employee对象的id属性： useGeneratedKeys=”true”：使用自动生成的主键 keyProperty=””：将刚才自增的id封装给哪个属性 获取非自增主键而对于不支持自增型主键的数据库（例如 Oracle），则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用 参数传递单个参数基本类型：#{随便写} 多个参数任意多个参数，都会被MyBatis重新包装成一个Map传入。Map的key是param1，param2，0，1…，值就是参数的值。 错误取值：#{参数名} 正确写法：0，1（参数索引）或param1,param2（第几个参数paramN…） 原因：只要传入了多个参数：myBatis会自动的将这些参数封装在一个map中，封装时使用的key就是参数的索引和参数的param优化写法：在方法参数前使用@Param(“参数名”)，为参数指定id POJO当这些参数属于我们业务POJO时，我们直接传递POJO 取值：#{pojo的属性名} Map我们也可以封装多个参数为map，直接传递 取值：#{key} #{key}：获取参数的值，预编译到SQL中。安全。 ${key}：获取参数的值，拼接到SQL中。有SQL注入问题。ORDER BY ${name}(在不支持预编译的位置要进行取值就用${key}) 参数处理#{key}取值的时候可以设置一些规则： 支持的属性：javaType、jdbcType、mode、numericScale、 resultMap、typeHandler、jdbcTypeName、expression 注：JDBC 要求，如果一个列允许使用 null 值，并且会使用值为 null 的参数，就必须要指定 JDBC 类型（jdbcType） selectSelect元素来定义查询操作。 insert、update、delete ResultMap constructor- 用于在实例化类时，注入结果到构造方法中 idArg - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能 arg - 将被注入到构造方法的一个普通结果 id – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能 result – 注入到字段或 JavaBean 属性的普通结果 association– 一个复杂类型的关联；许多结果将包装成这种类型 嵌套结果映射 – 关联可以是 resultMap 元素，或是对其它结果映射的引用 collection– 一个复杂类型的集合 嵌套结果映射 – 集合可以是 resultMap 元素，或是对其它结果映射的引用 discriminator– 使用结果值来决定使用哪个 resultMap case– 基于某些值的结果映射 嵌套结果映射 – case 也是一个结果映射，因此具有相同的结构和元素；或者引用其它的结果映射 id&amp;resultid 和 result 映射一个单独列的值到简单数据类型(字符串,整型,双精度浮点数,日期等)的属性或字段 association(关联)POJO中的属性可能会是一个对象 可以使用联合查询，并以级联属性的方式封装对象 使用association标签定义对象封装规则 嵌套结果集 分段查询 select:调用目标的方法查询当前属性的值 column:将指定列的值传入目标方法 延迟加载 Collection-集合类型&amp;嵌套结果集 分布查询 动态sqlif标签if 标签通常用于 WHERE 语句、UPDATE 语句、INSERT 语句中，通过判断参数值来决定是否使用某个查询条件、判断是否更新某一个字段、判断是否插入某个字段的值。 foreach标签foreach 标签主要用于构建 in 条件，可在 sql 中对集合进行迭代。也常用到批量删除、添加等操作中。 collection:指定要遍历的集合的key close:以什么结束 index:索引 如果遍历的是list： index:指定的变量保存了当前索引 item:保存当前遍历的元素的值 如果便利的是map: index：指定的变量就是保存了当前遍历的元素的key item：就是保存当前遍历的元素的值 item:每次遍历出的元素起一个变量名方便引用 open:以什么开始 separator:每次遍历元素的分隔符 choose标签MyBatis 提供了 choose 元素，按顺序判断 when 中的条件出否成立，如果有一个成立，则 choose 结束。当 choose 中所有 when的条件都不满则时，则执行 otherwise 中的 sql。类似于 Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。 if 是与(and)的关系，而 choose 是或（or）的关系。 set标签没有使用 if 标签时，如果有一个参数为 null，都会导致错误。当在 update 语句中使用 if 标签时，如果最后的 if 没有执行，则或导致逗号多余错误。使用 set 标签可以将动态的配置 set关键字，和剔除追加到条件末尾的任何不相关的逗号。 trim标签格式化输出，可以设置或忽略前后缀 where标签 当 name 值为 null 时，查询语句会出现 “WHERE AND” 的情况，解决该情况除了将”WHERE”改为“WHERE 1=1”之外，还可以利用 where标签。这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以 AND 或 OR 开头的，则它会剔除掉。 抽取可重用sql 在之后的方法中加入： 即可省略重复的sql语句 缓存暂时的存储一些数据；加快系统的查询速度 MyBatis缓存机制： Map；能保存查询出的一些数据； 一级缓存：线程级别的缓存；本地缓存；SqlSession级别的缓存； 二级缓存：全局范围的缓存；除过当前线程；SqlSession能用外其他也可以使用； 一级缓存MyBatis：SqlSesion级别的缓存；默认存在； 机制：只要之前查询过的数据，mybatis就会保存在一个缓存中（Map）；下次获取直接从缓存中拿； 一级缓存失效的情况： 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存 二级缓存namespace级别的缓存 一级缓存；SqlSession关闭或者提交以后，一级缓存的数据会放在二级缓存中；MyBatis默认关闭，需手动开启 配置某个dao.xml文件，让其使用二级缓存 缓存原理 全局setting的cacheEnable：配置二级缓存的开关。一级缓存一直是打开的。 select标签的useCache属性：配置这个select是否使用二级缓存。一级缓存一直是使用的 sql标签的flushCache属性：增删改默认flushCache=true。sql执行以后，会同时清空一级和二级缓存。查询默认flushCache=false。 sqlSession.clearCache()：只是用来清除一级缓存。 当在某一个作用域 (一级缓存Session/二级缓存Namespaces) 进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被clear。 整合第三方缓存整合ehcache 导包 ehcache-core-2.6.8.jar(ehcache核心包) mybatis-ehcache-1.0.3.jar(ehcache的整合包) slf4j-api-1.7.21.jar slf4j-log4j12-1.7.21.jar ehcache要工作有一个配置文件 文件名叫ehcache.xml；放在类路径的根目录下 在mapper.xml中配置使用自定义的缓存 别的dao还要用这个缓存 缓存引用cache-ref "},{"title":"SpringMVC2","date":"2021-05-15T16:00:00.000Z","url":"/2021/05/16/SpringMVC2/","categories":[["ssm","/categories/ssm/"]],"content":"数据绑定流程： Spring MVC 主框架将 ServletRequest 对象及目标方法的参数实例传递给 WebDataBinderFactory 实例，以创建 DataBinder 实例对象 DataBinder 调用装配在 Spring MVC 上下文中的 ConversionService 组件进行数据类型转换、数据格式化工作。将 Servlet 中的请求信息填充到参数对象中 调用 Validator 组件对已经绑定了请求消息的参数对象进行数据合法性校验，并最终生成数据绑定结果 BindingData 对象 Spring MVC 抽取 BindingResult 中的入参对象和校验错误对象，将它们赋给处理方法的响应参数 数据转换Spring MVC 上下文中内建了很多转换器，可完成大多数 Java 类型的转换工作 自定义类型转换器 ConversionService:是一个接口。它里面有Converter（转换器）进行工作 Converter是ConversionService中的组件 实现过程： 自定义的Converter得放进ConversionService 中 将WebDataBinder中的ConversionService设置成我们这个加了自定义类型转换器的ConversionService 步骤： 实现Converter接口，写一个自定义的类型转换器 配置出ConversionService 让SpringMVC用自定义的ConversionService 源码上WebDataBinder上的ConversionService组件就会被替换 &lt;mvc:annotation-driven /&gt; &lt;mvc:annotation-driven /&gt; 会自动注册RequestMappingHandlerMapping 、RequestMappingHandlerAdapter 与 ExceptionHandlerExceptionResolver 三个bean。 还将提供以下支持： 支持使用 ConversionService 实例对表单参数进行类型转换 支持使用 @NumberFormat annotation、@DateTimeFormat注解完成数据类型的格式化 支持使用 @Valid 注解对 JavaBean 实例进行 JSR 303 验证 支持使用 @RequestBody 和 @ResponseBody 注解 数据格式化 FormattingConversionServiceFactroyBean 内部已经注册了 : NumberFormatAnnotationFormatterFactroy：支持对数字类型的属性使用 @NumberFormat 注解 JodaDateTimeFormatAnnotationFormatterFactroy：支持对日期类型的属性使用 @DateTimeFormat 注解 装配了 FormattingConversionServiceFactroyBean 后，就可以在 Spring MVC 入参绑定及模型数据输出时使用注解驱动了&lt; mvc:annotation-driven/&gt;默认创建的ConversionService 实例即为 FormattingConversionServiceFactroyBean 例 数据校验只做前端校验是不安全的；在重要数据一定要加上后端验证 JSR303 JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 中 JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证 后端校验 导入校验框架的jar包–Hibernate Validator 有几个带el的jar不导入；tomcat中有；如果tomcat的版本是* 7.0以下；tomcat7.0以上el表达式比较强大 ，如果是7.0以下将带el的几个jar放在tomcat的lib文件夹下 只需要给javaBean的属性添加上校验注解 在SpringMVC封装对象的时候，告诉SpringMVC这个javaBean需要校验 校验结果 给需要校验的javaBean后面紧跟一个BindingResult。这个BindingResult就是封装前一个bean的校验结果 来到页面使用form:errors取出错误信息即可 Hibernate-Validator拓展 国际化定制自己的错误消息显示 编写国际化配置文件 让SpringMVC管理国际化资源文件 来到页面取值 拦截器SpringMVC提供了拦截器机制；允许运行目标方法之前进行一些拦截工作，或者目标方法运行之后进行一些其他处理。 preHandle：在目标方法运行之前调用 postHandle：在目标方法运行之后调用 afterCompletion：在请求整个完成之后 步骤： 实现HandlerInterceptor接口 配置拦截器 拦截器的运行流程 正常运行流程： 拦截器的preHandle——目标方法—–拦截器postHandle—–页面——-拦截器的afterCompletion 其他流程： 只要preHandle不放行就没有以后的流程 只要放行了，afterCompletion都会执行 多个拦截器： 正常流程： 异常流程： MySecondInterceptor不放行；但是他前面已经放行了的拦截器的afterCompletion总会执行 流程： filter的流程； 拦截器的preHandle：是按照顺序执行 拦截器的postHandle：是按照逆序执行 拦截器的afterCompletion：是按照逆序执行； 已经放行了的拦截器的afterCompletion总会执行； 异常处理默认就是这几个 HandlerExceptionResolver ExceptionHandlerExceptionResolver ResponseStatusExceptionResolver DefaultHandlerExceptionResolver 如果异常解析器都不能处理就直接抛出去 配置文件中写入 自定义异常 controller 告诉SpringMVC这个方法专门处理这个类发生的异常 给方法参数中写上一个Exception，用来接收发生的异常 要携带异常信息不能给参数位置写model 返回ModelAndView即可 如果有多个@ExceptionHandler都能处理这个异常，精确优先 SpringMVC的运行流程 所有请求，前端控制器（DispatcherServlet）收到请求，调用doDispatch进行处理 根据HandlerMapping中保存的请求映射信息找到，处理当前请求的，处理器执行链（包含拦截器） 根据当前处理器找到他的HandlerAdapter（适配器） 拦截器的preHandle先执行 适配器执行目标方法，并返回ModelAndView ModelAttribute注解标注的方法提前运行 有注解 没注解 看是否是Model、Map以及其他的 如果是自定义类型 从隐含模型中看有没有，如果有就从隐含模型中拿 如果没有，再看是否SessionAttributes标注的属性，如果是从Session中拿，如果拿不到会抛异常 都不是，就利用反射创建对象 拦截器的postHandle执行 处理结果；（页面渲染流程） 如果有异常使用异常解析器处理异常；处理完后还会返回ModelAndView 调用render进行页面渲染 视图解析器根据视图名得到视图对象 视图对象调用render方法 执行拦截器的afterCompletion SpringMVC与Spring整合SpringMVC和Spring整合的目的；分工明确 SpringMVC的配置文件就来配置和网站转发逻辑以及网站功能有关的（视图解析器，文件上传解析器，支持ajax，xxx） Spring的配置文件来配置和业务有关的（事务控制，数据源，xxx） SpringMVC和Spring使用同一个容器&lt;import resource=*”spring.xml”*/&gt;：可以合并配置文件 SpringMVC和Spring分容器web.xml中配置 spring.xml中配置 springMVC.xml中配置 Spring是一个父容器，SpringMVC是一个子容器； 子容器还可以引用父容器的组件； 父容器不能引用子容器的组件；"},{"title":"SpringMVC1","date":"2021-05-14T16:00:00.000Z","url":"/2021/05/15/SpringMVC1/","categories":[["ssm","/categories/ssm/"]],"content":"概要本文章基于Spring4.x版本的SpringMVC,源码上与Spring5会有些许不同 Spring为展现层提供的基于MVC设计理念的优秀的Web框架，是目前最主流的MVC框架之一 SpringMVC通过一套MVC注解，让POJO成为处理请求的控制器，而无需实现任何接口 采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性 mvc在b/s系统下的应用： SpringMVC原理流程图： 前端控制器 DispatcherServlet 作用：接收请求，响应，也是中央转发器处理器映射器 HandlerMapping 作用：根据url查找Handler 处理器适配器 HandlerAdapter 作用：按照特定规则去执行Handler，规则即HandlerAdapter要求的规则 注意：编写Handler时需要按HandlerAdapter要求去编写，这样适配器才可以去正确执行Handler 视图解析器 ViewResolver 作用：根据逻辑视图解析成真正的视图（view） 视图 View View 是一个接口，实现类支持不同的view类型（jsp，FreeMarker，pdf，excel…) SpringMVC-Hello World步骤： 加入jar包 commons-logging-1.1.3.jar spring-aop-4.0.0.RELEASE.jar spring-beans-4.0.0.RELEASE.jar spring-context-4.0.0.RELEASE.jar spring-core-4.0.0.RELEASE.jar spring-expression-4.0.0.RELEASE.jar spring-web-4.0.0.RELEASE.jar spring-webmvc-4.0.0.RELEASE.jar 在web.xml中配置DispatcherServlet 加入Spring MVC的配置文件 编写处理请求的处理器，并标记为处理器 编写视图 @RequestMapping映射请求 Spring MVC使用@RequestMapping注解为控制器指定可以处理哪些 URL 请求 在控制器的类定义及方法定义处都可标注 类定义处：为当前类的所有方法准备一个基准路径 方法处：提供进一步的细分映射信息。相对于类定义处的 URL。若类定义处未标注 @RequestMapping，则方法处标记的 URL 相对于 WEB 应用的根目录 DispatcherServlet 截获请求后，就通过控制器上 @RequestMapping 提供的映射信息确定请求所对应的处理方法。 映射请求参数、请求方法或请求头 @RequestMapping 除了可以使用请求 URL 映射请求外，还可以使用请求方法、请求参数及请求头映射请求 RequestMapping的其他属性method限定请求方式：GET、POST 例： params规定请求参数 params:和headers支持简单表达式 param1：表示请求必须包含名为param1的请求参数 表示发送请求的时候必须带上一个名为username的参数，否则会404报错。 ！param1:表示请求不能包含名为param1的请求参数 表示发送请求的时候不能带上一个名为username的参数 param1!=value1:表示请求包含名为param1的请求参数，但其值不能为value1 表示发送请求的时候，携带的username值必须不是123（不带username或者username的值不是value） {“param1=value1”,”param2”}:请求必须包含名为param1和param2的请求参数 表示请求参数必须满足：username不是123，必须有pwd的值，不能有age headers使用User-Agent限制浏览器访问 consumes只接受内容类型是哪种的请求，规定请求头中的Content-Type produces告诉浏览器返回的内容类型是什么，给响应头中加上Content-Type:text/html;charset=utf-8 @RequestMapping模糊匹配（Ant风格）URL地址可以写模糊的通配符 通配符 作用 ？ 能代替一个字符 * 能代替多个字符，和一层路径 ** 能代替多层路径 例： 映射请求参数请求处理方法签名 Spring MVC 通过分析处理方法的签名，将 HTTP 请求信息绑定到处理方法的相应参数中 Spring MVC 对控制器处理方法签名的限制是很宽松的，几乎可以按喜欢的任何方式对方法进行签名 必要时可以对方法及方法参数标注相应的注解（ @PathVariable 、@RequestParam、@RequestHeader 等）、Spring MVC 框架会将 HTTP 请求的信息绑定到相应的方法入参中，并根据方法的返回值类型做出相应的后续处理。 @PathVariable-映射URL绑定的占位符 带占位符的URL是Spring3.0新增的功能，该功能在SprngMVC向REST目标挺进发展过程中具有里程碑的意义 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过 @PathVariable(“xxx”) 绑定到操作方法的入参中。 例 @RequestParam-获取请求参数值在处理方法参数处使用 @RequestParam 可以把请求参数传递给请求方法 value:参数名 required:是否必须。默认为true，表示请求参数中必须包含对应的参数，若不存在，将抛出异常 defaultValue:默认值，没带参数默认为null 对于路径/book/{user}?user=admin @RequestHeader-获取请求报头的属性值 请求头包含了若干个属性，服务器可据此获知客户端的信息，通过 @RequestHeader 即可将请求头中的属性值绑定到处理方法的参数中 @CookieValue-获取请求中的Cookie值 示例 使用POJO对象获取请求参数值 Spring MVC 会按请求参数名和 POJO 属性名进行自动匹配，自动为该对象填充属性值。支持级联属性 SpringMVC会自动封装Book的属性值 提交的数据可能会乱码： 请求乱码： GET请求： 改Server.xml，在8080端口处添加：URIEncoding=”UTF-8” POST请求： 在第一次获取请求参数之前设置 request.setCharacterEncoding(“UTF-8”); 响应乱码： response.setContentType(“text.html;charset=utf-8”) 使用原生API作为参数SpringMVC可以直接在参数上写原生API HttpServletRequest HttpServletResponse HttpSession java.security.Principal Locale ：国际化有关的区域信息对象 InputStream ServletInputStream inputStream = request.getInputStream(); OutputStream ServletOutputStream outputStream = response.getOutputStream(); Reader BufferedReader reader = request.getReader(); Writer PrintWriter writer = response.getWriter(); 处理模型数据SpringMVC除了在方法上原生的request和session外还能怎么样把数据带给页面? 可以在方法处传入Map、或者Model或者ModelMap,给这些参数里面保存的所有数据都会放在域中，可以在页面获取 关系： Map,Model,ModelMap,最终都是BindingAwareModelMap在工作：相当于给BindingAwareModelMap中保存的东西都会被放在请求域中 Map属于jdk中的interface model属于spring中的interface ModelMap属于Map旗下，是继承于LinkedHashMap的Class ExtendedModelMap属于继承于ModelMap实现Model接口的Class BindingAwareModelMap继承于ExtendedModelMap的Class Spring MVC 提供了以下几种途径输出模型数据： ModelAndView: 处理方法返回值类型为 ModelAndView 时, 方法体即可通过该对象添加模型数据 Map 及 Model: 入参为 org.springframework.ui.Model、org.springframework.ui.ModelMap 或 java.uti.Map 时，处理方法返回时，Map 中的数据会自动添加到模型中。 @SessionAttributes: 将模型中的某个属性暂存到 HttpSession 中，以便多个请求之间可以共享这个属性 @ModelAttribute: 方法入参标注该注解后, 入参的对象就会放到数据模型中 ModelAndView控制器处理方法的返回值如果为 ModelAndView, 则其既包含视图信息，也包含模型数据信息。 添加模型数据 设置视图 例 结果：请求域和session域中都有值 Map&amp;ModelSpring MVC 在内部使用了一个 org.springframework.ui.Model 接口存储模型数据 步骤： Spring MVC 在调用方法前会创建一个隐含的模型对象作为模型数据的存储容器。 如果方法的参数为 Map 或 Model 类型，Spring MVC 会将隐含模型的引用传递给这些参数。在方法体内，开发者可以通过这个参数对象访问到模型中的所有数据，也可以向模型中添加新的属性数据 例： Model Map @SessionAttributes 若希望在多个请求之间共用某个模型属性数据，则可以在控制器类上标注一个 @SessionAttributes, Spring MVC 将在模型中对应的属性暂存到 HttpSession 中 @SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外，还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中 例 并不推荐使用@SessionAttribute，可能会引发异常，给Session中放数据请使用原生API。 ModelAttribute 在方法定义上使用 @ModelAttribute 注解：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了 @ModelAttribute 的方法 在方法的参数前使用 @ModelAttribute注解： 可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数绑定到对象中，再传入参数 将方法参数对象添加到模型中 全字段更新问题实际开发场景中对于修改的属性，并不是全字段修改，只会修改部分字段 不修改的字段可以在页面进行展示但是不要提供修改输入框 为了简单，Controller直接在参数位置来写对象 SpringMVC为我们自动封装；（没有带的值是null） 如果接下来调用了一个全字段更新的dao操作；会将其他的字段可能变为null 全字段更新时，如何只更新页面携带数据 方法一： 修改Dao，但非常麻烦 方法二： 在保存对象的方法上加上@ModelAttribute,标注的方法会提前运行并把方法的运行结果放在隐含模型中，同时会使用一个key：如果@ModelAttribute(“key”)指定了，就用指定的key,如果没有指定就用返回值类型的首字母小写作为key 在更新方法中的参数前加上@ModelAttribute注解，key的值需要和保存对象的方法中保持一致。它可以让SpringMVC不创建对象，直接从中先取出保存的对象的信息 将请求中所有与对象对应的属性一一设置过来 使用刚才取出的对象，设置属性值（请求参数带了哪些值就覆盖之前的值） 带了的字段就改为携带的值，没带的字段就保持之前的值 将之前查到的，并且封装了请求参数的对象。进行保存 例 视图解析SpringMVC 内部最终会将返回的参数及视图名字封装成一个 ModelAndView 对象，这个对象包含两个部分：Model 是一个 HashMap 集合，View 一般则是一个 String 类型记录要跳转视图的名字或者是视图对象 SpringMVC 内部最终是借助这个 ModelAndView 对象里面的 View 来选取视图解析器，解析出视图，然后将 Model 里面的键值写进 requestScope 里面，最终呈现给客户端渲染后的视图 视图 视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户 为了实现视图模型和具体实现技术的解耦，Spring 在 org.springframework.web.servlet 包中定义了一个高度抽象的 View 接口 视图对象由视图解析器负责实例化。由于视图是无状态的，所以他们不会有线程安全的问题 常用的视图实现类 视图解析器 SpringMVC 为逻辑视图名的解析提供了不同的策略，可以在 Spring WEB 上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类 视图解析器的作用比较单一：将逻辑视图解析为一个具体的视图对象 所有的视图解析器都必须实现 ViewResolver 接口 常用的视图解析器实现类 可以选择一种视图解析器或混用多种视图解析器 每个视图解析器都实现了 Ordered 接口并开放出一个 order 属性，可以通过 order 属性指定解析器的优先顺序，order 越小优先级越高 •SpringMVC 会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则将抛出 ServletException 异常 forward指定转发操作 redirect指定重定向操作 jstlView便捷国际化导入jstl的时候会自动创建为一个jstlView，可以快速方便的支持国际化功能 javaWeb国际化步骤: 得到一个Locale对象 使用ResourceBundle绑定国际化资源文件 使用ResourceBundle.getString(“key”)；获取到国际化配置文件中的值 web页面的国际化，fmt标签库来做 &lt;fmt: setLocale&gt; &lt;fmt:setBundle &gt; &lt;fmt: message&gt; 用jstlView: 让Spring管理国际化资源就行 直接去页面使用&lt;fmt: message&gt;； 自定义视图&amp;视图解析器自定义视图和视图解析器的步骤： 编写自定义的视图解析器，和视图实现类 视图解析器必须放在ioc容器中，让其工作，能创建出我们的自定义视图对象 View层 Controller层 RESTful SpringMVC CRUDcontroller层 员工列表页面 完整源码： 链接：提取码：2333 "},{"title":"Spring5框架（事务）","date":"2021-04-24T16:00:00.000Z","url":"/2021/04/25/Spring5%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8B%E5%8A%A1%EF%BC%89/","categories":[["ssm","/categories/ssm/"]],"content":"事务操作简介 事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败 典型场景：银行转账 lucy转账100元给mary lucy少100元，mary多100元 事务特性（ACID） 原子性:事务包含的所有操作要么全部成功，要么全部失败回滚 一致性:事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态 隔离性:多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离 持久性:一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作 事务操作环境 创建数据库表，添加记录 创建 service，搭建 dao，完成对象创建和注入关系 在 dao 创建两个方法：多钱和少钱的方法，在 service 创建方法（转账的方法） 在accountMoney中手动加入异常 添加异常后，lucy少100，但因为出现异常，下面语句并没有执行，mary并没有多100.导致凭空少了100. 事务操作过程 Spring事务操作 事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层） 在 Spring 进行事务管理操作（有两种方式：编程式事务管理和声明式事务管理） 声明式事务管理（基于注解方式&amp;基于xml配置文件方式） 在 Spring 进行声明式事务管理，底层使用 AOP 原理 Spring 事务管理 API 提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类 注解声明式事务管理 在 spring 配置文件配置事务管理器 在 spring 配置文件，开启事务注解 在 spring 配置文件引入名称空间 tx 开启事务注解 在 service 类上面（或者 service 类里面方法上面）添加事务注解 @Transactional，这个注解添加到类上面，也可以添加方法上面 如果把这个注解添加类上面，这个类里面所有的方法都添加事务 如果把这个注解添加方法上面，为这个方法添加事务 管理参数配置 propagation：事务传播行为（7种） 当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行 ioslation：事务隔离级别 脏读：一个未提交事务读取到另一个未提交事务的数据 不可重复读：一个未提交事务读取到另一提交事务修改数据 一个未提交事务读取到另一提交事务添加数据 timeout：超时时间 事务需要在一定时间内进行提交，如果不提交进行回滚 默认值是 -1 ，设置时间以秒单位进行计算 readOnly：是否只读 读：查询操作，写：添加修改删除操作 readOnly 默认值 false，表示可以查询，可以添加修改删除操作 设置 readOnly 值是 true，设置成 true 之后，只能查询 rollbackFor：回滚 设置出现哪些异常进行事务回滚 noRollbackFor：不回滚 设置出现哪些异常不进行事务回滚 xml声明式事务管理 在 spring 配置文件中进行配置 配置事务管理器 配置通知 配置切入点和切面 完全注解声明式事务管理 创建配置类，使用配置类替代 xml 配置文件 编写测试类 "},{"title":"Spring5框架（AOP、JDBCTemplate）","date":"2021-04-24T16:00:00.000Z","url":"/2021/04/25/Spring5%E6%A1%86%E6%9E%B6%EF%BC%88AOP%E3%80%81JDBCTemplate%EF%BC%89/","categories":[["ssm","/categories/ssm/"]],"content":"AOP简介 AOP（Aspect-OrientedProgramming，面向切面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。 利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 不通过修改源代码方式，在主干功能里面添加新功能 底层原理AOP底层使用动态代理实现 情况一：有接口情况，使用JDK动态代理创建接口实现类代理对象，增强类的方法 使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象 调用 newProxyInstance 方法，方法有三个参数 类加载器 增强方法所在的类，这个类实现的接口，支持多个接口 实现这个接口InvocationHandler，创建代理对象，写增强的部分 编写JDK动态代理代码 创建接口，定义方法 创建接口实现类，实现方法 使用 Proxy 类创建接口代理对象 情况二：没有接口情况，使用CGLIB动态代理创建子类的代理对象，增强类的方法 Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想目标没有实现接口的类,就可以使用Cglib实现. 术语 连接点：类中的可以增强的方法 切入点：实际被增强的方法 通知（增强）：实际增强的逻辑部分 类型： 前置通知 后置通知 环绕通知 异常通知 最终通知 切面：把通知应用到切入点的过程 AOP操作Spring框架一般都是基于AspectJ实现AOP操作，AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作 切入点表达式 作用：知道对哪个类里面的哪个方法进行增强 语法结构：execution([权限修饰符] [返回类型] [类全路径] [方法名称] ([参数列表])) 例1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 execution(* com.atguigu.dao.BookDao.add(..)) 例2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强 execution(* com.atguigu.dao.BookDao.* (..)) 例3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 execution(* com.atguigu.dao.. (..)) AOP实现-注解实现 创建类，在类里面定义方法 创建增强类(编写增强逻辑) 进行通知的配置 在Spring配置文件中，开启注解扫描 使用注解创建User和UserProxy对象 在增强类上添加注解@Aspect生成代理对象 在 spring 配置文件中开启生成代理对象 配置不同类型的通知 在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置 相同的切入点抽取 有多个增强类对同一个方法进行增强，设置增强类优先级 在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高 AOP完全注解实现 创建配置类，不需要创建 xml 配置文件 测试类改为 AOP实现-xml配置文件 创建两个类，增强类和被增强类，创建方法 在Spring配置文件中创建两个类对象 在 spring 配置文件中配置切入点 JdbcTemplate简介 Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 环境配置 引入相关jar包 druid mysql-connector-java spring-jdbc spring-orm spring-tx 在 spring 配置文件配置数据库连接池 配置 JdbcTemplate 对象，注入 DataSource 创建 service 类，创建 dao 类，在 dao 注入 jdbcTemplate 对象 配置文件中加入： Service层 Dao层 JdbcTemplate操作数据库 对应数据库创建实体类 编写Service和Dao 在Dao进行数据库操作 Service层 Dao层 DaoImpl层（增删改） 查询操作 queryForObject(String sql,Class&lt; T &gt; requiredType) 第一个参数：sql语句 第二个参数：返回类型Class queryForObject(String sql,RowMapper&lt; T &gt; rowMapper,Object… args) 第一个参数：sql语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成 数据封装 第三个参数：sql 语句值 query(String sql,RowMapper&lt; T &gt; rowMapper,Object… args) 第一个参数：sql语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成 数据封装 第三个参数：sql 语句值 批量操作 batchUpdate(String sql,List&lt; Object[] &gt; batchArgs) 第一个参数：sql语句 第二个参数：List集合，添加多条记录数据 编写测试类 "},{"title":"Spring5框架（IOC）","date":"2021-04-23T16:00:00.000Z","url":"/2021/04/24/Spring5%E6%A1%86%E6%9E%B6%EF%BC%88IOC%EF%BC%89/","categories":[["ssm","/categories/ssm/"]],"content":"Spring5框架概述 Spring5是轻量级的开源的JavaEE框架 SPring可以解决企业应用开发复杂性 核心部分： IOC：控制反转，把创建对象过程交给Spring进行管理 AOP：面向切面，不修改源代码进行功能增强 特点 方便解耦，简化开发 AOP编程支持 方便程序测试 方便和其他框架进行整合 方便进行事务操作 降低API开发难度 环境搭建以spring5.2.6为例 下载Spring5压缩包 创建Java工程 导入Spring5相关jar包(压缩包的lib目录下) commons-logging-1.1.1.jar spring-beans-5.2.6.RELEASE.jar spring-context-5.2.6.RELEASE.jar spring-core-5.2.6.RELEASE.jar spring-expression-5.2.6.RELEASE.jar 创建一个普通类和方法 创建Spring配置文件，在配置文件创建配置对象 配置文件使用xml格式 编写测试代码测试 IOC（Version Of Control）简介 IOC即控制反转，是一种设计思想。IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内直接控制。 传统JavaSE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IOC是有专门一个容器来创建这些对象。即，由IOC容器来控制对象的创建。 有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转。而反转则是由容器来帮忙创建及注入依赖对象；因为有容器帮助查找及注入依赖对象，对象只是被动的接受依赖对象，所以称之为“反转”，反转的是依赖对象的获取。 IOC作用：传统应用程序都是由我们在类的内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试。使用IOC容器可以把创建和查找依赖对象的控制权交给容器，由容器进行注入组合对象，所以对象和对象之间是松散耦合，便于测试，利于**功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 底层原理实现过程xml解析、工厂模式、反射 第一步：xml配置文件，配置创建的对象 第二步：有service类和dao类，创建工厂类 实际操作中，xml解析、工厂设计模式、反射机制创建对象都是Spring封装好的。只需要修改xml文件即可。 IOC思想基于IOC容器完成，IOC容器底层即为对象工厂 IOC容器实现方式（两个接口） Spring提供了实现IOC容器的两个接口 BeanFactory：IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用（加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象） ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用（加载配置文件时候就会把在配置文件对象进行创建） ApplicationContext实现类： FileSystemXmlApplicationContext ClassPathXmlApplicationContext Bean管理(基于xml方式)创建对象 在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建 在 bean 标签有很多属性 常用的属性 id 属性：唯一标识 class 属性：类全路径（包类路径） 创建对象时候，默认也是执行无参数构造方法完成对象创建 注入属性方式DI—Dependency Injection即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中****。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。**通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。 第一种注入方式：set方法进行注入 创建类，定义属性和set方法 在Spring配置文件配置对象创建，配置属性注入 第二种注入方式：使用有参构造进行注入 创建类，定义属性，创建属性对应有参数构造方法 在Spring配置文件中进行配置 p名称空间注入(了解)使用p名称空间注入，可以简化基于xml配置方式 添加p名称空间在配置文件中 进行属性注入，在bean标签里进行操作 xml注入其他类型属性 字面量 null值 属性值包含特殊符号 注入属性-外部bean 创建两个类 service 类和 dao 类 在 service 调用 dao 里面的方法 在 spring 配置文件中进行配置 注入属性-内部bean Spring配置文件中进行配置 注入属性-级联赋值第一种写法 第二种写法先生成Dept类的get方法，然后在在 spring 配置文件中进行配置 注入属性-集合 注入数组类型属性 注入List集合类型属性 注入Map集合类型属性 创建类，定义数组、list、map、set 类型属性，生成对应 set 方法 在Spring配置文件中进行配置 在集合里面设置对象类型值 把集合注入部分提取出来 在 spring 配置文件中引入名称空间 util 使用 util 标签完成 list 集合注入提取 FactoryBean Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean） 普通 bean：在配置文件中定义 bean 类型就是返回类型 工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样 第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean 第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型 bean作用域作用域限定了Spring Bean的作用范围，在Spring配置文件定义Bean时，通过声明scope配置项，可以灵活定义Bean的作用范围。例如，当你希望每次IOC容器返回的Bean是同一个实例时，可以设置scope为singleton；当你希望每次IOC容器返回的Bean实例是一个新的实例时，可以设置scope为prototype。 默认情况下，bean是单实例对象 在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用 getBean 方法时候创建多实例对象 bean生命周期 bean-后置处理器作用是在Bean对象在实例化和依赖注入完毕后，在显示调用初始化方法的前后添加我们自己的逻辑。注意是Bean实例化完毕后及依赖注入完成后触发的 添加后置处理器后，bean的生命周期增加到了7步 通过构造器创建 bean 实例（无参数构造） 为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） 把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization 调用 bean 的初始化的方法（需要进行配置初始化的方法） 把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization bean 可以使用了（对象获取到了） 当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法） 演示 创建类，实现接口BeanPostProcessor,创建后置处理器 xml自动装配根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入 根据属性名称自动注入 根据属性类型自动注入 外部属性文件配置直接配置数据库信息 配置德鲁伊连接池 引入德鲁伊连接池依赖jar包 引入外部属性文件配置数据库连接池 创建外部属性文件，properties 格式文件，写数据库信息 把外部 properties 属性文件引入到 spring 配置文件中 引入 context 名称空间 在 spring 配置文件使用标签引入外部属性文件 Bean管理（基于注解方式） 注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..) 使用注解，注解作用在类上面，方法上面，属性上面、 使用注解目的：简化 xml 配置 Spring 针对 Bean 管理中创建对象提供注解 @Component @Service @Controller @Respository 上面四个注解功能是一样的，都可以用来创建 bean 实例 基于注解方式实现对象创建 引入依赖spring-aop-5.2.6.RELEASE.jar 开启组件扫描 创建类，在类上面添加创建对象注解 开启组件扫描细节配置 基于注解方式实现属性注入 @Autowired：根据属性类型进行自动装配 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解 @Qualifier：根据名称进行注入 这个@Qualifier 注解的使用，和上面@Autowired 一起使用 @Resource：可以根据类型注入，可以根据名称注入 @Value：注入普通类型属性 完全注解开发 创建配置类，代替xml配置文件 编写测试类 "},{"title":"JSON&Ajax&i18n","date":"2021-04-17T16:00:00.000Z","url":"/2021/04/18/JSON&Ajax&i18n/","categories":[["Java Web","/categories/Java-Web/"]],"content":"JSON简介JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON 采用完全独立于语言的文本格式，而且很多语言都提供了对 json 的支持（包括 C, C++, C#, Java, JavaScript, Perl, Python 等）。 这样就使得JSON成为理想的数据交换格式。 json是一种轻量级的数据交换格式 轻量级指的是跟xml作比较 数据交换指的是客户端和服务器之间业务数据的传递格式 JavaScript中的使用json的定义json 是由键值对组成，并且由花括号（大括号）包围。每个键由引号引起来，键和值之间使用冒号进行分隔， 多组键值对之间进行逗号进行分隔。 示例 json访问 json 本身是一个对象。 json 中的 key 我们可以理解为是对象中的一个属性。 json 中的 key 访问就跟访问对象的属性一样： json 对象.key 示例 json两个常用方法json 的存在有两种形式。 一种是：对象的形式存在，我们叫它 json 对象。 一种是：字符串的形式存在，我们叫它 json 字符串。 一般我们要操作 json 中的数据的时候，需要 json 对象的格式。 一般我们要在客户端和服务器之间进行数据交换的时候，使用 json 字符串 方法 描述 JSON.stringify() 把json对象转换成为json字符串 JSON.parse() 把json字符串转换成为json对象 示例 json在Java中的使用javaBean和json的互转 List和json的互转 map和json的互转 AJAX请求简介AJAX 即“Asynchronous Javascript And XML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。 ajax 是一种浏览器通过 js 异步发起请求，局部更新页面的技术。 Ajax 请求的局部更新，浏览器地址栏不会发生变化 局部更新不会舍弃原来页面的内容 示例 jQuery中的Ajax请求$.ajax方法 url——表示请求的地址 type—-表示请求的类型GET或POST请求 data—-表示发送给服务器的数据 格式有两种 name=value&amp;name=value {key:value} success—-请求成功，响应的回调函数 dataType–响应的数据类型 常用的数据类型有 text–纯文本 xml–xml数据 json表示json对象 示例 $.get方法和$.post方法 url—-请求的url地址 data–发送的数据 callback—成功的回调函数 type—返回的数据类型 示例 $.getJSON方法 url—-请求的url地址 data–发送给服务器的数据 callback—成功的回调函数 示例 表单序列化serialize()serialize()可以把表单中所有表单项的内容都获取到，并以 name=value&amp;name=value的形式进行拼接 i18n国际化简介 国际化（Internationalization）指的是同一个网站可以支持多种不同的语言，以方便不同国家，不同语种的用户访问。 关于国际化我们想到的最简单的方案就是为不同的国家创建不同的网站，比如苹果公司，他的英文官网是：  而中国官网是  苹果公司这种方案并不适合全部公司，而我们希望相同的一个网站，而不同人访问的时候可以根据用户所在的区域显示 不同的语言文字，而网站的布局样式等不发生改变。 于是就有了我们说的国际化，国际化总的来说就是同一个网站不同国家的人来访问可以显示出不同的语言。但实际上这 种需求并不强烈，一般真的有国际化需求的公司，主流采用的依然是苹果公司的那种方案，为不同的国家创建不同的页 面。所以国际化的内容我们了解一下即可。 国际化的英文 Internationalization，但是由于拼写过长，老外想了一个简单的写法叫做 I18N，代表的是 Internationalization 这个单词，以 I 开头，以 N 结尾，而中间是 18 个字母，所以简写为 I18N。以后我们说 I18N 和国际化是一个意思 相关要素Locale对象Locale表示不同的时区，位置，语言 Properties属性配置文件国际化配置文件命名规则： baseName_locale.properties 例如：baseName是i18n 中文的配置文件名是：i18n_zh_CN.properties 英文的配置文件名是：i18n_en_US.properties 国际化资源 properties测试配置两个语言的配置文件 i18n_en_US.properties 英文 i18n_zh_CN.properties 中文 国际化测试代码 通过请求头国际化页面 通过显示的选择语言类型进行国际化 JSTL标签库实现国际化 "},{"title":"Filter过滤器","date":"2021-04-12T16:00:00.000Z","url":"/2021/04/13/Filter%E8%BF%87%E6%BB%A4%E5%99%A8/","categories":[["Java Web","/categories/Java-Web/"]],"content":"简介 Filter过滤器是Java Web三大组件之一（Servlet程序、Listener监听器、Filter过滤器） Filter过滤器是JavaEE的规范，也就是接口 Filter过滤器它的作用是：拦截请求，过滤响应 拦截请求常见的应用场景有： 权限检查 日记操作 事务管理 应用应用场景：当你的 web 工程下，有一个 admin 目录。这个 admin 目录下的所有资源（html 页面、jpg 图片、jsp 文件、等等）都必须是用户登录之后才允许访问。 思路：用户登录之后都会把用户登录的信息保存到 Session 域中。所以要检查用户是否 登录，可以判断 Session 中否包含有用户登录的信息即可 Filter工作流程： 客户端（浏览器）根据地址访问服务器（Tomcat） Filter过滤器检查用户是否登录（权限检查） 有权限：让程序默认运行第3步 无权限：跳转到登录页面或者不允许访问 访问目标资源 Filter代码： web.xml 中的配置: Filter使用步骤： 编写一个类实现Filter接口 实现过滤方法doFilter() 到web.xml中去配置Filter的拦截路径 完整的用户登录login.jsp页面==登录表单 LoginServlet程序 Filter的生命周期Filter的生命周期包含几个方法 构造器方法 init初始化方法 doFilter过滤方法 destory销毁方法 注： 第1、2步，在web工程启动的时候执行（Filter已经创建） 第3步，每次拦截到请求，就会执行 第4步，停止web工程的时候，就会执行（停止web工程，也会销毁Filter过滤器） FilterConfig类FilterConfig 类见名知义，它是 Filter 过滤器的配置文件类。 Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。 FilterConfig 类的作用是获取 filter 过滤器的配置内容 获取Filter的名称filter-name的内容 获取在Filter中配置的init-param初始化参数 获取ServletContext对象 java代码 web.xml配置 FilterChain 过滤器链表示多个过滤器一起工作 Filter的拦截路径精确匹配 以上配置的路径，表示请求地址必须为：工程路径/target.jsp 目录匹配 以上配置的路径，表示请求地址必须为：工程路径/admin/* 后缀名匹配 以上配置的路径，表示请求地址必须以.html 结尾才会拦截到 以上配置的路径，表示请求地址必须以.do 结尾才会拦截到 以上配置的路径，表示请求地址必须以.action 注：Filter 过滤器它只关心请求的地址是否匹配，不关心请求的资源是否存在"},{"title":"Cookie&Session","date":"2021-04-07T16:00:00.000Z","url":"/2021/04/08/Cookie&Session/","categories":[["Java Web","/categories/Java-Web/"]],"content":"Cookie Cookie 是服务器通知客户端保存键值对的一种技术 客户端有了 Cookie 后，每次请求都发送给服务器 每个 Cookie 的大小不能超过 4kb Cookie创建 Servlet程序中 服务器获取Cookie 服务器获取客户端的 Cookie 只需要一行代码：req.getCookies():Cookie[] Cookie的工具类 Servlet中的代码 修改Cookie值方案一 先创建一个要修改的同名（指的就是key）的Cookie对象 在构造器，同时赋予新的Cookie值 调用response.addCookie(Cookie); 方案二 先查找到需要修改的Cookie对象 调用setValue()方法赋予新的Cookie值 调用response.addCookie()通知客户端保存修改 Cookie生命控制 Cookie 的生命控制指的是如何管理 Cookie 什么时候被销毁（删除） setMaxAge() 正数，表示在指定的秒数后过期 负数，表示浏览器一关，Cookie 就会被删除（默认值是-1） 零，表示马上删除 Cookie有效路径Path的设置 Cookie 的 path 属性可以有效的过滤哪些 Cookie 可以发送给服务器。哪些不发。 path 属性是通过请求的地址来进行有效的过滤。 CookieA path=/工程路径 CookieB path=/工程路径/abc 请求地址如下： 工程路径/a.html CookieA 发送 CookieB 不发送 工程路径/abc/a.html CookieA 发送 CookieB 发送 免输入用户名登录练习login.jsp页面 LoginServlet页面 Session会话 Session就一个接口（HttpSession） Session就是会话。它是用来维护一个客户端和服务器之间关联的一种技术 每个客户端都有自己的一个Session会话 Session会话中，经常用来保存登录之后的信息 创建&amp;获取Session 创建和获取 Session。它们的 API 是一样的。 request.getSession() 第一次调用是：创建 Session 会话 之后调用都是：获取前面创建好的 Session 会话对象。 isNew(); 判断到底是不是刚创建出来的（新的） true 表示刚创建 false 表示获取之前创建 每个会话都有一个身份证号。也就是 ID 值。而且这个 ID 是唯一的。 getId() 得到 Session 的会话 id 值。 Session域数据的存取 Session生命周期控制 public void setMaxInactiveInterval(int interval) 设置 Session 的超时时间（以秒为单位），超过指定的时长，Session 就会被销毁。 值为正数的时候，设定 Session 的超时时长。 负数表示永不超时（极少使用） public int getMaxInactiveInterval()：获取 Session 的超时时间 public void invalidate()：让当前 Session会话马上超时无效 Session 默认的超时时间长为 30 分钟。 因为在 Tomcat 服务器的配置文件 web.xml中默认有以下的配置，它就表示配置了当前 Tomcat 服务器下所有的 Session 超时配置默认时长为30 分钟。 web工程下修改所有Session超时时长 修改个别Session超时时长 Session的超时指的是，客户端两次请求的最大间隔时长 示例 Session 马上被超时 "},{"title":"EL表达式&JSTL标签库","date":"2021-04-02T16:00:00.000Z","url":"/2021/04/03/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F&JSTL%E6%A0%87%E7%AD%BE%E5%BA%93/","categories":[["Java Web","/categories/Java-Web/"]],"content":"EL表达式简介 EL表达式全称：Expression Language是表达式语言 EL表达式主要是代替JSP页面中的表达式脚本在jsp页面中进行数据的输出。因为EL表达式在输出数据的时候，要比JSP的表达式脚本要简洁的多。 EL表达式的格式是：${表达式} EL表达式在输出null值的时候，输出的是空串。JSP表达式脚本输出null值的时候，输出的是null字符串 EL表达式搜索域数据的顺序 EL表达式主要是在JSP页面上输出数据 主要是输出域对象中的数据 当四个域中都有相同的key的数据的时候，EL表达式会按照四个域的从小到大的顺序去进行搜索，找到就输出。 EL 表达式输出 Bean 的普通属性，数组属性。List 集 合属性，map 集合属性 输出 Person 类中普通属性，数组属性。list 集合属性和 map 集合属性 person类 输出的代码 EL表达式——运算语法 关系运算 关系运算符 说明 范例 结果 ==或eq 等于 ${5==5}或${5eq5} true !=或ne 不等于 ${5!=5}或${5ne5} false &lt;或lt 小于 ${3&lt;5}或${3lt5} true &gt;或gt 大于 ${2&gt;10}或${2gt10} false &lt;=或le 小于等于 ${5&lt;=12}或${5le12} true &gt;=或ge 大于等于 ${3&gt;=5}或${3ge5} false 逻辑运算 逻辑运算符 说明 范围 结果 $$或and 与运算 ${12==12&amp;&amp;12&lt;11}或${12==12and12&lt;11} false ||或or 或运算 ${12==12||12&lt;11}或${12==12or12&lt;11} true !或not 取反运算 ${!true}或${not true} false 算术运算 算术运算符 说明 范例 结果 + 加 ${12+18} 30 - 减 ${18-8} 10 * 乘 ${12*12} 144 /或div 除 ${144/12}或${144div12} 12 %或mod 取模 ${144%10}或${144mod10} 4 empty运算empty 运算可以判断一个数据是否为空，如果为空，则输出 true,不为空输出 false。 以下几种情况为空： 值为 null 值的时候，为空 值为空串的时候，为空 值是 Object 类型数组，长度为零的时候 list 集合，元素个数为零 map 集合，元素个数为零 三元运算表达式 1？表达式 2：表达式 3 如果表达式 1 的值为真，返回表达式 2 的值，如果表达式 1 的值为假，返回表达式 3 点运算&amp;中括号运算符 .点运算，可以输出 Bean 对象中某个属性的值。 []中括号运算，可以输出有序集合中某个元素的值。 并且[]中括号运算，还可以输出 map 集合中 EL表达式的11个隐含对象EL表达式中11个隐含对象，是EL表达式中自己定义的，可以直接使用 变量 类型 作用 pageContext PageContextImpl 它可以获取jsp中的九大内置对象 pageScope Map&lt;String,Object&gt; 它可以获取pageContext域中的数据 requestScope Map&lt;String,Object&gt; 它可以获取request域中的数据 sessionScope Map&lt;String,Object&gt; 它可以获取session域中的数据 applicationScope Map&lt;String,Object&gt; 它可以获取ServletContext域中的数据 param Map&lt;String,String&gt; 它可以获取请求参数的值 paramValues Map&lt;String,String[]&gt; 它也可以获取请求参数的值，获取多个值的时候使用 header Map&lt;String,String&gt; 它可以获取请求头的信息 headerValues Map&lt;String,String[]&gt; 它可以获取请求头的信息，它可以获取多个值的情况 cookies Map&lt;String,Cookie&gt; 它可以获取当前请求的cookie信息 initParam Map&lt;String,String&gt; 它可以获取在 web.xml 中配置的上下文参数 EL 获取四个特定域中的属性 pageScope—————pageContext域 requestScope———–Request域 sessionScope———–Session域 applicationScope——ServletContext域 pageContext对象的使用 EL表达式其他隐含对象的使用 param paramValues cookie initParam web.xml中的配置 示例 JSTL标签库 JSTL 标签库 全称是指 JSP Standard Tag Library JSP 标准标签库。是一个不断完善的开放源代码的 JSP 标 签库。 EL 表达式主要是为了替换 jsp 中的表达式脚本，而标签库则是为了替换代码脚本。这样使得整个 jsp 页面 变得更佳简洁。 JSTL由五个不同功能的标签库组成 功能范围 URI 前缀 核心标签库  c 格式化  fmt 函数  fn 数据库（不使用）  sql XML（不使用）  x 在 jsp 标签库中使用 taglib指令引入标签库 JSTL标签库使用步骤 先导入 jstl 标签库的 jar 包。 taglibs-standard-impl-1.2.1.jar taglibs-standard-spec-1.2.1.jar 使用 taglib 指令引入标签库。 core核心库使用&lt;c:set /&gt;（很少使用）作用：set标签可以往域中保存数据 &lt;c:if /&gt;if 标签用来做 if 判断。 &lt; c:choose &gt;&lt; c:when &gt;&lt; c:otherwise &gt;标签作用：多路判断。跟switch…case…default非常接近 &lt;c:foreach /&gt;作用：遍历输出使用 遍历1~10输出 遍历Object数组 遍历Map集合 遍历 List 集合—list 中存放 Student 类，有属性：编号，用户名，密码，年龄， 电话信息Student类 示例 "},{"title":"JSP","date":"2021-03-31T16:00:00.000Z","url":"/2021/04/01/JSP/","categories":[["Java Web","/categories/Java-Web/"]],"content":"简介 JSP的全称是java server pages。jaa的服务器页面 jsp的主要作用是代替Servlet程序回传html页面的数据，因为 Servlet 程序回传 html 页面数据是一件非常繁锁的事情。开发成本和维护成本都极高 servlet回传html页面数据 jsp 回传 html 页面的代码 JSP访问 jsp 页面和 html 页面一样，都是存放在 web 目录下。访问也跟html页面相同 JSP本质 jsp 页面本质上是一个 Servlet 程序 当第一次访问 jsp 页面的时候。Tomcat 服务器会把 jsp 页面翻译成为一个 java 源文件。并且对它进行编译成 为.class 字节码程序。跟踪源代码发现，HttpJspBase类直接继承了HttpServlet类。也就是说，jsp翻译出的java类，间接地继承了HttpServlet类。翻译出来的是一个 Servlet 程序。 JSP的三种语法JSP头部的page指令jsp 的 page 指令可以修改JSP页面中一些重要的属性，或者行为。 属性 说明 language 表示jsp翻译后是什么语言文件。暂时只支持java contentType jsp返回的数据类型是什么。也是源码中response.setContentType()参数值 pageEncoding 表示当前jsp页面文件本身的字符集 import 跟Java源代码中一样。用于导包，导类 errorPage 设置当jsp页面运行时出错，自动跳转去的错误页面路径。 isErrorPage 设置当前jsp页面是否是错误信息页面。默认是false。如果是true可以获取异常信息 session 设置访问当前jsp页面，是否会创建HttpSession对象默认是true。 extends 设置jsp翻译出来的java类默认继承谁 out输出流 属性 说明 autoFlush 设置当out输出流缓冲区满了以后，是否自动刷新冲级区。默认值是true buffer 设置out缓冲区的大小。默认是8kb 注：当缓冲区满了之后不能自动刷新，就会报错 JSP中的脚本声明脚本（极少使用）格式 作用 可以给jsp翻译出来的java类定义属性和方法甚至是静态代码块。内部类等。 表达式脚本（常用）格式 作用 在jsp页面上输出数据 特点 所有的表达式脚本都会被翻译到_jspService()方法中 表达式脚本都会被翻译成为out.print()输出到页面上 由于表达式脚本翻译的内容都在_jspService()方法中，所以 _jspService()方法中的对象都可以直接使用。 表达式脚本中的表达式不能以分号结束 示例代码： 代码脚本格式 作用 可以在jsp页面中，编写我们自己需要的功能(写的是java语句) 特点 代码脚本翻译之后都在_jspService方法中 代码脚本由于翻译到_jspService()方法中，所以在 _jspService()方法中的现有对象都可以直接使用 还可以由多个代码脚本块组合完成一个完整的 java 语句。 代码脚本还可以和表达式脚本一起组合使用，在 jsp 页面上输出数据 示例 JSP中的三种注释html注释 html 注释会被翻译到 java 源代码中。在_jspService 方法里，以 out.writer 输出到客户端 Java注释 java 注释会被翻译到 java 源代码中 JSP注释 jsp 九大内置对象 jsp 中的内置对象，是指 Tomcat 在翻译 jsp 页面成为 Servlet 源代码后，内部提供的九大对象，叫内置对象 request 请求对象 response 响应对象 pageContext jsp的上下文对象 session 会话对象 application ServletContext对象 config ServletConfig对象 out jsp输出流对象 page 指向当前jsp的对象 exception 异常对象 JSP四大域对象 域对象 说明 pageContext (PageContextImpl类) 当前jsp页面范围内有效 request (HttpServletRequest类) 一次请求内有效 session (HttpSession类) 一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器） application (ServletContext类) 整个Web工程范围内都有效(只要Web工程不停止，数据都在) 域对象是可以像 Map 一样存取数据的对象。四个域对象功能一样。不同的是它们对数据的存取范围 虽然四个域对象都可以存取数据。在使用上它们是有优先顺序的。 四个域在使用的时候，优先顺序分别是，他们从小到大的范围的顺序。 pageContext ====&gt;&gt;&gt; request ====&gt;&gt;&gt; session Scope.jsp页面 Scope2.jsp页面 out 输出和 response.getWriter 输出的区别 response 中表示响应，我们经常用于设置返回给客户端的内容（输出） out 也是给用户做输出使用的。 out.write()输出时，会将输出结果放在out缓冲区中。 response.getWriter()输出时，会将数据直接放入response缓冲区。 当jsp中的代码全部执行完毕后会执行out.flush()操作，将out缓冲区的数据追加写入到response缓冲区末尾。然后执行response的刷新操作。把全部数据写给客户端 由于 jsp 翻译之后，底层源代码都是使用 out 来进行输出，所以一般情况下。我们在 jsp 页面中统一使用 out 来进行输出。避免打乱页面输出内容的顺序。 out.write() 输出字符串没有问题 out.print() 输出任意数据都没有问题（都转换成为字符串后调用的 write 输出 JSP的常用标签JSP静态包含 JSP动态包含 JSP标签-转发 练习在JSP页面输出九九乘法口诀表 jsp 输出一个表格，里面有 10 个学生信息。student类 SearchStudentServlet 程序 showStudent.jsp 页面 Listener监听器 Listener 监听器它是 JavaWeb 的三大组件之一。JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监 听器。 Listener 它是 JavaEE 的规范，就是接口 监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。 ServletContextListener 监听器 ServletContextListener 它可以监听 ServletContext 对象的创建和销毁。 ServletContext 对象在 web 工程启动的时候创建，在 web 工程停止的时候销毁。 监听到创建和销毁之后都会分别调用 ServletContextListener 监听器的方法反馈。 创建&amp;销毁监听方法 如何使用 ServletContextListener 监听器监听 ServletContext 对象。 使用步骤如下： 编写一个类去实现 ServletContextListener 实现其两个回调方法 到 web.xml 中去配置监听器 监听器实现类 web.xml配置 "},{"title":"Servlet2","date":"2021-03-30T16:00:00.000Z","url":"/2021/03/31/Servlet2/","categories":[["Java Web","/categories/Java-Web/"]],"content":"HttpServletRequset类作用请求进入Tomcat服务器，服务器就会把请求过来的Http协议信息解析好封装到Request对象中。然后传递到Service方法（doGet()和doPost()）中使用。可以通过HttpServletRequest对象，获取到所有请求的信息 常用方法 方法名 说明 getRequestURI() 获取请求的资源路径 getRequestURL() 获取请求的统一资源定位符（绝对路径） getRemoteHost() 获取客户端的IP地址 getHeader() 获取请求头 getParameter 获取请求的参数 getParameterValues() 获取请求的参数（多个值时使用） getMethod() 获取请求的方式GET或POST setAttribute(key,value) 设置域数据 getAttribute(key) 获取域数据 getRequestDispatcher() 获取请求转发对象 示例 获取请求参数示例表单 Java代码 doGet请求的中文乱解决 doPost请求的中文乱码解决 请求转发服务器收到请求后，从一次资源跳转到另一个资源的操作叫请求转发 特点： 浏览器地址栏没有变化 他们是一次请求 他们共享Request域中的数据 可以转发到WEB-INF目录下 不可以访问工程以外的资源 示例Servlet1 Servlet2 base标签的作用base标签可以设置当前页面中所有相对路径工作时，参照哪个路径来进行跳转 Web 中的相对路径和绝对路径相对路径 符号 说明 . 表示当前目录 .. 表示上一级目录 资源名 表示当前目录/资源名 绝对路径 工程路径/资源路径 在实际开发中，路径都使用绝对路径，而不简单的使用相对路径 相对路径 base+相对 web中“/”的不同意义 在web中“/”是一种绝对路径 “/”如果被浏览器解析，得到的地址是： “/“如果被服务器解析，得到的地址是：工程路径 /servlet1 servletContext.getRealPath(“/”); request.getRequestDispatcher(“/”); 特殊情况： response.sendRediect(“/”); 把斜杠发送给浏览器解析。得到  HttpServletResponse类作用HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息， 我们如果需要设置返回给客户端的信息，都可以通过HttpServletResponse对象来进行设置 两个输出流说明 字节流：getOutputStream();——–常用于下载（传递二进制数据） 字符流：getWriter();——————–常用于回传字符串（常用） 两个流同时只能使用一个。否则会报错。 客户端回传数据 响应的乱码解决方案一 方案二(推荐) 请求重定向请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求重定向（因为之前的地址可能已经被废弃）。 请求重定向的第一种方案 请求重定向的第二种方案(推荐)"},{"title":"HTTP协议","date":"2021-03-28T16:00:00.000Z","url":"/2021/03/29/HTTP%E5%8D%8F%E8%AE%AE/","categories":[["Java Web","/categories/Java-Web/"]],"content":"HTTP协议简介HTTP 协议就是指，客户端和服务器之间通信时，发送的数据，需要遵守的规则，叫 HTTP 协议。 HTTP 协议中的数据又叫报文。 请求的HTTP协议格式 客户端给服务器发送数据叫请求。 服务器给客户端回传数据叫响应。 请求又分为 GET 请求，和 POST 请求两种 GET请求 请求行 请求的方式———GET 请求的资源路径[+?+请求参数] 请求的协议的版本号——–HTTP/1.1 请求头 key:value 组成不同的键值对，表示不同的含义 POST请求 请求行 请求的方式———POST 请求的资源路径[+?+请求参数] 请求的协议的版本号——-HTTP/1.1 请求头 key:value———不同的请求头，有不同的含义 请求体===&gt;&gt;&gt;就是发送给服务器的数据 常用请求头说明 Accept: 表示客户端可以接收的数据类型 Accpet-Languege: 表示客户端可以接收的语言类型 User-Agent: 表示客户端浏览器的信息 Host：表示请求时的服务器 ip 和端口号 哪些是 GET 请求，哪些是 POST 请求GET 请求有哪些： form 标签 method=get a 标签 link 标签引入 css Script 标签引入 js 文件 img 标签引入图片 iframe 引入 html 页面 在浏览器地址栏中输入地址后敲回车 POST 请求有哪些： form 标签 method=post 响应的 HTTP 协议格式响应行 响应的协议和版本号 响应状态码 响应状态描述符 响应头 key : value 不同的响应头，有其不同含义 响应体 响应体 就是回传给客户端的数据 常用的响应码说明 响应码 说明 200 表示请求成功 302 表示请求重定向 404 表示请求服务器已经收到了，但需要的数据不存在（请求地址错误） 500 表示服务器已经收到请求，但是服务器内部错误（代码错误） MIME 类型说明 MIME 是 HTTP 协议中数据类型。 MIME 的英文全称是”Multipurpose Internet Mail Extensions” 多功能 Internet 邮件扩充服务。MIME 类型的格式是“大类型/小 类型”，并与某一种文件的扩展名相对应。 文件 MIME类型 超文本标记语言文本 .html , .htm text/html 普通文本 .txt text/plain RTF 文本 .rtf application/rtf GIF 图形 .gif image/gif JPEG 图形 .jpeg,.jpg image/jpeg au 声音文件 .au audio/basic MIDI音乐文件 mid,.midi audio/midi,audio/x-midi RealAudio 音乐文件 .ra, .ram audio/x-pn-realaudio MPEG 文件 .mpg,.mpeg video/mpeg AVI 文件 .avi video/x-msvideo GZIP 文件 .gz application/x-gzip TAR文件 .tar application/x-tar "},{"title":"Servlet1","date":"2021-03-28T16:00:00.000Z","url":"/2021/03/29/Servlet1/","categories":[["Java Web","/categories/Java-Web/"]],"content":"Servlet技术 Servlet是JavaEE规范之一。规范就是接口 Servlet 就 JavaWeb 三大组件之一。三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监听器 Servlet 是运行在服务器上的一个 java 小程序，它可以接收客户端发送过来的请求，并响应数据给客户端 手动实现Servlet程序 编写一个类实现Servlet接口 实现service方法，处理请求，并响应数据 到web.xml中去配置Servlet程序的访问地址 示例实现Servlet接口类 web.xml中的配置 Servlet的生命周期 执行Servlet构造器方法 执行init初始化方法 执行service方法 执行destroy销毁方法 注： 第1、2步是在第一次访问的时候创建Servlet程序会调用 第3步每次访问都会调用 第4步在web工程停止的时候调用 GET和POST请求的分发处理 通过继承HttpServlet实现Servlet程序一般在实际项目开发中，都是使用继承 HttpServlet 类的方式去实现 Servlet 程序。 编写一个类去继承 HttpServlet 类 根据业务需要重写 doGet 或 doPost 方法 到 web.xml中的配置Servlet程序的访问地址 示例Servlet类 web.xml配置 Servlet类的继承体系 ServletConfig类 ServletConfig 类是 Servlet 程序的配置信息类。 Servlet 程序和 ServletConfig 对象都是由 Tomcat 负责创建，我们负责使用。 Servlet 程序默认是第一次访问的时候创建，ServletConfig 是每个 Servlet 程序创建时，就创建一个对应的 ServletConfig 对 象。 ServletConfig类的三大作用 可以获取Servlet程序的别名servlet-name的值 获取初始化参数init-param 获取ServletContext对象 web.xml中的配置 Servlet 注：重新init()方法里面一定要调用父类的init(ServletConfig)操作 ServletContext类什么是ServletContext ServletContext是一个接口，它表示Servlet上下文对象 一个web工程，只有一个ServletContext对象实例 ServletContext对象是一个域对象 ServletContext是在web工程部署启动的时候创建。在web工程停止的时候销毁 域对象：可以像Map一样存取数据的对象。这里的域指的是存取数据的操作范围，整个web工程。 存数据 取数据 删除数据 Map put() get() remove() 域对象 setAttribute() getAttribute() removeAttribute() ServletContext类的四个作用 获取web.xml中配置的上下文参数context-param 获取当前的工程路径，格式：/工程路径 获取工程部署后在服务器硬盘上的绝对路径 像Map一样存取数据 示例ServletContext web.xml ServletContext像Map一样存取数据ContextServlet1 ContextServlet2 "},{"title":"Tomcat","date":"2021-03-27T16:00:00.000Z","url":"/2021/03/28/Tomcat/","categories":[["Java Web","/categories/Java-Web/"]],"content":"JavaWeb的概念 JavaWeb 是指，所有通过 Java 语言编写可以通过浏览器访问的程序的总称，叫 JavaWeb。 JavaWeb 是基于请求和响应来开发的。 请求是指客户端给服务器发送数据，叫请求 Request 响应是指服务器给客户端回传数据，叫响应 Response 请求和响应是成对出现的，有请求就有响应 Web资源的分类web 资源按实现的技术和呈现的效果的不同，又分为静态资源和动态资源两种。 静态资源： html、css、js、txt、mp4 视频 , jpg 图片 动态资源： jsp 页面、Servlet 程序 常用的 Web 服务器 Tomcat：由 Apache 组织提供的一种 Web 服务器，提供对 jsp 和 Servlet 的支持。它是一种轻量级的 javaWeb 容器（服务 器），也是当前应用最广的 JavaWeb 服务器（免费）。 Jboss：是一个遵从 JavaEE 规范的、开放源代码的、纯 Java 的 EJB 服务器，它支持所有的 JavaEE 规范（免费）。 GlassFish： 由 Oracle 公司开发的一款 JavaWeb 服务器，是一款强健的商业服务器，达到产品级质量（应用很少）。 Resin：是 CAUCHO 公司的产品，是一个非常流行的服务器，对 servlet 和 JSP 提供了良好的支持， 性能也比较优良，resin 自身采用 JAVA 语言开发（收费，应用比较多）。 WebLogic：是 Oracle 公司的产品，是目前应用最广泛的收费Web 服务器，支持 JavaEE 规范， 而且不断的完善以适应新的开发要求，适合大型项目（收费，用的不多，适合大公司）。 Tomcat使用目录介绍 目录 说明 bin 专门用来存放Tomcat服务器的可执行程序 conf 专门用来存放 Tocmat 服务器的配置文件 lib 专门用来存放 Tomcat 服务器的 jar 包 logs 专门用来存放 Tomcat 服务器运行时输出的日记信息 temp 专门用来存放 Tomcdat 运行时产生的临时数据 webapps 专门用来存放部署的 Web 工程 work 是 Tomcat 工作时的目录，用来存放 Tomcat 运行时 jsp 翻译为 Servlet 的源码，和 Session 钝化的目录 启动Tomcat服务器方式一找到 Tomcat 目录下的 bin 目录下的 startup.bat 文件，双击，就可以启动 Tomcat。 打开浏览器，在浏览器地址栏中输入以下地址测试：   http://真实 ip:8080 方式二 打开命令行 cd到你的Tomcat的bin目录下 输入：catalina run 关闭Tomcat 点击 tomcat 服务器窗口的 x 关闭按钮 把 Tomcat 服务器窗口置为当前窗口，然后按快捷键 Ctrl+C 找到 Tomcat 的 bin 目录下的 shutdown.bat 双击，就可以停止 Tomcat 部署Web工程到Tomcat中方式一 把 web 工程的目录拷贝到 Tomcat 的 webapps 目录下 只需要在浏览器中输入访问地址格式如下： 工程名/目录下/文件名 方式二 找到 Tomcat 下的 conf 目录\\Catalina\\localhost\\ 下,创建如下的配置文件 访问这个工程的路径如下: "},{"title":"XML","date":"2021-03-27T16:00:00.000Z","url":"/2021/03/28/XML/","categories":[["Java Web","/categories/Java-Web/"]],"content":"xml简介xml是可扩展的标记性语言 作用 用来保存数据，而且这些数据具有自我描述性 它还可以作为项目或者模块的配置文件 还可以作为网络传输数据的格式（现在json为主） xml语法文档声明 xml注释和html相同 元素（标签）xml元素指的是从（且包括）从开始标签直到（且包括）结束标签的部分。元素可包含其他元素、文本或者两者的混合物。元素也可用有属性。 命名规则 名称可以含字母、数字以及其它字符 名称不能以数字或者标点符号开始 名称不能包含空格 单&amp;双标签单标签 格式： &lt;标签名 属性=”值” 属性=”值” …… /&gt; 双标签 格式：&lt; 标签名 属性=”值” 属性=”值” ……&gt;文本数据或子标签 xml属性xml 的标签属性和 html 的标签属性是非常类似的。 在标签上可以书写属性： 一个标签上可以书写多个属性。每个属性的值必须使用引号引起来。规则和标签的书写规则一致。 语法规则 所有xml元素都必须有关闭标签（也就是闭合） xml标签对大小写敏感 必须正确嵌套 必须有根元素 根元素就是顶级元素，没有父标签的的元素叫顶级元素。根元素是没有父标签的顶级元素，而且是唯一一个才行。 xml的属性值需加引号 文本区域（CDATA区）CDATA语法可以告诉xml解析器，我CDATA里的文本内容，只是纯文本，不需要xml语法解析 CDATA格式： xml解析技术介绍不管是html还是xml文件他们都是标记型文档，都可以使用w3c组织制定的dom技术来解析。 DOM&amp;SAX简介（已经过时，但还是需要了解） dom 解析技术是 W3C 组织制定的，而所有的编程语言都对这个解析技术使用了自己语言的特点进行实现。 Java 对 dom 技术解析标记也做了实现。 sun 公司在 JDK5 版本对 dom 解析技术进行升级：SAX（ Simple API for XML ） SAX 解析，它跟 W3C 制定的解析不太一样。它是以类似事件机制通过回调告诉用户当前正在解析的内容。 它是一行一行的读取 xml 文件进行解析的。不会创建大量的 dom 对象。 所以它在解析 xml 的时候，在内存的使用上。和性能上。都优于 Dom 解析。 第三方的解析： jdom 在 dom 基础上进行了封装 dom4j 又对 jdom 进行了封装。（Dom4j是第三方的解析技术。我们需要使用第三方给我们提供好的类库才可以解析 xml 文） pull 主要用在 Android 手机开发，是在跟 sax 非常类似都是事件机制解析 xml dom4j解析技术（重点）由于 dom4j 它不是 sun 公司的技术，而属于第三方公司的技术，我们需要使用 dom4j 就需要到 dom4j 官网下载 dom4j 的 jar 包。 dom4j编程步骤 先加载xml文件创建document对象 通过Document对象拿到根元素对象 通过根元素.elements(标签名);可以返回一个集合，这个集合里放着。所有你指定的标签名的元素对象 找到你想要修改、删除的子元素，进行相应操作 保存到硬盘上 获取document对象先创建SaxReader对象。这个对象，用于读取xml文件，并创建Document 遍历标签获取所有标签中的内容（重点） 通过创建 SAXReader 对象。来读取 xml 文件，获取 Document 对象 通过 Document 对象。拿到 XML 的根元素对象 通过根元素对象。获取所有的 book 标签对象 遍历每个 book 标签对象。然后获取到 book 标签对象内的每一个元素，再通过 getText() 方法拿到起始标签和结束标签之间的文本内容 "},{"title":"jQuery1","date":"2021-03-24T16:00:00.000Z","url":"/2021/03/25/jQuery1/","categories":[["Java Web","/categories/Java-Web/"]],"content":"jQuery介绍 顾名思义，jQuery也就是JavaScript和查询（Query），他就是辅助JavaScript开发的Js类库。 jQuery的核心思想是“写的更少，做得更多”，所以它实现了很多浏览器的兼容问题 示例给按钮添加一个绑定单击事件 jQuery使用时一定要引入jQuery库 jQuery中的$是一个函数 jQuery核心函数$ 是 jQuery 的核心函数，能完成 jQuery 的很多功能。$()就是调用$这个函数 传入参数为[函数]时 表示页面加载完成之后。相当于window.onload=function(){} 传入参数为[HTML字符串]时 会对我们创建这个html标签对象 传入参数为[选择器字符串]时 $(“#id属性值”);——–id选择器，根据id查询标签对象 $(“标签名”);————-标签名选择器，根据指定的标签名查询标签对象 $(“.class属性值”);——类型选择器，可以根据class属性查询标签对象 传入参数为[DOM对象]时 会把这个dom对象转换为jQuery对象 jQuery对象和dom对象区分jQuery对象&amp;dom对象Dom对象 通过 getElementById()查询出来的标签对象是 Dom 对象 通过 getElementsByName()查询出来的标签对象是 Dom 对象 通过 getElementsByTagName()查询出来的标签对象是 Dom 对象 通过 createElement() 方法创建的对象，是 Dom 对象 DOM 对象 Alert 出来的效果是：**[object HTML 标签名 Element]** jQuery对象 通过jQuery提供的API创建的对象，是jQuery对象 通过jQuery包装的Dom对象，也是jQuery对象 通过jQuery提供的API查询到的对象，是jQuery对象 jQuery 对象 Alert 出来的效果是：[object Object] jQuery对象的本质jQuery 对象是 dom 对象的数组 +jQuery提供的一系列功能函数 jQuery对象和Dom对象使用区别 jQuery对象不能使用Dom对象的属性和方法 Dom对象也不能使用jQuery对象的属性和方法 Dom和jQuery对象相互转换 Dom对象转换为jQuery对象 先有Dom对象 $(Dom对象)就可以转换成jQuery对象（var $obj=$(dom对象);） jQuery对象转换为Dom对象 先有jQuery对象 jQuery对象[下标]取出相应的Dom对象（var dom=$obj[下标]） jQuery选择器基本选择器 选择器 描述 #id 根据id查找标签对象 .class 根据class查找标签对象 element 根据标签名查找标签对象 * 表示任意的，所有元素 selector1,selector2 合并选择器1，选择器2的结果并返回 示例代码 层级选择器 选择器 描述 ancestor descendant(后代选择器) 在给定的祖先元素下匹配所有的后代元素 parent&gt;child(子元素选择器) 在给定的父元素下匹配所有的子元素 prev+next(相邻元素选择器) 匹配所有紧接在prev元素后的next元素 prev~sibings(兄弟元素选择器) 匹配prev元素之后的所有siblings元素 示例代码 过滤选择器基本过滤器 过滤器 描述 :first 获取第一个元素 :last 获取最后一个元素 :not(selector) 去除所有与给定选择器匹配的元素 :even 匹配所有索引值为偶数的元素，从0开始计数 :odd 匹配所有索引值为奇数的元素，从0开始计数 :eql(index) 匹配一个给定索引值的元素 :gt(index) 匹配所有大于给定索引值的元素 :lt(index) 匹配所有小于给定索引值的元素 :header 匹配如 h1, h2, h3 之类的标题元素 :animated 匹配所有正在执行动画效果的元素 内容过滤器 过滤器 描述 :contains(text) 匹配包含给定文本的元素 :empty 匹配所有不包含子元素或者文本的空元素 :parent 匹配含有子元素或者文本的元素 :has(selector) 匹配含有选择器所匹配的元素的元素 代码示例 属性过滤器 过滤器 描述 [attribute] 匹配包含给定属性的元素 [attribute=value] 匹配给定的属性是某个特定值的元素 [attribute!=value] 匹配所有不含有指定的属性，或者属性不等于特定值的元素 [attribute^=value] 匹配给定的属性是以某些值开始的元素 [attribute$=value] 匹配给定的属性是以某些值结尾的元素 [attribute*=value] 匹配给定的属性是以包含某些值的元素 [ attrSel1 ] [ attrSel2 ] [ attrSelN ] 复合属性选择器，需要同时满足多个条件时使用 示例代码 表单过滤器&amp;表单对象属性过滤器 过滤器 描述 :input 匹配所有 input, textarea, select 和 button 元素 :text 匹配所有 文本输入框 :password 匹配所有的密码输入框 :radio 匹配所有的单选框 :checkbox 匹配所有的复选框 :submit 匹配所有提交按钮 :image 匹配所有 img 标签 :reset 匹配所有重置按钮 :button 匹配所有 input type=button 按钮 :file 匹配所有 input type=file 文件上传 :hidden 匹配所有不可见元素 display:none 或 input type=hidden 表单对象属性过滤器 过滤器 描述 :enabled 匹配所有可用元素 :disabled 匹配所有不可用元素 :checked 匹配所有选中的单选，复选，和下拉列表中选中的option标签对象 :selected 匹配所有选中的option 示例代码 jQuery元素筛选 筛选元素 描述 eq() 获取给定索引的元素 first() 获取第一个元素 last() 获取最后一个元素 filter(exp) 留下匹配的元素 is(exp) 判断是否匹配给定的选择器，只要有一个匹配就返回，true has(exp) 返回包含有匹配选择器的元素的元素 not(exp) 删除匹配选择器的元素 children(exp) 返回匹配给定选择器的子元素 find(exp) 返回匹配给定选择器的后代元素 next() 返回当前元素的下一个兄弟元素 nextAll() 返回当前元素后面所有的兄弟元素 nextUntil() 返回当前元素到指定匹配的元素为止的后面元素 parent() 返回父元素 prev(exp) 返回当前元素的上一个兄弟元素 prevAll() 返回当前元素前面所有的兄弟元素 prevUnit(exp) 返回当前元素到指定匹配的元素为止的前面元素 siblings(exp) 返回所有兄弟元素 add() 把 add 匹配的选择器的元素添加到当前 jquery 对象 "},{"title":"jQuery2","date":"2021-03-24T16:00:00.000Z","url":"/2021/03/25/jQuery2/","categories":[["Java Web","/categories/Java-Web/"]],"content":"jQuery属性操作 属性 描述 html() 它可以设置和获取起始标签和结束标签中的内容 text() 它可以设置和获取起始标签和结束标签中的文本 val() 它可以设置和获取表单项的 value 属性值 属性 描述 attr() 可以设置和获取属性的值，不推荐操作 checked、readOnly、selected、disabled 等等。 attr 方法还可以操作非标准的属性。比如自定义属性：abc,bbj prop() 可以设置和获取属性的值,只推荐操作 checked、readOnly、selected、disabled 等等 jQuery练习 DOM的增删改 内部插入 示例 描述 appendTo() a.appendTo(b) 把 a 插入到 b 子元素末尾，成为最后一个子元素 prependTo() a.prependTo(b) 把 a 插到 b 所有子元素前面，成为第一个子元素 外部插入 示例 描述 insertAfter() a.insertAfter(b) 得到ba insertBefore() a.insertBefore(b) 得到ab 替换 示例 描述 replaceWith() a.replaceWith(b) 用b替换掉a replaceAll() a.replaceAll(b) 用a替换掉所有b 删除 示例 描述 remove() a.remove(); 删除a标签 empty() a.empty(); 清空a标签里的内容 示例 jQuery练习2 动态添加、删除表格记录 CSS样式操作 样式操作 描述 addClass() 添加样式 removeClass() 删除样式 toggleClass() 有就删除，没有就添加样式 offset() 获取和设置元素的坐标 jQuery动画基本动画 动画方法 描述 show() 将隐藏的元素显示 hide() 将可见的元素隐藏 toggle() 可见就隐藏，不可见就显示 以上动画方法都可以添加参数。 第一个参数是动画 执行的时长，以毫秒为单位 第二个参数是动画的回调函数 (动画完成后自动调用 淡入淡出动画 方法 描述 fadeln() 淡入（慢慢可见） fadeOut() 淡出（慢慢可见） fadeTo() 在指定时长内慢慢的将透明度修改到指定的值。0 透明，1 完成可见，0.5 半透明 fadeToggle() 淡入/淡出 切换 jQuery练习3需求： 点击按钮的时候，隐藏和显示卡西欧之后的品牌。 当显示全部内容的时候，按钮文本为“显示精简品牌” 然后，小三角形向上。所有品牌产品为默认颜色。 当只显示精简品牌的时候，要隐藏卡西欧之后的品牌，按钮文本为“显示全部品牌” 然后小三形向下。并且把 佳能，尼康的品牌颜色改为红色（给 li 标签添加 promoted 样式即可） jQuery事件操作$( function(){} ); 和 window.onload = function(){} 的区别？他们分别是在什么时候触发？ jQuery 的页面加载完成之后是浏览器的内核解析完页面的标签创建好 DOM 对象之后就会马上执行。 原生 js 的页面加载完成之后，除了要等浏览器内核解析完标签创建好 DOM 对象，还要等标签显示时需要的内容加载 完成。 他们触发的顺序？ jQuery 页面加载完成之后先执行 原生 js 的页面加载完成之后 他们执行的次数？ 原生 js 的页面加载完成之后，只会执行最后一次的赋值函数。 jQuery 的页面加载完成之后是全部把注册的 function 函数，依次顺序全部执行 jQuery 中其他的事件处理方法 方法 描述 click() 它可以绑定单击事件，以及触发单击事件 mouseover() 鼠标移入事件 mouseout() 鼠标移出事件 bind() 可以给元素一次性绑定一个或多个事件 one() 使用上跟 bind 一样。但是 one 方法绑定的事件只会响应一次 unbind() 跟 bind 方法相反的操作，解除事件 live() 也是用来绑定事件。它可以用来绑定选择器匹配的所有元素的事件。哪怕这个元素是后面动态创建出 来的也有效 事件的冒泡事件的冒泡是指，父子元素同时监听同一个事件。当触发子元素的事件的时候，同一个事件也被传递到了父元素的事件里去 响应。 示例 javaScript 事件对象事件对象，是封装有触发的事件信息的一个 javascript 对象。 如何获取 javascript 事件对象？ 在给元素绑定事件的时候，在事件的 function( event ) 参数列表中添加一个参数，这个参数名，我们习惯取名为 event。 这个 event 就是 javascript 传递参事件处理函数的事件对象 示例 jQuery练习3图片跟随 "},{"title":"JavaScript","date":"2021-03-22T16:00:00.000Z","url":"/2021/03/23/JavaScript/","categories":[["Java Web","/categories/Java-Web/"]],"content":"JavaScript介绍 Javascript 语言诞生主要是完成页面的数据验证。因此它运行在客户端，需要运行浏览器来解析执行 JavaScript 代码。 特点 交互性（它可以做的就是信息的动态交互） 安全性（不允许直接访问本地硬盘） 跨平台性（只要是可以解释 JS 的浏览器都可以执行，和平台无 JavaScript 和 html 代码的结合方式第一种方式只需要在 head 标签中，或者在 body 标签中， 使用 script 标签 来书写 JavaScript 代码 第二种方式使用 script 标签引入 单独的 JavaScript 代码文件 html代码内容 css代码内容 变量变量是可以存放某些值的内存的命名，JavaScript的变量类型都包括 数值类型 number 字符串类型 string 对象类型 object 布尔类型 boolean 函数类型 function JavaScript 里特殊的值 undefined 未定义，所有js变量未赋于初始值的时候，默认值都是 undefined null 空值 NaN 全称是：Not a number。非数字。非数值 JS 中的定义变量格式 示例 关系运算 等于 全等于 == === 等于是简单的做字面值的比较 除了做字面值的比较之外，还会比较两个变量的数据类型 示例 逻辑运算 符号 含义 &amp;&amp; 且运算 || 或运算 ! 取反运算 在 JavaScript 语言中，所有的变量，都可以做为一个 boolean 类型的变量去使用。 0 、null、 undefined、””(空串) 都认为是 false 说明 &amp;&amp; 且运算。 有两种情况： 当表达式全为真的时候。返回最后一个表达式的值 当表达式中，有一个为假的时候。返回第一个为假的表达式的值 || 或运算 当表达式全为假时，返回最后一个表达式的值 只要有一个表达式为真。就会把回第一个为真的表达式的值 &amp;&amp; 和 || 有短路。 短路就是说，当这个&amp;&amp;或||运算有结果了之后 。后面的表达式不再执行 示例 数组（重点）数组定义方式JS中数组的定义方式 示例 函数（重点）函数的定义方式第一种方式使用的格式如下 在 JavaScript 语言中，定义带有返回值的函数 ，只需要在函数体内直接使用 return 语句返回值即可！ 示例 第二种方式var 函数名 = function(形参列表) { 函数 } 注：在 Java 中函数允许重载。但是在 JS 中函数的重载会直接覆盖掉上一次的定义 函数的 arguments 隐形参数（只在 function 函数内）就是在 function 函数中不需要定义，但却可以直接用来获取所有参数的变量。我们管它叫隐形参数。 隐形参数特别像 java 基础的可变长参数一样。 public void fun( Object … args ); 可变长参数其实是一个数组。 那么 js 中的隐形参数也跟 java 的可变长参数一样。操作类似数组。 示例 JS 中的自定义对象Object 形式的自定义对象 示例 {}花括号形式的自定义对象 示例 js 中的事件事件是电脑输入设备与页面进行交互的响应。我们称之为事件 常用的事件 事件 描述 onload 加载完成事件 页面加载完成之后，常用于做页面 js 代码初始化操作 onclick 单击事件 常用于按钮的点击响应操作 onblur 失去焦点事件 常用用于输入框失去焦点后验证其输入内容是否合法 onchange 内容发生改变事件 常用于下拉列表和输入框内容发生改变后操作 onsubmit 表单提交事件 常用于表单提交前，验证所有表单项是否合法 事件的注册事件的注册（绑定）：告诉浏览器，当事件响应后要执行哪些操作代码。 静态注册事件通过html标签的事件属性直接赋予事件响应后的代码 动态注册事件先通过 js 代码得到标签的 dom 对象，然后再通过 dom 对象.事件名 = function(){} 这种形式赋于事件响应后的代码。 动态注册基本步骤： 获取标签对象 标签对象.事件名 = fucntion(){} onload加载完成事件静态方法 动态方法 onclick 单击事件静态方法 动态方法 onblur 失去焦点事件静态方法 动态方法 onchange 内容发生改变事件静态方法 动态方法 onsubmit 表单提交事件静态方法 动态方法 DOM模型 DOM 全称是 Document Object Model 文档对象模型 将文档中的标签，属性，文本，转换成为对象来管理。 Document文档树内存结构 Document对象Document 对象的理解 Document 它管理了所有的 HTML 文档内容。 document 它是一种树结构的文档。有层级关系。 它让我们把所有的标签 都 对象化 我们可以通过 document 访问所有的标签对象 Document 对象中的方法介绍document.getElementById(elementId)通过标签的 id 属性查找标签 document.getElementsByName(elementName)通过标签的 name 属性查找标签 dom 对象，elementName 标签的 name 属性值 document.getElementsByTagName(tagname)通过标签名查找标签 dom 对象。tagname 是标签名 document.createElement( tagName)通过给定的标签名，创建一个标签对象。tagName是要创建的标签名 注： document 对象的三个查询方法，如果有 id 属性，优先使用 getElementById 方法来进行查询 如果没有 id 属性，则优先使用 getElementsByName 方法来进行查询 如果 id 属性和 name 属性都没有最后再按标签名查 getElementsByTagName 以上三个方法，一定要在页面加载完成之后执行，才能查询到标签对象 节点的常用属性和方法节点就是标签对象 方法 通过具体的元素节点调用 getElementsByTagName() 方法，获取当前节点的指定标签名孩子节点 appendChild( oChildNode ) 方法，可以添加一个子节点，oChildNode 是要添加的孩子节点 属性 属性 描述 childNodes 获取当前节点的所有子节点 firstChild 获取当前节点的第一个子节点 lastChild 获取当前节点的最后一个子节点 parentNode 获取当前节点的父节点 nextSibling 获取当前节点的下一个节点 previousSibling 获取当前节点的上一个节点 className 用于获取或设置标签的 class 属性 innerHTML 表示获取/设置起始标签和结束标签中的内容 innerText 表示获取/设置起始标签和结束标签中的文本 示例HTML部分 CSS部分 "},{"title":"HTML&CSS","date":"2021-03-21T16:00:00.000Z","url":"/2021/03/22/HTML&CSS/","categories":[["Java Web","/categories/Java-Web/"]],"content":"网页的组成部分页面由三部分组成，分别是 内容（结构）：在页面中可以看到的数据。称之为内容。一般内容使用 html 技术来展示 表现：内容在页面上表现的形式比如颜色、布局、大小等。一般使用CSS技术实现 行为：指的是页面中元素与输入设备交互的响应。一般使用javascript技术实现 HTML简介 Hyper Text Markup Language(超文本标记语言)，简称：HTML HTML通过标签来标记要显示的网页中的各个部分。网页文件本身是一种文本文件，通过在文本文件中添加标记符，可以告诉浏览器如何显示其中的内容（例如：文字处理、画面安排、图片显示等） HTML示例 注：Java 文件是需要先编译，再由 java 虚拟机跑起来。但 HTML 文件它不需要编译，直接由浏览器进行解析执行。 书写规范 Html 的代码注释： HTML标签简介 标签格式：&lt; 标签名 &gt;封装的数据&lt; /标签名 &gt; 标签名大小写不敏感 标签拥有自己的属性 基本属性：bgcolor=”red”————可以修改简单的样式效果 事件属性：onclick=”alert(‘你好！’);”———可以直接设置事件响应后的代码 单标签&amp;双标签 单标签格式：&lt;标签名 /&gt;————&lt; br/ &gt;换行，&lt; hr/ &gt;水平线 双标签格式：&lt; 标签名 &gt; …封装的数据…&lt; /标签名 &gt; 标签语法 标签不能交叉嵌套 标签必须正常关闭 属性必须有值，属性值必须加引号 注释不能嵌套 注意:html 代码不是很严谨。有时候标签不闭合，也不会报错。 常用标签介绍font字体标签 特殊字符常用的字符实体 显示结果 描述 实体名称 实体编号 空格 &amp; nbsp; &amp; #160; &lt; 小于 &amp; lt; &amp; #60; &gt; 大于 &amp; gt; &amp; #62; &amp; 和 &amp; amp; &amp; #38; “ 双引 &amp; quot; &amp; #34; ‘ 单引 &amp; apos;（IE不支持） &amp; #39; 其他特殊字符 显示结果 描述 实体名称 实体编号 ¢ 分 &amp; cent; &amp; #162; £ 镑 &amp; pound; &amp; #163; ￥ 日元 &amp; yen; &amp; #165; &sect; 节 &amp; sect; &amp; #167; © 版权 &amp; copy; &amp; #169; ® 已注册 &amp; reg; &amp; #174; &times; 乘号 &amp; times; &amp; #215; &divide; 除号 &amp; divide; &amp; #247; 标题标签 超链接（重点）在网页中所有点击之后可以跳转的内容都是超连接 列表标签 img标签img 标签可以在 html 页面上显示图片。 表格标签（重点） 跨行跨列表格（重点） iframe 框架标签（内嵌窗口）ifarme 标签它可以在一个 html 页面上,打开一个小窗口,去加载一个单独的页面 表单标签（重点）表单就是 html 页面中,用来收集用户信息的所有元素集合.然后把这些信息发送给服务器 表单提交细节 其他标签 CSS 技术CSS 技术介绍 CSS 是「层叠样式表单」。是用于(增强)控制网页样式并允许将样式信息与网页内容分离的一种标记性语言。 语法规则 选择器：浏览器根据“选择器”决定受 CSS 样式影响的 HTML 元素（标签）。 属性 (property) 是你要改变的样式名，并且每个属性都有一个值。属性和值被冒号分开，并 由花括号包围，这样就组成了一个完整的样式声明（declaration），例如：p {color: blue} 多个声明：如果要定义不止一个声明，则需要用分号将每个声明分开。虽然最后一条声明的 最后可以不加分号(但尽量在每条声明的末尾都加上分号） CSS 注释：/注释内容/ CSS和HTML结合方式第一种在标签的 style 属性上修改标签样式。 缺点 如果标签多了。样式多了。代码量非常庞大 可读性非常差 CSS 代码没什么复用性可言 第二种在 head 标签中，使用 style 标签来定义各种自己需要的 CSS 样式 缺点 只能在同一页面内复用代码，不能在多个页面中复用 css 代码 维护起来不方便，实际的项目中会有成千上万的页面，要到每个页面中去修改，工作量太大 第三种把 css 样式写成一个单独的 css 文件，再通过 link 标签引入即可复用。 CSS文件内容 HTML文件内容 CSS选择器标签名选择器 id选择器 class 选择器（类选择器） 组合选择器组合选择器可以让多个选择器共用同一个 css 样式 常用样式字体颜色 宽度 高度 背景颜色 字体样式 红色 1 像素实线边 DIV 居中 文本居中 超连接去下划线 表格细线 列表去除修饰"},{"title":"NewIO","date":"2021-03-20T16:00:00.000Z","url":"/2021/03/21/NewIO/","categories":[["Java","/categories/Java/"]],"content":"NewIO简介 Java NIO(New IO)是从java1.4版本开始引入的一个新的IO API，可以代替标准的Java IO API NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。 Java NIO和IO的主要区别 IO NIO 面向流（Stream Oriented） 面向缓冲区（Buffer Oriented） 阻塞IO（Blocking IO） 非阻塞IO（Non Blocking IO） 无 选择器（Selectors） 缓冲区(Buffer)&amp;通道(Channel)简介 Java NIO系统的核心在于：通道(Channel)和缓冲区 (Buffer)。通道表示打开到 IO 设备(例如：文件、 套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。 缓冲区（Buffer）简介 缓冲区（Buffer）：一个用于特定基本数据类 型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。 Java NIO 中的 Buffer 主要用于与 NIO 通道进行 交互，数据是从通道读入缓冲区，从缓冲区写 入通道中的 Buffer常用子类Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类 ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自 管理的数据类型不同而已。都是通过如下方法获取一个 Buffer 对象 Buffer中的重要概念 容量 (capacity) ：表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改 **限制 (limit)**：第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量 **位置 (position)**：下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制 **标记 (mark)与重置 (reset)**：标记是一个索引，通过 Buffer 中的 mark() 方法 指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这 个 position. 注意：标记、位置、限制、容量遵守以下不变式： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity Buffer常用方法 方法 描述 Buffer clear() 清空缓冲区并返回对缓冲区的引用 Buffer flip() 将缓冲区的界限设置为当前位置，并将当前位置重置为0 int capacity() 返回Buffer的capacity大小 boolean hasRemaining() 判断缓冲区中是否还有元素 int limit() 返回Buffer的界限（limit）的位置 Buffer limit(int n) 将设置缓冲区界限为n，并返回修改后的buffer对象 Buffer mark() 对缓冲区设置标记 int position() 返回缓冲区的当前位置position Buffer position(int n) 将设置缓冲区的当前位置为n,并返回修改后的Buffer对象 int remaining() 返回position和limit之间的元素个数 Buffer reset() 将位置position转到以前设置的mark所在的位置 Buffer rewind() 将位置设为0，取消设置的mark Buffer的数据操作使用Buffer读写数据一般遵循以下四个步骤: 写入数据到Buffer 调用flip()方法 从Buffer中读取数据 调用clear()方法或者compact()方法 当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。 一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用**clear()或compact()**方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。 Buffer 所有子类提供了两个用于数据操作的方法：get() 与 put() 方法 获取 Buffer 中的数据 get()：读取单个字节 get(byte[] dst)：批量读取多个字节到dst中 get(int index)：读取指定索引位置的字节（不会移动position） 放入数据到 Buffer 中 put(byte b)：将给定单个字节写入缓冲区的当前位置 put(byte[] src)：将src中的字节写入缓冲区的当前位置 put(int index,byte b)：将指定字节写入缓冲区的索引位置（不会移动position） 示例代码 直接与非直接缓冲区 非直接缓冲区：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中,遇到大文本的文件时 效率及其低下. 直接缓冲区：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率 注意：其中传统的io和 nio的accocate()都是非直接缓冲区. 通道(Channel)简介 通道（Channel）：由 java.nio.channels 包定义的。Channel 表示 IO 源与目标打开的连接。 Channel 类似于传统的“流”。只不过 Channel 本身不能直接访问数据，Channel 只能与 Buffer 进行交互 Channel实现类 FileChannel：用于读取、写入、映射和操作文件的通道 DatagramChannel：通过UDP读写网络中的数据通道 SocketChannel：通过TCP读写网络中的数据 ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel 获取Channel获取通道的一种方式是对支持通道的对象调用 getChannel() 方法 支持通道的类： 本地IO: FileInputStream FileOutputStream RandomAccessFile 网络IO: DatagramSocket Socket ServerSocket 获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获 取字节通道。或者通过通道的静态方法 open() 打开并返回指定通道 Channel的数据传输将 Buffer 中数据写入 Channel 从 Channel 读取数据到 Buffer 分散(Scatter)和聚集(Gather)分散读取（Scattering Reads）是指从 Channel 中读取的数据“分 散”到多个 Buffer 中。 注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满 聚集写入（Gathering Writes）是指将多个 Buffer 中的数据“聚集” 到 Channel。 注意：按照缓冲区的顺序，写入 position 和 limit 之间的数据到 Channel 。 通道之间的数据传输transferFrom()将数据从源通道传输到其他 Channel transferTo()将数据从源通道传输到其他Channel中 FileChannel常用方法 方法 描述 int read(ByteBuffer dst) 从 Channel 中读取数据到 ByteBuffer long read(ByteBuffer[] dsts) 将 Channel 中的数据“分散”到 ByteBuffer[] int write(ByteBuffer src) 将 ByteBuffer 中的数据写入到 Channel long write(ByteBuffer[] srcs) 将 ByteBuffer[] 中的数据“聚集”到 Channel long position() 返回此通道的文件位置 FileChannel position(long p) 设置此通道的文件位置 long size() 返回此通道的文件的当前大小 FileChannel truncate(long s) 将此通道的文件截取为给定大小 void force(boolean metaData) 强制将所有对此通道的文件更新写入到存储设备中 NIO的非阻塞式网络通信阻塞与非阻塞 传统的 IO 流都是阻塞式的。也就是说，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行 IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理， 当服务器端需要处理大量客户端时，性能急剧下降 Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO可以让服务器端使用一个或有限几个线程来同 时处理连接到服务器端的所有客户端 选择器（Selector） 选择器（Selector） 是 SelectableChannel 对象的多路复用器，Selector 可 以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector 可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心 选择器的应用创建 Selector 向选择器注册通道 当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。 可以监听的事件类型（可使用 SelectionKey 的四个常量表示） 读 : SelectionKey.OP_READ 写 : SelectionKey.OP_WRITE 连接 : SelectionKey.OP_CONNECT 接收 : SelectionKey.OP_ACCEPT 若注册时不止监听一个事件，则可以使用“位或”操作符连接 SelectionKey：表示 SelectableChannel 和 Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整 数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。 方法 描述 int interestOps() 获取感兴趣事件集合 int readyOps() 获取通道已经准备就绪的操作的集合 SelectableChannel channel() 获取注册通道 Selector selector() 返回选择器 boolean isReadable() 检测Channel中读事件是否就绪 boolean isWritable() 检测Channel中写事件是否就绪 boolean isConnectable() 检测Channel中连接是否就绪 boolean isAcceptable() 检测Channel中接收是否就绪 Selector常用方法 方法 描述 Set&lt; SelectionKey &gt; keys() 所有的 SelectionKey 集合。代表注册在该Selector上的Channel selectedKeys() 被选择的 SelectionKey 集合。返回此Selector的已选择键集 int select() 监控所有注册的Channel，当它们中间有需要处理的 IO 操作时， 该方法返回，并将对应得的 SelectionKey 加入被选择的 SelectionKey 集合中，该方法返回这些 Channel 的数量。 int select(long timeout) 可以设置超时时长的 select() 操作 int selectNow(); 执行一个立即返回的 select() 操作，该方法不会阻塞线程 Selector wakeup() 使一个还未返回的 select() 方法立即返回 void close() 关闭该选择器 SocketChannelJava NIO中的SocketChannel是一个连接到TCP网络套接字的通道 操作步骤： 打开 SocketChannel 读写数据 关闭 SocketChannel Java NIO中的 ServerSocketChannel 是一个可以 监听新进来的TCP连接的通道，就像标准IO中 的ServerSocket一样。 DatagramChannel Java NIO中的DatagramChannel是一个能收发 UDP包的通道 操作步骤 打开 DatagramChannel 接收/发送数据 管道（Pipe） Java NIO 管道是2个线程之间的单向数据连接。 Pipe有一个source通道和一个sink通道。数据会 被写到sink通道，从source通道读取。 读写操作"},{"title":"JUC","date":"2021-03-17T16:00:00.000Z","url":"/2021/03/18/JUC/","categories":[["Java","/categories/Java/"]],"content":"Java JUC简介在Java 5.0 提供了 java.util.concurrent （简称 JUC ）包，在此包中增加了在并发编程中很常用 的实用工具类，用于定义类似于线程的自定义子 系统，包括线程池、异步 IO 和轻量级任务框架。 提供可调的、灵活的线程池。还提供了设计用于 多线程上下文中的 Collection 实现等 内存可见性 内存可见性：当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。 可见性错误：当读操作与写操作在不同的线程中执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。 我们可以通过同步来保证对象被安全地发布。除此之外我们也可以 使用一种更加轻量级的 volatile 变量。 volatile关键字多个线程访问共享数据时，保证内存中的数据是可见的。相较于synchronized是一种较为轻量级的同步策略（因为它不会引起线程上下文的切换和调度）。 注意: volatile不具备”互斥性”（当一个线程访问主内存时，其他线程依旧可以访问） volatile不能保证变量的”原子性”（不可分割） 可见性问题内存可见性：当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。 执行后发现，子线程执行时已经将 flag 设置成 true，但主线程执行时没有读到 flag 的最新值，导致控制台没有输出上面的句子。 问题原因JMM（Java内存模型）机制问题 JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。 JMM 的规定： 所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。 线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量。 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。 JMM抽象示意图 解决方法两种方案：加锁或使用volatile关键字 方法一：synchronized 原因：当一个线程进入 synchronized 代码块后，线程获取到锁，会清空本地内存，然后从主内存中拷贝共享变量的最新值到本地内存作为副本，执行代码，又将修改后的副本值刷新到主内存中，最后线程释放锁。 PS：除了 synchronizer 外，其它锁也能保证变量的内存可见性。 方法二：volatile关键字 原因：使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 CPU 总线嗅探机制告知其他线程该变量副本已经失效，需要重新从主内存中读取。 volatile 保证了不同线程对共享变量操作的可见性，也就是说一个线程修改了 volatile 修饰的变量，当修改后的变量写回主内存时，其他线程能立即看到最新值。 volatile的原子性问题原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。 在多线程环境下，volatile 关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性。也就是说，多线程环境下，使用 volatile 修饰的变量是线程不安全的。 可以使用锁机制，或者使用原子类（如 AtomicInteger）解决 注意：对任意单个使用 volatile 修饰的变量的读 / 写是具有原子性。但类似于 flag = !flag 这种复合操作不具有原子性。简单地说就是，单纯的赋值操作是原子性的。 总结 volatile 修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值；或者作为状态变量，如 flag = ture，实现轻量级同步。 volatile 属性的读写操作都是无锁的，它不能替代 synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是低成本的。 volatile 提供了可见性，任何一个线程对其的修改将立马对其他线程可见。volatile 属性不会被线程缓存，始终从主存中读取。 volatile 可以使纯赋值操作是原子的，如 boolean flag = true; falg = false。 原子变量,CAS算法原子变量类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可 将 volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。 类 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对 相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。 AtomicIntegerArray、AtomicLongArray 和AtomicReferenceArray 类进一步扩展了原子操 作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方 面也引人注目，这对于普通数组来说是不受支持的。 核心方法：boolean compareAndSet(expectedValue, updateValue) java.util.concurrent.atomic 包下提供了一些原子操作的常用类 AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference AtomicIntegerArray 、AtomicLongArray AtomicMarkableReference AtomicReferenceArray AtomicStampedReference CAS算法 CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器 操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。 CAS 是一种无锁的非阻塞算法的实现。 函数公式：CAS(V,E,N)。 V：表示要更新的变量 E：表示预期值 N：表示新值 当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的 值，否则不会执行任何操作。 优点它不会像synchronized一样，当一个线程访问共享数据的时候，别的线程都在阻塞。synchronized不管是否有线程冲突都会进行加锁。由于CAS是非阻塞的，它死锁问题天生免疫，并且线程间的相互影响也非常小，更重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，所以它要比锁的方式拥有更优越的性能。 实现过程原理图： 如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作。 模拟CAS算法实现 ConcurrentHashMap锁分段机制简介 ConcurrentHashMap 同步容器类是Java 5 增加的一个线程安全的哈希表。对 与多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段” 机制替代 Hashtable 的独占锁。进而提高性能。 此包还提供了设计用于多线程上下文中的 Collection 实现： ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、 CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给 定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap， ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远 大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。 ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 底层实现原理jdk7版本 jdk8版本 改进一：取消segments字段，直接采用transient volatile HashEntry&lt;K,V&gt; table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。 改进二：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中。如果hash之后散列的很均匀，那么table数组中的每个队列长度主要为0或者1。但实际情况并非总是如此理想，虽然ConcurrentHashMap类默认的加载因子为0.75，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。 基本操作读操作因为读操作不会改变数值的大小，所以它是不加锁的，而且HashEntry加了volatile关键字，也可以保证读取到的值是最新值。同时读操作可以多个线程进行操作，即至少可以有16个线程操作，至多无上限，只要在CPU的能力承受范围内即可。 写操作具有锁机制，可以同时让16（默认容量的）个线程进行操作，每个线程进入各自所需寻找的Segment数组中的HashEentry数组进行操作，大大的提高了操作效率。 主要特点 存储方面采用了数组加数组加链表的形式 在线程对每部分的Segment段读取数据时，可以多个线程访问，效率较高；在线程对每部分的Segment段写数据时，加锁机制启动，只许一个进入，线程安全 安全性方面采用了分段的锁机制机，即保证了多线程的安全性，又提高了访问的效率 HashMap、HashTable和ConcurrentHashMap的区别？底层结构 HashMap是数组加链表 HashTable是数组加链表 ConcurrentHashMap是数组加数组加链表 扩容 HashMap是初始容量右移一位加一 HashTable是初始容量右移一位 ConcurrentHashMap是初始的Segment数组保持不变，只将HashEntry的数组进行扩容 继承关系 HashMap是继承于 extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable HashTable是继承于extends Dictionary&lt;K,V&gt;implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable ConcurrentHashMap是继承于 extends AbstractMap&lt;K, V&gt;implements ConcurrentMap&lt;K, V&gt;, Serializable 在线程安全方面： HashMap在单线程下是安全的，多线程下不安全， HashTable在多线程下是安全的，因为它在基本操作前面都加上了synchronized锁，即就是就算在多个线程操作的时候，只要有一个线程进入了基本方法内，其他的线程就必须等待。只有当第一个线程操作结束，释放了锁，其他的线程才可以进行操作。虽然说在多线程操作的时候线程是安全的但是效率比较低，毕竟那么多的线程就在等一把锁。 JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。 CountDownLatch闭锁简介 CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作 之前，它允许一个或多个线程一直等待。 闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行 确保某个计算在其需要的所有资源都被初始化之后才继续执行 确保某个服务在其依赖的所有其他服务都已经启动之后才启动 等待直到某个操作所有参与者都准备就绪再继续执行 CountDownLatch 定义了一个计数器，和一个阻塞队列， 当计数器的值递减为0之前，阻塞队列里面的线程处于挂起状态，当计数器递减到0时会唤醒阻塞队列所有线程，这里的计数器是一个标志，可以表示一个任务一个线程，也可以表示一个倒计时器，CountDownLatch可以解决那些一个或者多个线程在执行之前必须依赖于某些必要的前提业务先执行的场景。 常用方法 代码实现 上面代码中计算10个LanchDemo线程计算0-50000的偶数，并计算所用时间。当调用LatchDemo的线程时，10个线程和计算时间的主线程同时运行，没办法得到最后的计算时间，所以运用latch.await();函数来让LanchDemo进入阻塞状态，并用CountDown();函数对计数器进行递减1操作，等待10个全部执行完毕后，计数器递减为0，当前线程会唤醒阻塞队列中的所有线程。 实现Callable接口简介 Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常。 Callable 需要依赖FutureTask ，FutureTask 也可以用作闭锁。 代码实现 Lock同步锁简介 在 Java 5.0 之前，协调共享对象的访问时可以使用的机 制只有 synchronized 和 volatile 。Java 5.0 后增加了一些 新的机制，但并不是一种替代内置锁的方法，而是当内 置锁不适用时，作为一种可选择的高级功能。 ReentrantLock 实现了 Lock 接口，并提供了与 synchronized 相同的互斥性和内存可见性。但相较于 synchronized 提供了更高的处理锁的灵活性。 应用场景当一个代码块被synchronized修饰了，一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况： 获取锁的线程执行完了该代码块，然后线程释放对锁的占有 线程执行发生异常，此时JVM会让线程自动释放锁 那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能地等待，这多么影响程序执行效率。 因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断） 代码实现 生产者消费者问题使用Synchronized和Object中的wait()&amp;notifyAll()实现 使用Lock&amp;Condition控制线程通信实现Condition Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用 法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关 联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版 本中的不同。 在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是 await、signal 和 signalAll。 Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得 Condition 实例，请使用其 newCondition() 方法。 题目：线程按序交替编写一个程序，开启三个线程，这三个线程的ID分别为A,B,C，每个线程将自己的ID在屏幕上打印10遍，要求输出的结果必须按顺序显示如：ABCABCABC…依次递归 ReadWriteLock读写锁简介 ReadWriteLock 维护了一对相关的锁，一个用于只读操作， 另一个用于写入操作。只要没有 writer，读取锁可以由 多个 reader 线程同时保持。写入锁是独占的。 ReadWriteLock 读取操作通常不会改变共享资源，但执行 写入操作时，必须独占方式来获取锁。对于读取操作占 多数的数据结构。 ReadWriteLock 能提供比独占锁更高 的并发性。而对于只读的数据结构，其中包含的不变性 可以完全不需要考虑加锁操作。 示例代码 互斥锁一次只允许一个线程访问共享数据，哪怕进行的是只读操作；读写锁允许对共享数据进行更高级别的并发访问：对于写操作，一次只有一个线程（write线程）可以修改共享数据，对于读操作，允许任意数量的线程同时进行读取。 与互斥锁相比，使用读写锁能否提升性能则取决于读写操作期间读取数据相对于修改数据的频率，以及数据的争用——即在同一时间试图对该数据执行读取或写入操作的线程数。 线程八锁 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用 其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻 内，只能有唯一一个线程去访问这些synchronized方法 锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的 synchronized方法 所有的非静态同步方法用的都是同一把锁——实例对象本身，也就是说如果一个实 例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获 取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实 例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非 静态同步方法释放锁就可以获取他们自己的锁。 所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对 象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个 静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取 锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同 步方法之间，只要它们同一个类的实例对象！ 代码示例 线程八锁关键 非静态方法的锁默认为 this，静态方法的锁为对应的class 实例 在某一时刻内，只能有一个线程持有锁，无论几个方法。 线程池简介 提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。 第四种获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在 执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行 任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。 工具类: Executors ExecutorService newFixedThreadPool():创建固定大小的线程池 ExecutorService newCachedThreadPool():缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。 ExecutorService newSingleThreadExecutor(): 创建单个线程池。线程池中只有一个线程 ScheduledExecutorService newScheduledThreadPool():创建固定大小的线程，可以延迟或定时的执行任务。 线程池的体系结构 java.util.concurrent.Executor : 负责线程的使用与调度的根接口 –ExecutorService 子接口: 线程池的主要接口 –ThreadPoolExecutor 线程池的实现类 –ScheduledExecutorService 子接口：负责线程的调度 代码实现 线程调度一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令。 ForkJoinPool分支/合并框架 工作窃取Fork/Join 框架就是在必要的情况下，将一个大任务，进行**拆分(fork)**成 若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总。 Fork/Join 框架与线程池的区别 采用 “工作窃取”模式（work-stealing）： 当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加 到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队 列中。 相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务 的处理方式上.在一般的线程池中，如果一个线程正在执行的任务由于某些 原因无法继续运行，那么该线程会处于等待状态。而在fork/join框架实现中， 如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理 该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了 线程的等待时间，提高了性能。 代码实例"},{"title":"JDBC核心技术2","date":"2021-03-16T16:00:00.000Z","url":"/2021/03/17/JDBC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF2/","categories":[["JDBC","/categories/JDBC/"]],"content":"数据库事务数据库事务介绍 事务：一组逻辑操作单元，是数据从一种状态变换到另一种状态 事务处理（事务操作）：保证所有事物都作为一个工作单元来执行，即使出现故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交（commit）,那么这些修改就永久地保存下来；要么数据库管理系统将放弃所做的所有修改，整个事务回滚（rollback）到最初状态。 为确保数据库中的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部退回到开始状态。 JDBC事务处理 数据一旦被提交，就不可回滚。 数据什么时候意味着提交？ 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。 关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一连接下。 JDBC程序中为了让多个SQL语句作为一个事务执行： 调用Connection对象的setAutoCommit(false);以取消自动提交事务 在所有的SQL语句都成功执行后，调用Commit();方法提交事务 在出现异常时，调用rollback();方法回滚事务 若此时Connection没有被关闭，还可能被重复利用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 例如：用户AA向用户BB转账100 对数据库的操作的方法为： 事务的ACID属性 原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另一个一致性状态。 隔离性（Isolation） 事物的隔离性是指一个事务的执行不能被其他事务干扰，即一个事物内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。 数据库的并发问题 对于同时运行的多个事务，当这些事务访问数据库中的相同数据时，如果没有采取必要的隔离机制，就会导致各种并发问题： 脏读：对于两个事务T1，T2，T1已经读取了被T2更新但还没有被提交的字段。之后，若T2回滚，T1读取的内容就是临时且无效的。 不可重复读：对于两个事务T1，T2，T1读取了一个字段，然后T2更新了该字段。之后，T1再次读取同一个字段，值就不同了。 幻读：对于两个事务T1，T2，T1从一个表中读取了一个字段，然后T2在该表中插入了一些新的行。之后，如果T1再次读取同一个表，就会多出几行。 数据库事务的隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性弱。 四种隔离级别 数据库提供的4种事务隔离级别 隔离级别 描述 READ UNCOMMITED（读未提交数据） 允许事务读取未被其他事务提交的变更。脏读，不可重复读和幻读的问题都会出现 READ COMMITED（读已提交数据） 只允许事务读取已经被其他事务提交的变更。可以避免脏读，但不可重复读和幻读问题仍然可能出现 REPEATABLE READ（可重复读） 确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事物对这个字段进行更新，可以避免脏读和不可重复读，但幻读的问题仍然存在 SERIALIZABLE（串行化） 确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作，所有并发问题都可以避免，但性能十分低下 Oracle支持的两种事务隔离级别：READ COMMITED,SERIALIZABLE。Oracle默认的事务隔离级别为：READ COMMITED. Mysql支持四种事务隔离级别。Mysql默认的事务隔离级别为：REPEATABLE READ. 在Mysql中设置事务隔离级别 每启动一个mysql程序，就会获得一个单独的数据库连接，每个数据库连接都有一个全局变量@@tx_isolation,表示当前的事务隔离级别。 查看当前的隔离级别: 设置当前 mySQL 连接的隔离级别: 设置数据库系统的全局的隔离级别: 补充操作： 创建mysql数据库的用户： 授予权限 DAO及相关实现类 DAO:Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create,Retrival,Update,Delete）,而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更利于代码的维护和升级 层次结构： 创建底层DAO（封装了针对于数据表的通用的操作） 创建DAO接口（用于规范针对于customers表的常用操作） 创建DAOImpl实现类（继承父类和接口，具体实现功能） 例如：创建customer表的DAO BaseDAO: CustomerDAO: CustomerImpl: Customer类： 数据库连接池JDBC数据库连接池的必要性 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤： 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接 这种开发模式，存在的问题： 普通的JDBC数据库连接使用DriverManager来获取，每次向数据库建立连接的时候都要将Connection加载到内存中，再验证用户名和密码（得花费0.05s~1s的时间）。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（内存泄漏：保留下来却永远不再使用的对象引用。） 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 数据库连接池技术 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。 数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。 数据库连接池技术的优点 1. 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。 2. 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间 3. 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源 4. 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露 多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 C3P0数据库连接池 获取连接方式一 获取连接方式二 其中，src下的配置文件为：【c3p0-config.xml】 注意： c3p0-0.9.2版本后需再导入数据库连接池的辅助包mchange-commons-java-x.x.x.x.jar。 mysql8.0需要注意c3p0版本。 DBCP数据库连接池 DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件： Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 配置属性说明 属性 默认值 说明 initialSize 0 连接池启动时创建的初始化连接数量 maxActive 8 连接池中可同时连接的最大的连接数 maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制 minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。 maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 poolPreparedStatements false 开启池的Statement是否prepared maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数 minEvictableIdleTimeMillis 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间 removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接 removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收 获取连接方式一： 获取连接方式二： 其中，src下的配置文件为：【dbcp.properties】 Druid（德鲁伊）数据库连接池Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。 其中，src下的配置文件为：【druid.properties】 详细配置参数： 配置 缺省 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this) url 连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里： driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系 Apache-DBUtils实现CRUD操作Apache-DBUtils简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 API介绍： org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler 工具类：org.apache.commons.dbutils.DbUtils API包说明： 对应的jar包需build path到当前工程下 ResultSetHandler，此接口用于处理数据库查询操作得到的结果集。不同的结果集的情形，由其不同的子类来实现 QueryRunner，提供数据库操作的一系列重载的update()和query()操作 主要API的使用DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLException。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 插入 删除 ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 接口的主要实现类： ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List ScalarHandler：查询单个值对象 测试： 总结"},{"title":"JDBC核心技术1","date":"2021-03-13T16:00:00.000Z","url":"/2021/03/14/JDBC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF1/","categories":[["JDBC","/categories/JDBC/"]],"content":"JDBC概述数据的持久化 持久化(persistece)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以“固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存在磁盘文件、XML数据文件中。 Java中的数据存储技术在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO(Java Data Object)技术 第三方O/R工具，如Hibernate，Mybatis等 JDBC是java访问数据库的基石，JDO，Hibernate、Mybatis等只是更好的封装了JDBC JDBC介绍JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统，通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准java类库，（java.sql.javax.sql）使用这些类库可以以一种标准的方法，方便的访问数据库资源。 JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多了解，从而大大简化和加快了开发过程。 总结：java应用程序直接访问数据库可行，但这意味着java应用程序没有更好的可移植性。因此并不建议这么做。 JDBC体系结构JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。 不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ​ ————面向接口编程 JDBC接口(API)包括两个层次： 面向应用API：Java API，抽象接口，供应用程序开发人员使用(连接数据库，执行SQL语句，获得结果)。 面向数据库API：Java Driver API，供开发商开发数据库驱动程序用。 JDBC程序编写步骤 开始——》导入java.sql包——》 两种方式： SQL Server：JDBC-ODBC桥方式（建立数据源） Oracle、Mysql：纯Java驱动方式（附加相应产商提供的驱动） ——》加载并注册驱动程序——》创建Connection对象——》创建Statement对象——》执行SQL语句——》 不同功能： 查询：使用ResultSet对象——》关闭ResultSet对象——》关闭Statement对象——》关闭Connection对象——》结束。 更新：关闭Statement对象 ——》关闭Connection对象——》结束。 补充：ODBC（Open Database Conectivity,开放式数据库连接），是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由ODBC驱动程序将调用转换成为对特定的数据库的调用请求。 获取数据库连接要素一：Driver接口实现类Driver接口介绍 java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。 Oracle的驱动：oracle.jdbc.driver.OracleDriver Mysql的驱动：com.mysql.jdbc.Driver 将连接数据库所需的jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹存入。 在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path。 注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可 加载与注册JDBC驱动 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”); 注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序 使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来驱动注册 通常不用显式调用DriverManager类的registerDriver()方法来注册驱动程序类的实例，因为Driver接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用DriverManager.registerDriver()方法来注册自身的一个实例。 Mysql的Driver实现类的源码： 要素二：URL JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分间用冒号分隔。 jdbc:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名 例如： 几种常用数据库的 JDBC URL MySQL的连接URL编写方式： jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值 jdbc:mysql://localhost:3306/test jdbc:mysql://localhost:3306/test**?useUnicode=true&amp;characterEncoding=utf8**（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集） jdbc:mysql://localhost:3306/test?user=用户名&amp;password=密码 Oracle9i的连接URL编写方式： jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 jdbc:oracle:thin:@localhost:1521:test SQLServer的连接URL编写方式： jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称 jdbc:sqlserver://localhost:1433:DatabaseName=test 要素三：用户名和密码user,password可以用“属性名=属性值”方式告诉数据库 可以调用DriverManager类的getConnection()方法建立到数据库的连接 数据库连接方式举例方式一： 说明：上述代码中显式出现了第三方数据库的API 方式二： 说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。 方式三: 说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。 方式四： 说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。 方式五（推荐使用）： 其中，配置文件声明在工程的src目录下：【jdbc.properties】 说明：使用配置文件的方式保存配置信息，在代码中加载配置文件 注意：MySQL8.0以下版本应改成：dirverClass=com.mysql.jdbc.Driver 使用配置文件的好处： ①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码②如果修改了配置信息，省去重新编译的过程。 使用PreparedStatement实现CRUD操作操作和访问数据库数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。 在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式： Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行 SQL 存储过程 使用Statement操作数据表的弊端通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。 Statement 接口中定义了下列方法用于执行 SQL 语句： 但是使用Statement操作数据表存在弊端： 存在拼串操作，繁琐 存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。 例如： 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。 PreparedStatement的使用PreparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 PreparedStatement vs Statement 代码的可读性和可维护性。 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止 SQL 注入 Java与SQL对应数据类型转换表 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY , VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 使用PreparedStatement实现增、删、改操作 使用PreparedStatement实现查询操作 说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。 ResultSet与ResultSetMetaDataResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现 ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。 例如: getInt(1), getString(“name”) 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。 ResultSet 接口的常用方法： boolean next() getString() … ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象 ResultSetMetaData meta = rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名 getColumnCount()：返回当前 ResultSet 对象中的列数。 getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 isNullable(int column)：指示指定列中的值是否可以为 null。 isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？ ​ 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData 问题2：关于ResultSetMetaData 如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法即可 获取 ResultSet 中有多少列： 调用 ResultSetMetaData 的 getColumnCount() 方法 获取 ResultSet 每一列的列的别名是什么： 调用 ResultSetMetaData 的getColumnLabel() 方法 资源的释放 释放ResultSet, Statement,Connection。 数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。 JDBC API小结 两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 sql是需要结合列名和表的属性名来写。注意起别名。 两种技术 JDBC结果集的元数据：ResultSetMetaData 获取列数：getColumnCount() 获取列的别名：getColumnLabel() 通过反射，创建指定类的对象，获取指定的属性并赋值 "},{"title":"关于最近学习状态调整这件事","date":"2021-02-28T16:00:00.000Z","url":"/2021/03/01/%E5%B0%91%E5%B9%B4%E3%81%AE%E6%97%A5%E5%B8%B802/","categories":[["少年の日常","/categories/%E5%B0%91%E5%B9%B4%E3%81%AE%E6%97%A5%E5%B8%B8/"]],"content":"正所谓计划赶不上变化（借口），本假期接近尾声，但是学习进度着实是慢了一些。 3月10日到校，预计开学时会看完Oracle数据库。 时光飞逝，找实习的日子不远了，时不我待！加油！ 目前学习状态需要好好调整，空余时间还是多看看技术类文章为好。 根据目前课表来看课程虽然不算少，但是空闲时间也还是有。所以，空闲时间还是以继续学习尚硅谷的课程为主。 游戏的话。。。。混蛋！别想着玩了！ 希望自己能坚持下去 （话说这东西写出来也就只有自己看吧。。。）"},{"title":"MySQL","date":"2021-02-05T16:00:00.000Z","url":"/2021/02/06/202126mysql/","categories":[["MySQL","/categories/MySQL/"]],"content":"启动MySQL服务通过计算机管理方式： ​ 右击计算机—管理—服务—启动或停止MySQL服务 通过命令行方式： ​ 启动：net start mysql服务名 ​ 停止：net stop mysql服务名 MySQL服务端的登录和退出控制台输入 登录：mysql -h 主机IP -P 端口 -u 用户名 -p密码 退出：exit 如果没有写-h 主机，默认就是本机 吐过没有写-P 端口，默认就是3306 MySQL语法规范 不区分大小写 每句话用;或者\\g结尾 各子句一般分行写 关键字不能缩写也不能分行 用缩进提高语句的可读性 MySQL常见命令 show database; 查看当前所有的数据库 create database 数据库名; 创建数据库 drop database 数据库名; 删除数据库 create database 数据库名 character set 字符集; 创建使用指定字符集数据库（默认UTF8） use 库名; 打开指定的库 show tables; 查看当前库的所有表 show tables from 库名; 查看其它库的所有表 create table 表名（列名 列类型,列名 列类型…）; 创建表 desc 表名; 查看表结构 登录到mysql服务端 :select version();没有登陆mysql客户端 :mysql –version/mysql –V 查看服务器版本 mysqldump -u 用户名 -p -B 数据库1 数据库2 数据库n &gt;文件名.sql 备份数据库 Source 文件名.sql 恢复数据库 注释： 单行注释：#注释文字 或 –注释文字 多行注释：/* 注释文字 */ MySQL三层结构所谓安装Mysql数据库，就是在主机安装一个数据库管理系统(DBMS)，这个管理程序可以管理多个数据库，一个数据库一管理多个表，以保存数据。 数据操纵语句(DML)用于添加、删除、修改、查询数据库记录，并检查数据完整性。 插入语法：INSERT INTO 表名(字段名，…) ​ VALUES(值1，…); 特点： 字段类型和值类型一致或兼容，而且一一对应 可以为空的字段，可以不用插入值，或用null填充 不可以为空的字段，必须插入值 字段个数和值的个数必须一致 字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致 修改修改单表语法 修改多表语法 删除方式一：DELETE语句 单表的删除： 多表的删除： 方式二：truncate语句 两种方式的区别： truncate不能加WHERE条件，而DELETE可以加WHERE条件 truncate效率高一点 truncate删除带自增长列的表后，如果再插入数据，数据从1开始 delete删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始 truncate删除不能回滚，delete删除可以回滚 数据查询语句(DQL)基本SELECT语句 列的别名 重命名一个列 便于计算 紧跟列名（也可以在列名和别名之间加入关键字’AS‘，别名使用双引号，以便于在别名中包含空格或特殊字符并区分大小写） 例如： 字符串 字符串可以是 SELECT 列表中的一个字符,数字,日期。 日期和字符只能在单引号中出现。 每当返回一行时，字符串被输出一次。 过滤WHERE子句使用WHERE子句，将不满足条件的行过滤掉。 WHERE子句紧跟FROM子句 比较运算 操作符 含义 = 等于（不是==） &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 &lt;&gt; 不等于（也可以是!=） PS:赋值使用=符号 其他比较运算 操作符 含义 BETWEEN…AND… 在两个值之间（包含边界） IN(值1,值2,值3…) 等于值列表中的一个 LIKE 模糊查询 IS NULL 空值 LIKE： 使用LIKE运算选择类似的值 选择条件可以包含字符或数字： ——%代表0个或多个字符（任意个字符） ——_代表一个字符。 ‘%’和’_’可以同时使用 NULL： 使用IS (NOT) NULL判断是否为空值 逻辑运算 操作符 含义 AND 并 OR 或 NOT 否 ORDER BY子句使用ORDER BY子句排序 ——ASC（ascend）：升序 ——DESC（descend）：降序 ORDER BY子句在SELECT语句的结尾 常见函数 操作符 含义 concat 拼接 substr 截取子串 upper 转换成大写 lower 转换成小写 trim 去掉前后指定的空格和字符 Itrim 去掉左边空格 rtrim 去掉右边空格 replace 替换 lpad 左填充 rpad 右填充 instr 返回字串第一次出现的索引 length 获取字节个数 数学函数 操作符 含义 round 四舍五入 rand 随机数 floor 向下取整 ceil 向上取整 mod 取余 truncate 截断 日期函数 操作符 含义 now 当前系统日期+时间 curdate 当前系统日期 curtime 当前系统时间 str_to_date 将字符转换成日期 date_format 将日期转换为字符 格式符 功能 %Y 四位的年份 %y 2位的年份 %m 月份（01，02…11，12） %c 月份（1，2…11，12） %d 日（01，02…） %H 小时（24小时制） %h 小时（12小时制） %i 分钟（00，01…59） %s 秒（00，01，…59） 流程控制函数if：处理双分支 case语句：处理多分支 ​ 情况1：处理等值判断 ​ 情况2：处理条件判断 条件函数 操作符 含义 version 版本 database 当前库 user 当前连接用户 分组函数分组函数作用于一组数据，并对一组数据返回一个值。 操作符 含义 SUM（列名） 求和 MAX（列名） 最大值 MIN（列名） 最小值 AVG（列名） 平均值 COUNT（） 计数 特点： 以上五个分组函数都忽略null值，除了count（*） sum和avg一般用于处理数值型max、min、count可以处理任何数据类型 都可以搭配distinct使用，用于统计去重后的结果 count的参数可以支持：字段、*、常量值，一般放1 建议使用 count(*) 分组查询&amp;过滤分组语法： 特点： 1、可以按单个字段分组2、和分组函数一同查询的字段最好是分组后的字段3、分组筛选 针对的表 位置 关键字分组前筛选： 原始表 GROUP BY的前面 WHERE分组后筛选： 分组后的结果集 GROUP BY的后面 HAVING 4、可以按多个字段分组，字段之间用逗号隔开5、可以支持排序6、having后可以支持别名 过滤分组：HAVING子句 使用 HAVING 过滤分组: 行已经被分组。 使用了组函数。 满足HAVING 子句中条件的分组将被显示。 多表连接查询如果连接条件省略或者无效则会出现笛卡尔乘积 解决办法：WHERE处添加连接条件 传统模式下的链接：等值连接——非等值连接 等值连接的结果=多个表的交集 n表连接，至少需要n-1个连接条件 多个表不分主次，没有顺序要求 一般为表起别名，提高阅读性和性能 在表中有相同列时，在列名之前加上表名前缀 sql99语法：通过join关键字实现连接 自然连接中是以具有相同名字的列为连接条件的。 可以使用 ON 子句指定额外的连接条件。 这个连接条件是与其它条件分开的。 ON 子句使语句具有更高的易读性。 分类： 内连接：[inner] join on: 也称为等值连接，返回两张表都满足条件的部分 外连接： ——左外连接 left [outer] join on: 取左边的表的全部，右边的表按条件，符合的显示，不符合则显示null 例如： ——右外连接 right [outer] join on: 取右边表的全部，左边的表按条件，符合的显示，不符合则显示null 例如： ——全外连接 full [outer] join on 全外连接是在结果中除了显示满足连接的条件的行外，还显示了join两侧表中所有满足检索条件的行 ——交叉连接 cross join 返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积 SQL99语法多表联查 PS：内连接和where SQL中关键字的执行顺序：from-&gt;on-&gt;join-&gt;where-&gt;group by-&gt;having-&gt;select-&gt;distinct-&gt;union-&gt;order by 如果两张表的数据量都比较大的话，那样就会占用很大的内存空间这显然是不合理的。所以，我们在进行表连接查询的时候一般都会使用JOIN xxx ON xxx的语法，ON语句的执行是在JOIN语句之前的，也就是说两张表数据行之间进行匹配的时候，会先判断数据行是否符合ON语句后面的条件，再决定是否JOIN。 当两张表的数据量比较大，又需要连接查询时，应该使用 FROM table1 JOIN table2 ON xxx的语法，避免使用 FROM table1,table2 WHERE xxx 的语法，因为后者会在内存中先生成一张数据量比较大的笛卡尔积表，增加了内存的开销。 子查询含义：一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询 特点： 子查询都放在小括号内 子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧 子查询优先于主查询执行，主查询使用了子查询的执行结果 子查询根据结果的行数不同分为以下两类： 单行子查询 结果集只有一行 一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 非法使用子查询的情况： 子查询的结果为一组值 子查询的结果为空 多行子查询 结果集有多行 一般搭配多行操作符使用：any、all、in、not in in/not in:属于子查询结果的任意一个就行 any和all往往可以用其他查询代替 子查询中的HAVING子句 首先执行子查询 向主查询中的HAVING子句返回结果 分页查询实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句 语法： 特点： 起始条目索引从0开始 limit语句放在查询语句的最后 公式：SELECT*FROM 表LIMIT(page-1)*sizePerPage,sizePerPage sizePerPage:每页显示条目数 page：要显示的页数 联合查询引入：union 联合、合并 语法： 特点： 多条查询语句的查询列数必须是一致的 多条查询语句的查询的列的类型几乎相同 union代表去重，union all代表不去重 数据定义语句(DDL)用于库和表的创建、修改、删除 库和表的管理 库的管理： 表的管理： 常见类型 整型:Tinyint、Smallint、Mediumint、Int、Integer、Bigint 小数：定点型:DEC(M,D)/DECIMAL(M,D) ​ 浮点型:float、double 字符型:char(M)、varchar(M) 日期型:date、datetime、timestamp、time、year Timestamp支持的时间范围较小，取值范围： 19700101080001——2038年的某个时间 Datetime的取值范围：1000-1-1 ——9999—12-31 timestamp和实际时区有关，更能反映实际的日 期，而datetime则只能反映出插入时的当地时区 timestamp的属性受Mysql版本和SQLMode的影响 很大 Blob型：用于存储二进制数据。类似于char和varchar，不同的是它们包含二进制字符串而不包含非二 进制字符 Enum型：要求插入的值必须属于列表中指定的值之一 如果列表成员为1255，则需要1个字节存储 如果列表成员为25565535，则需要2个字节存储 最多需要65535个成员！ Set型：和Enum类型类似，里面可以保存0~64个成员。和Enum类型最大的区 别是：SET类型一次可以选取多个成员，而Enum只能选一个 根据成员个数不同，存储所占的字节也不同 成员数 字节数 1~8 1 9~16 2 17~24 3 25~32 4 33~64 8 约束 为了保证数据的一致性和完整性，SQL规范以约束的方式对表的数据进行额外的条件限制。 约束是表级的强制规定 可以在创建表时规定约束（通过CREATE TABLE 语句），或者在表创建以后也可以（通过ALTER TABLE 语句） 六种约束 NOT NULL 非空约束，规定某个字段不能为空 UNIQUE 唯一约束，规定某个字段在整个表中是唯一的 PRIMARY KEY 主键（非空且唯一） FOREIGN KEY 外键 CHECK 检查约束 DEFAULT 默认值 注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果 根据约束列的限制，约束可以分为： 单列约束：每个约束只约束一列 多列约束：每个约束可约束多列数据 根据约束的作用范围，约束可分为： 列级约束只能作用在一个列上，跟在列的定义后面 表级约束可以作用在多个列上，不与列一起，而是单独定义 创建表时添加约束 修改表时添加或删除约束 自增长列特点： 不用手动插入值，可以自动提供序列值，默认从1开始，步长为1auto_increment_increment如果要更改起始值：手动插入值如果要更改步长：更改系统变量set auto_increment_increment=值; 一个表至多有一个自增长列 自增长列只能支持数值型 自增长列必须为一个key NOT NULL约束 非空约束用于确保当前列的值不为空值，非空约束只能出现在表对象的列上。 Null类型特征： 所有的类型的值都可以是null，包括int、float等数据类型 空字符串“”不等于null，0也不等于null 例： UNIQUE约束 同一个表可以有多个唯一约束，多个列组合的约束。在创建唯一约束的时候，如果不给唯一约束名称，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引 例： PRIMARY KEY约束 主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值 如果是多列组合的主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。 每个表最多只允许一个主键，建立主键约束可以在列级别创建，也可以在表级别创建。 MySQL的主键名总是PRIMARY，当创建主键约束时，系统默认会在所在的列和列组合上建立对应的唯一索引。 例： 注意：PRIMARY KEY和UNIQUE比较 区别： 一个表只能有一个主键，但可以有多个唯一键 主键不允许为空，唯一键可以为空 相同点： 都具有唯一性 都支持组合键，但不推荐 FOREIGN KEY约束 外键约束是保证一个或两个表之间的参照完整性， 外键是构建于一个表的两个字段或是两个表的两个字 段之间的参照关系。 从表的外键值必须在主表中能找到或者为空。当主 表的记录被从表参照时，主表的记录将不允许删除， 如果要删除数据，需要先删除从表中依赖该记录的数 据，然后才可以删除主表的数据。 插入数据，先插入主表。删除数据，先删除从表 注意：外键约束的参照列，在主表中引用的只能是 主键或唯一键约束的列 同一个表可以有多个外键约束 注意： FOREIGN KEY：在表级指定子表中的列 REFERENCES：表示在父表中的列 ON DELETE CASCADE(级联删除): 当父表中的列被删除 时，子表中相对应的列也被删除 ON DELETE SET NULL(级联置空): 子表中相应的列置空 CHECK约束MySQL可以使用check约束，但check约束对数据 验证没有任何作用,添加数据时，没有任何错误或 警告 DEFAULT约束DEFAULT 约束用于向列中插入默认值。 如果没有规定其他的值，那么会将默认值添加到所有的新记录。 索引提高数据库性能，当不使用索引时进行数据操作会对全表进行扫描，造成资源浪费。使用索引时，会形成一个索引的数据结构，比如二叉树 但是使用索引会导致对磁盘占用增加，并且对DML(update、delete、insert)语句的效率影响。因为每次对数据本身进行操作，都会导致索引创建的数据结构进行更改。 类型 主键索引，主键自动的为主索引(类型Primary key) 唯一索引(UNIQUE) 普通索引(INDEX) 全文索引(FULLTEXT)[适用于MylSAM] 一般开发，不使用mysql自带的全文索引，而是使用：全文搜索Solr和ElasticSearch(ES) 普通索引这是最基本的索引，它没有任何限制 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。 唯一索引索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一 主键索引主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引 较为频繁的作为查询条件字段应该创建索引 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件 更新非常频繁的字段不适合创建索引 不会出现在WHERE子句中字段不应该创建索引 事务事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个SQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的是数据将返回到事务开始以前的状态。如果单元中的所有SQL语句均执行成功，则事务顺利执行。 事务的属性 原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）：事务必须使数据库从一个一致性状态变换到另外一个一致性状态 隔离性（Isolation）：事物的隔离性是指一个事务的执行不能被其他事务干扰，即一个事物内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能相互干扰 持久性（Durability）：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响 事务分类隐式事务没有明显的开启和结束，本身就是一条事务可以自动提交，比如：INSERT、UPDATE、DELETE、 显式事务步骤： 开启事务： set autocommit=0; start transaction;(可以省略) 编写一组逻辑SQL语句（注意：SQL语句支持的是INSERT、UPDATE、DELETE） 设置回滚点：savepoint 回滚点名; 结束事务 ·提交：commit; -回滚：rollback; -回滚到指定地方：rollback to 回滚点名; 并发事务多个事务同时操作同一个数据的相同数据时会引发下列并发问题 脏读：对于两个事务 T1, T2,。T1 读取了已经被 T2 更新但还没有被提交的字段之后, 若 T2 回滚, T1读取的内容就是临时且无效的. 不可重复读：对于两个事务T1, T2。T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了. 幻读：对于两个事务T1, T2。T1 从一个表中读取了一个字段, 然后 T2 在该表中插 入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行. 解决方法： 通过设置隔离级别来解决并发问题 数据库事务的隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。 隔离级别：一个事务与其他事务隔离的程度。数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。 四种事务隔离级别 隔离级别 描述 READ UNCOMMITTED(读未提交数据) 允许事务读取未被其他事务提交的变更。脏读、不可重复读、幻读的问题都会出现。 READ COMMITTED(读已提交数据) 只允许事务读取已经被其他事务提交的变更，可以避免脏读，但不可重复读和幻读问题仍可能出现。 REPEATABLE READ(可重复读) 确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复读，但幻读的问题仍然存在。 SERIALIZABLE(串行化) 确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，所有并发问题都i可以避免，但性能十分低下。 设置隔离级别 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每 个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的 事务隔离级别. 视图MySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的，只保存了SQL逻辑，不保存查询结果 应用于： 多个地方用到同样的查询结果 该查询结果使用的SQL语句较复杂 好处： 重用SQL语句 简化复杂的SQL操作，不必知道它的查询细节 保护数据，提高安全性 语法： 创建视图 OR REPLACE：表示在创建视图时候会替换已有视图 ALGORITHM：表示视图选择算法 [WITH [CASCADED | LOCAL] CHECK OPTION]：表示视图在更新时保证在视图的权限范围之内 推荐使用WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 修改视图 删除视图 查看视图 DML操作更新视图因为视图本身并没有数据，因此对视图的DML操作最终都体现在基表上。 插入： 修改： 删除 注意：视图一般用于查询，而不是更新，所以具备以下特点的视图都不允许更新 包含分组函数：GROUP BY、DISTINCT、HAVING、UNION JOIN 常量视图 WHRER后的子查询用到了FROM中的表 用到了不可更新的视图 视图和表的对比 关键字 是否占用物理空间 使用 视图 VIEW 占用较小，只保存SQL逻辑 一般用于查询 表 TABLE 保存实际的数据 增删改查 变量系统变量说明：变量由系统提供，不用自定义.分为全局变量和会话变量 全局变量服务器层面上的，必须拥有super权限才能为系统变量赋值，作用域为整个服务器，也就是针对于所有连接(会话)有效 语法： 查看全局变量 查看满足条件的部分全局变量 查看指定的全局变量的值 为全局变量赋值 方式一： 方式二： 注意：如果没有显式声明GLOBAL还是SESSION，默认SESSION 会话变量服务器为每一个连接的客户端都提供了系统变量，作用域为当前的连接(会话) 查看所有会话变量 查看满足条件的部分会话变量 查看指定的会话变量的值 为某个会话变量赋值 自定义变量用户变量作用域：针对于当前连接(会话)生效 位置：BEGIN END里面，也可以放在外面 使用： 赋值 更新值 方式一： 方式二： 使用 局部变量作用域：仅仅在定义它的BEGIN END中有效 位置：只能放在BEGIN END 中，而且只能放在第一句 使用： 声明 赋值或更新 方式一： 方式二： 使用 存储过程和函数事先经过编译并存储在数据库中的一段SQL语句的集合。 好处： 简化应用开发人员的很多工作 减少数据在数据库和应用服务器之间的传输 提高了数据处理效率 存储过程创建存储过程 注意： 参数模式：IN、OUT、INOUT，其中IN可以省略 存储过程体的每一条SQL语句都需要用分号结尾 调用 查看 删除 函数创建函数 注意：函数体中肯定会有RETURN语句 调用函数 查看函数 删除函数 函数和存储过程的区别 关键字 调用语法 返回值 应用场景 函数 FUNCTION SELECT 函数() 只能有一个 一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个 存储过程 PROCEDURE CALL 存储过程() 可以有0个或多个 一般用于更新 流程控制结构分支结构if函数功能：实现简单双分支 语法：if(条件，值1，值2) 特点：可以用在任何位置 case语句功能：实现多分支 语法1： 语法2: 特点： 可以放在任何位置 如果放在BEGIN END外面，作为表达式结合着其他语句使用 如果放在BEGIN END里面，一般作为独立的语句使用 if elseif语句功能：实现多分支 语法： 位置： 只能放在 BEGIN END中 应用场合 if函数 简单双分支 case结构 等值判断的多分支 if结构 区间判断的多分支 循环结构位置： 只能放在BEGIN END中 特点：都能实现循环结构 while语法： loop语法： repeat语法： 循环控制语句 leave:类似于break，用于跳出所在循环 iterate:类似于continue，用于结束本次循环，继续下一次 对比 这三种循环都可以省略名称，但如果循环中加入了循环控制语句则必须添加名称 loop：一般用于实现简单的死循环 while：先判断后执行 repeat：先执行后判断，无条件至少执行一次 "},{"title":"Java反射机制","date":"2021-01-22T16:00:00.000Z","url":"/2021/01/23/Java%E5%8F%8D%E5%B0%84/","categories":[["Java","/categories/Java/"]],"content":"反射的概述反射的理解Reflection（反射）是被视作动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个 类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可 以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看 到类的结构，所以，我们形象的称之为：反射。 正常方式：引入需要的“包类”名称——&gt;通过new实例化——&gt;取得实例化对象 反射方式：实例化对象——&gt;getClass()方法——&gt;得到完整的包类名称 框架=反射+注解+设计模式。 动态语言&amp;静态语言动态语言：是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以 被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运 行时代码可以根据某些条件改变自身结构。 主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。 静态语言：与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、 C++。 Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动 态性，可以利用反射机制、字节码操作获得类似动态语言的特性。 反射机制能提供的功能 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解 生成动态代理 相关APIjava.lang.Class:反射的源头java.lang.reflect.Methodjava.lang.reflect.Fieldjava.lang.reflect.Constructor … Class类的理解&amp;获取Class类的实例Class类在Object类中定义了以下的方法，此方法 将被所有子类继承：public final Class getClass() 。 以上的方法返回值的类型是一个Class类， 此类是Java反射的源头，实际上所谓反射 从程序的运行结果来看也很好理解，即： 可以通过对象反射求出类的名称。 Class本身也是一个类 Class 对象只能由系统建立对象 一个加载的类在 JVM 中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个 Class 实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 Class对象 Class类的理解1.类的加载过程：程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例。2.换句话说，Class的实例就对应着一个运行时类。3.加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。 Class的常用方法 方法名 功能说明 static Class forName(String name) 返回指定类名name的Class对象 Object newInstance() 调用缺省构造函数，返回该Class对象的一个实例 getName() 返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class [] getInterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 Class getSuperclass() 返回表示此Class所表示的实体的超类的Class Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组 Field[] getDeclaredFields() 返回Field对象的一个数组 Method getMethod(String name,Class … paramTypes) 返回一个Method对象，此对象的形参类型为paramType 获取Class实例的几种方式 PS：前三种方法需要熟记！ 创建类的对象的方式 new+构造器 要创建XXX类的对象，可以考虑：XXX、XXXS、XXXFactory、XXXBuilder类中查看是否有静态方法的存在。可以调用其静态方法，创建XXX对象。 通过反射创建 Class实例可以是哪些结构的说明 Class：外部类、成员（成员内部类、静态内部类），局部内部类，匿名内部类 interface：接口 []：数组 enum：枚举 annotation：注解@interface primitive type：基本数据类型 void 了解ClassLoader类的加载过程 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时 数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问 入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的 过程需要类加载器参与。 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题 准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存 都将在方法区中进行分配。 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 初始化： 执行类构造器&lt; clinit &gt;()方法的过程。类构造器&lt; clinit &gt;()方法是由编译期自动收集类中 所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信 息的，不是构造该类对象的构造器）。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类 的初始化。 虚拟机会保证一个类的&lt; clinit &gt;()方法在多线程环境中被正确加锁和同步。 什么时候会发生类的初始化类的主动引用（一定会发生类的初始化） 当虚拟机启动，先初始化main方法所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对类进行反射调用 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类 类的被动引用（不会发生类的初始化） 当访问一个静态域时，只有真正声明这个域的类才会被初始化，当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常 量池中了） 类的加载器的作用 类的加载器的分类 Java类编译、运行的执行的流程 使用Classloader加载src目录下的配置文件 反射应用一：创建运行时类的对象创建类的对象：调用Class对象的newInstance()方法要求： 类必须有一个无参数的构造器 类的构造器的访问权限需要足够 问题：没有无参构造器是否就不能创建对象 答：不是，只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。 步骤如下： 通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类 型的构造器 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。 通过Constructor实例化对象。 反射应用二：获取运行时类的完整结构我们可以通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等。。。。 使用反射可以取得： 反射应用三：调用运行时类的指定结构示例代码 关于setAccessible方法的使用1.Method和Field、Constructor对象都有setAccessible()方法。 2.setAccessible启动和禁用访问安全检查的开关。 3.参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 ​ 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被 调用，那么请设置为true。 ​ 使得原本无法访问的私有成员也可以访问 4.参数值为false则指示反射的对象应该实施Java语言访问检查。 反射应用四：动态代理代理模式原理使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 静态代理实现Runnable接口的方法创建多线程。 缺点： 代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。 每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。 动态代理特点动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。 动态代理的实现需要解决的两个主要问题： 如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。 （通过Proxy.newProxyInstance()实现） 当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。(通过InvocationHandler接口的实现类及其方法invoke()) Java动态代理相关APIProxy ：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一 个或多个接口动态地生成实现类。 提供用于创建动态代理类和动态代理对象的静态方法 static Class getProxyClass(ClassLoader loader, Class… interfaces) 创建 一个动态代理类所对应的Class对象 static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 直接创建一个动态代理对象 动态代理步骤1.创建一个实现接口InvocationHandler的类，它必须实现invoke方 法，以完成代理的具体操作。 2.创建被代理的类以及接口 3.通过Proxy的静态方法 4.通过 Subject代理调用RealSubject实现类的方法 代码实现 To be continue…"},{"title":"网络编程","date":"2021-01-19T16:00:00.000Z","url":"/2021/01/20/2021120-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","tags":[["TCP","/tags/TCP/"],["UDP","/tags/UDP/"],["Socket","/tags/Socket/"]],"categories":[["undefined",""]],"content":"网络相关概念网络通信 两台设备之间通过网络进行数据传输 java.net包下提供了一系列的类或接口完成网络通信 网络两台或多台设备通过一定物理设备连接起来构成了网络 局域网：覆盖范围最小，仅仅覆盖一个教室或机房 城域网：覆盖范围较大，可以覆盖一个城市 广域网：覆盖范围最大，可以覆盖全球，万维网是广域网的代表 IP地址用于唯一标识网络中的每台计算机/主机 cmd查看IP地址：ipconfig IP地址表示形式：点分十进制 xx.xx.xx.xx（每一个十进制数的范围：0~255） IP地址的组成=网络地址+主机地址 IPV6是互联网工程任务组设计的用于替代IPV4的下一代IP协议 IPV4存在的最大问题在于网络地址资源有限，严重制约了互联网应用和发展。IPV6的使用，不仅解决了网络地址资源数量问题，而且也解决了多种接入设备连入互联网的障碍 IPV4地址分类 类型 范围 A 0.0.0.0到127.255.255.255 B 128.0.0.0到191.255.255.255 C 192.0.0.0到223.255.255.255 D 224.0.0.0到239.255.255.255 E 240.0.0.0到247.255.255.255 127.0.0.1表示本机地址 域名为了方便记忆，解决记IP的困难 通过HTTP协议，将IP地址映射成域名 端口号用于表示计算机上某个特定的网络程序 表示形式：以整数形式，端口范围065535[2个字节表示端口02^16-1] 0~1024已经被占用，比如：ssh-22,ftp-21,smtp-25,http-80 常见的网络程序端口号： tomcat:8080 mysql:3306 oracle:1521 sqlserver:1433 网络通信协议 OSI模型： 对于客户端/服务器（C/S）结构。 即通信双方一方作为服务器等待客户提出请求并予以响应。客户则在需要服务时向服务器提出申请。服务器一般作为守护进程始终运行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服务端口，使后来的客户也能及时得到服务。 对于浏览器/服务器（B/S）结构。 客户则在需要服务时向服务器进行请求。服务器响应后及时返回，不需要实时监听端口 TCP/UDPTCP协议TCP是 Tranfer Control Protocol 的简称，是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。 使用TCP协议前必须先建立TCP连接，形成传输数据通道 传输前，采用“三次握手”方式，是可靠的 TCP协议进行通信的两个应用进程：客户端、服务器 在连接中可进行大数据量的传输 传输完毕，需释放已建立的连接，效率低 三次握手建立起一个TCP连接需要经过“三次握手”： 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求 UDP协议UDP是 User Datagram Protocol 的简称，是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址 将数据、源、目的封装成数据包，不需要建立连接 每个数据报的大小限制在64K内，不适合传输大量数据 因无需连接，故是不可靠的 发送数据结束时无需释放资源(因为不是面向连接的)，速度快 应用TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此TCP传输的效率不如UDP高 UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些 InetAddress类getLocalHost()：获取本机InetAddress对象 getByName()：根据指定主机名/域名获取IP地址对象 getHostName()：获取InetAddress对象的主机名getHostName getHostAddress()：获取InetAddress对象的地址 Socket套接字(Socket)开发网络应用程序被广泛采用。在网络编程中，网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket Socket套接字是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口 通信的两端都要有Socket，是两台机器通信的端点。网络通信其实就是Socket之间的通信 Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输 步骤套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认 服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态 客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求 连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求 基于TCP的Socket实现 基于客户端-服务端的网络通信 底层使用的是TCP/IP协议 使用字符流 使用字节流 上传文件 当客户端连接到服务端后，实际上客户端也是通过一个端口和服务器进行通讯的，这个端口是TCP/IP来分配的，是不确定的，是随机的 基于UDP的Socket实现 类DatagramSocket和DatagramPacket[数据包/数据报]实现了基于UDP协议网络程序 UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送达，也不能确定什么时候抵达 DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号 UDP协议中每个数据报都给出了完整的地址信息，因此无需建立发送方和接收方的连接 netast指令netast -an：可以查看当前主机网络情况，包括端口监听情况和网络连接情况 netast an|more：可以分页显示 说明： Listening表示某个端口在监听 如果有一个外部程序(客户端)连接到该端口，就会显示一条连接信息 ctrl+c退出指令 "},{"title":"JavaIO流","date":"2021-01-19T16:00:00.000Z","url":"/2021/01/20/JavaIO/","categories":[["Java","/categories/Java/"]],"content":"File类的使用理解 File类的一个对象，代表一个文件或一个文件目录（文件夹） File类声明在java.io包下 File中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。 后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点” File的实例化常用构造器 路径的分类相对路径：相较于某个路径下，指明的路径。绝对路径：包含盘符在内的文件或文件目录的路径 说明：IDEA中：如果开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下。如果使用main()测试，相对路径即为当前的Project下。Eclipse中：不管使用单元测试方法还是使用main()测试，相对路径都是当前的Project下。 路径分隔符windows和DOS系统默认使用“\\”来表示UNIX和URL使用“/”来表示 File类的常用方法 IO流概述流的分类 操作数据单位：字节流、字符流 数据的流向：输入流、输出流 流的角色：节点流、处理流 图示： 流的体系结构 说明：红框对应的是IO流中的4个抽象基类。蓝框的流需要重点关注。 重点说明的几个流结构 输入、输出的标准化过程输入过程 创建File类的对象，指明读取的数据的来源。（要求此文件一定要存在） 创建相应的输入流，将File类的对象作为参数，传入流的构造器中 具体的读入过程：创建相应的byte[]或char[] 关闭资源流 说明:程序中出现的异常需要用try-catch-finally处理。 输出过程 创建File类的对象，指明写出的数据的位置。(不要求此文件一定存在) 创建相应的输出流，将File类的对象作为参数，传入流的构造器中 具体的写出过程：write(char[]/byte[] buffer,0,len) 关闭资源流 说明：程序中出现的异常需要使用try-catch-finally处理。 节点流（或文件流）FileReader/FileWriter的使用FileReader的使用 FileWriter的使用 文本文件的复制 FileInputStream / FileOutputStream的使用 注意： 相对路径在IDEA和Eclipse中使用的区别？IDEA:如果使用单元测试方法，相对路径基于当前的Module的。如果使用main()测试，相对路径基于当前Project的。 Eclipse:单元测试方法还是main(),相对路径都是基于当前Project的。 缓冲流的使用缓冲流涉及到的类BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 作用作用：提供流的读取、写入的速度提高读写速度的原因：内部提供了一个缓冲区。默认情况下是8kb 典型代码使用BufferedInputStream和BufferedOutputStream:处理非文本文件 使用BufferedReader和BufferedWriter：处理文本文件 转换流的使用转换流涉及到的类属于字符流 InputStreamReader：将一个字节的输入流转换为字符的输入流解码：字节、字节数组 —&gt;字符数组、字符串 OutputStreamWriter：将一个字符的输出流转换为字节的输出流编码：字符数组、字符串 —&gt; 字节、字节数组 说明：编码决定了解码的方式 作用提供字节流与字符流之间的转换 图示 典型实现 编码集常见的编码表ASCII：美国标准信息交换码。用一个字节的7位可以表示。ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。GB2312：中国的中文编码表。最多两个字节编码所有字符GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码Unicode：国际标准码，融合了目前人类使用的所字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。 其他的流的使用标准的输入输出流System.in:标准的输入流，默认从键盘输入System.out:标准的输出流，默认从控制台输出 修改默认的输入和输出行为System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入和输出的流。 打印流PrintStream 和PrintWriter 说明： 提供了一系列重载的print()和println()方法，用于多种数据类型的的输出 System.out返回的是PrintStream的实例 数据流DataInputStream 和 DataOutputStream作用：用于读取或写出基本数据类型的变量或字符串 示例： 对象流的使用对象流ObjectInputStream 和 ObjectOutputStream 作用ObjectOutputStream:内存中的对象—&gt;存储中的文件、通过网络传输出去：序列化过程ObjectInputStream:存储中的文件、通过网络接收过来 —&gt;内存中的对象：反序列化过程 对象的序列化机制对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象 序列化代码实现 反序列化代码实现 实现序列化的对象所属的类需要满足 需要实现接口：Serializable 当前类提供一个全局常量：serialVersionUID 除了当前Person类需要实现Serializable接口之外，还必须保证其内部所属性也必须是可序列化的。（默认情况下，基本数据类型可序列化） 补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量 RandomAccessFile类的使用随机存取文件流RandomAccessFile（） 说明 RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口 RandomAccessFile既可以作为一个输入流，又可以作为一个输出流 如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。如果写出到的文件存在，则会对原文件内容进行覆盖。（默认情况下，从头覆盖） 可以通过相关的操作，实现RandomAccessFile“插入”数据的效果。seek(int pos) 代码示例 Path\\Paths\\Files的使用NIO的使用说明 Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的JavaIO API。 NIO与原来的IO同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。 NIO将以更加高效的方式进行文件的读写操作。 随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。 Path的使用Path的说明Path替换原有的File类。 如何实例化 常用方法 Files工具类作用操作文件或文件目录的工具类 常用方法 The End!"},{"title":"Java泛型","date":"2021-01-03T16:00:00.000Z","url":"/2021/01/04/%E6%B3%9B%E5%9E%8B/","categories":[["Java","/categories/Java/"]],"content":"泛型的概念所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时确定（即传入实际的类型参数，也称为类型实参）。 背景 集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection&lt; E &gt;，List&lt; E &gt;，ArrayList&lt; E &gt; 这个&lt; E &gt;就是类型参数，即泛型。 集合中不使用泛型 集合中使用泛型 在集合中使用泛型的情况：以HashMap为例： 总结 集合接口或集合类在jdk5.0时都修改为带泛型的结构 在实例化集合类时，可以指明具体的泛型类型 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。比如：add(E e)—&gt;实例化以后:add(Integer e) 注意：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换。 如果实例化时，没指明泛型的类型。默认泛型为java.long.Object类型。 在给泛型指定具体类型后，可以传入该类型或者其子类类型 自定义泛型泛型的声明inteface List&lt; T &gt;和class GenTest&lt; K,V &gt; 其中的T、K、V不代表值，而是类型。使用任意字母都可。常用T表示，是Type缩写。 泛型的实例化一定要在类型后面指定类型参数的值（类型）。例如： List strList=new ArrayList(); Iterator iterator=customers.iterator(); T只能是类，不能用基本数据类型填充。但可以使用包装类填充。 核心思想：把一个集合中的内容限制为一个特定的 数据类型。 体会：使用泛型的主要优点是能够在编译时而不是运行时找到错误。 自定义泛型类、泛型接口 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt; E1,E2,E3 &gt; 泛型类的构造器如下： public GenericClass(){}。 而下面是错误的： public GenericClass&lt; E &gt;(){} 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。 泛型不同的引用不能相互赋值. PS:尽管在编译时ArrayList和ArrayList是两种类型，但是，在运行时只有 一个ArrayList被加载到JVM中。 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价 于Object。经验：泛型要使用一路都用。要不用，一路都不要用。 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。 jdk1.7，泛型的简化操作：ArrayList flist = new ArrayList&lt;&gt;(); 泛型的指定中不能使用基本数据类型，可以使用包装类替换。 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态 属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法 中不能使用类的泛型。 异常类不能是泛型的 不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity]; 参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型： 子类不保留父类的泛型：按需实现 ​ 没有类型 擦除 ​ 具体类型 子类保留父类的泛型：泛型子类 ​ 全部保留 ​ 部分保留 结论：子类除了指定或保留父类的泛型，还可以增加自己的泛型 自定义泛型方法方法也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。 泛型方法的格式： [访问权限]&lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常 泛型方法声明泛型时也可以指定上限 应用场景举例： 举例： 父类：JavaGeneric 子类：subJavaGeneric、subJavaGeneric 测试类：GenericTest 泛型在继承上的体现类A是类B的父类，但是G&lt; A &gt;和G&lt; B &gt;二者不具备子父类的关系，二者为并列关系。 补充：类A是类B的父类，A&lt; G &gt;是B&lt; G &gt;的父类 通配符通配符的使用通配符：? 类A是类B的父类，G&lt; A &gt;和G&lt; B &gt;是没关系的，二者共同的父类是：G&lt;?&gt; 通配符的集合的数据的写入和读取 有限制条件的通配符的使用 通配符指定上限 上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;=。 通配符指定下限 下限super：使用时指定的类型不能小于操作的类，即&gt;= 举例： 只允许泛型为A及A子类的引用调用 只允许泛型为A及A父类的引用调用 只允许泛型为实现Comparable接口的实现类的引用调用 读取与写入：读取没问题，因为&lt; ?&gt;也可以进行读取 参考链接："},{"title":"记录一次new String()报错","date":"2020-11-29T16:00:00.000Z","url":"/2020/11/30/error01/","categories":[["Error","/categories/Error/"]],"content":" 解决方法： 删除导入的import com.sun.org.apache.xpath.internal.operations.String;即可。"},{"title":"即使是期末，学习也不要停下来啊！","date":"2020-11-29T16:00:00.000Z","url":"/2020/11/30/%E5%B0%91%E5%B9%B4%E3%81%AE%E6%97%A5%E5%B8%B801/","categories":[["少年の日常","/categories/%E5%B0%91%E5%B9%B4%E3%81%AE%E6%97%A5%E5%B8%B8/"]],"content":"临近期末，开始准备考试！可能会拖慢学习进度，但还是保证尽量一周至少更新一次学习类博客。 PS：心中有党，成绩理想！"},{"title":"Java集合","date":"2020-11-29T16:00:00.000Z","url":"/2020/11/30/20201130-%E9%9B%86%E5%90%88/","tags":[["集合","/tags/%E9%9B%86%E5%90%88/"],["Map","/tags/Map/"],["Set","/tags/Set/"]],"categories":[["Java","/categories/Java/"]],"content":"概述数组 长度开始时必须指定，而且一旦指定，不能更改 保存的必须为同一类型元素 使用数组进行增加/删除元素比较麻烦 集合 可以动态保存任意多个对象，使用比较方便 提供了一系列方便的操作对象的方法 使用集合添加、删除新元素更加简洁 Collection接口单列集合框架结构Collection接口：单列集合，用来存储一个一个的对象 List接口：存储有序的、可重复的数据。–&gt;“动态”数组 Set接口：存储无序的、不可重复的数据 图示： Collection接口常用方法 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals(). Iterator说明 Iterator对象称为迭代器（设计模式的一种），重要用于遍历Colletion集合中的元素。 GOF（Gang of Four）给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。 所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器 Iterator仅用于遍历集合,Iterator本身并不存放对象 如何获取实例 遍历的代码实现 注意：在调用iterator.next()方法之前必须要调用iterator。hasNext()进行检测。若不调用，且下一条记录无效，直接调用.next()会抛出NoSuchElementException异常 IDEA快速生成代码：itit 图示说明 remove（）的使用 增强for循环增强for循环可以代替iterator迭代器，特点：增强for解释简化版的iterator，本质一样。只能用于遍历集合或数组.内部仍然调用了迭代器 格式：for(元素类型 元素名:集合名或数组名){访问元素} 遍历集合举例 遍历数组举例 List接口List接口是Collection接口的子接口 List集合类中元素有序(即添加顺序和取出顺序一致)，且可重复 List集合中的每一个元素都有其对应的顺序索引，即支持索引 List容器中的元素都对应一个整数型的序号记载其在容器中位置，可以根据序号存取容器中的元素 JDK API中List接口的实现类： AbstractList AbstractSequentialList ArrayList(常用) AttributeList CopyOrWriteArrayList LinkedList(常用) RoleList RoleUnresolvedList Stack Vector(常用) List接口常用方法 遍历 ArrayList ArrayList可以加入null，并且多个 ArrayList是由数组来实现数据存储的 ArrayList基本等同于Vector，除了ArrayList是线程不安全的(执行效率高)。在多线程情况下，不建议使用ArrayList 底层操作机制源码分析 ArrayList中维护了一个Object类型的数组elementData 当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩容elementData为10，如需再次扩容,则扩容elementData为1.5倍 如果使用的是指定大小的构造器，则初始elementData容量为指定的大小,如果需要扩容，则直接扩容elementData为1.5倍v 使用无参构造器创建ArrayList1.创建了一个空的elementData数组 2.执行list.add。先确定是否需要扩容，然后再执行赋值 3.调用calculateCapacity() 4.该方法确认minCapacity第一次扩容为10 5.modCount++记录集合被修改的次数。如果elementData的大小不够，就调用grow()去扩容 6.使用扩容机制来确定要扩容到多大。第一次newCapacity=10,第二次及以后，按照1.5倍扩容。扩容使用的是Arrays.CopyOf() Vector Vector底层也是一个对象数组elementData Vector是线程同步的，即线程安全，Vector类的操作方法带有Synchronized 在开发中，需要考虑线程同步安全时，考虑使用Vector 如果使用的是无参构造器，则初始elementData容量为10，如需再次扩容,则扩容elementData为2倍 如果使用的是指定大小构造器，则每次直接按2倍扩容 LinkedList LinkedList底层实现了双向链表和双端队列特点 可以添加任意元素(元素可以重复)，包括null 线程不安全，没有实现同步 底层操作机制 LinkedList底层维护了一个双向链表 LinkedList中维护了两个属性first和last分别指向首节点和尾节点 每个节点(Node对象)，里面又维护了prev、next、item三个属性，其中通过prev指向前一个，通过next指向后一个。最终实现双向链表 linkedList元素的添加和删除，不是通过数组完成的，相对来说效率较高 ArrayList和LinkedList比较 底层结构 增删的效率 改查的效率 ArrayList 可变数组 较低，数组扩容 较高 LinkedList 双向链表 较高，通过链表追加 较低 如果改查操作多，选择ArrayList 如果增删操作多，选择LinkedList Set接口 无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值来决定的 不可重复性：保证添加的元素照equals()判断时，不能返回true。即：相同的元素只能添加一个 Set接口中没有额外定义新方法，使用的都是Collection中声明过的方法 HashSet HashSet实现了Set接口 HashSet实际上是HashMap 不能有重复元素/对象 HashSet不保证元素是有序的，取决于Hash后，再确定索引的结果（即，不能保证存放元素的顺序和取出顺序一致） HashSet底层机制HashSet底层是HashMap，HashMap底层是(数组+链表+红黑树) HashSet添加元素底层实现过程： 先获取元素的哈希值(hashCode方法) 对hash值进行运算，得出一个索引值。即要存放在hash表中的位置号 如果该位置上没有其他元素，则直接存放。 如果该位置上有其他元素，则需要进行equals判断：如果相等，则不再添加。如果不相等，则以链表的方式添加 在Java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD(默认是8)，斌且table的大小&gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树) 源码分析： 因此使用HashSet时需要重写equals()和hashCode()方法 HashSet的扩容和转成红黑树机制 第一次添加时，table数组扩充为16，临界值(threshold)是16*加载因子(loadFactor)是0.75=12 如果table数组使用到了临界值12，就会扩容到16 * 2=32，新的临界值就是32 * 0.75=24，以此类推 在Java8中，如果一条链表的元素个数到达TREEIFY_THRESHOLD(默认是8)，并且table大小&gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树)，否则仍然采用数组扩容机制 LinkedHashSet LinkedHashSet是HashSet的子类 LinkedHashSet底层是LinkedHashMap，底层维护了一个 数组+双向链表 LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的 LinkedHashSet不允许添加重复元素 注意：同样需要重写equals()和hashCode()方法 TreeSet使用说明： 1.向TreeSet中添加的数据，要求是相同类的对象。2.两种排序方式：自然排序（实现Comparable接口 和 定制排序（Comparator） 常用的排序方式 Map接口 Map与conllection并列存在.用于保存具有映射关系的数据：Key-value Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中 Map中的key不允许重复，原因和HashSet一样 Map中的value可以重复 Map的key可以为null，value也可以为null，注意key为null，只能有一个，value为null，可以多个 常用String类作为Map的key key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value 一对k-v是放在一个HashMap$Node中的，又因为Node实现了Entry接口，也可以说一对k-v就是一个Entry 常用方法 遍历 常用实现类结构 HashMap HashMap是Map接口使用频率最高的实现类 HashMap是以key-value对的方式来存储数据(HashMap$Node类型) key不能重复，但是值可以重复，允许使用null键和null值 如果添加相同的key，则会覆盖原来的key-val，等同于修改（key不会替换，val会替换） 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的 HashMap没有实现同步，因此线程是不安全的，方法没有做同步互斥的操作，没有synchronized 底层机制扩容机制（和HashSet相同） HashMap底层维护了Node类型的数组table,默认为null 当创建对象时，将加载因子(loadfactor)初始化为0.75 当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key是否相等，如果相等，则直接替换val；如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容 第一次添加，则需要扩容table容量为16，临界值(threshold)为12 以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍，以此类推 在Java8中，如果一条链表的元素个数超过TREEIFY—THRESHOLD(默认是8)，并且table的大小&gt;=MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树) 源码 LinkedHashMap的底层实现原理LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap.区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node. HashTable 存放的元素时键值对：即，k-v hashTable的键和值都不能为null，否则会抛出NullPointerException hashTable使用方法基本上和HashMap相同 hashTable是线程安全的，hashMap是线程不安全的 Hashtable 和 HashMap 对比 版本 线程安全(同步) 效率 允许null键null值 HashMap 1.2 不安全 高 可以 HashTable 1.0 安全 较低 不可以 properties Properties类继承自HashTable类并且实现了Map接口，也是一种键值对形式来保存数据 它的使用特点和HashTable类似 Properties还可以用于从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改 xxx.properties文件通常作为配置文件 如何选择集合实现类主要取决于业务操作特点，然后根据集合实现类特性进行选择 先判断存储的类型(一组对象[单列]或一组键值对[双列]) 一组对象[单列]：Collection接口 允许重复：List 增删多：LinkedList[底层维护了一个双向链表] 改查多：ArrayList[底层维护Object类型的可变数组] 不允许重复：Set 无序：HashSet[底层是HashMap，维护了一个哈希表，即[数组+链表+红黑树]] 排序：TreeSet 插入和取出顺序一致：LinkedHashSet，维护数组+双向链表 一组键值对[双列]：Map 键无序：HashMap[底层是：哈希表] 键排序：TreeMap 键插入和取出顺序一致：LinkedHashMap 读取文件：Properties TreeMap的使用向TreeMap中添加key-value，要求key必须是由同一个类创建的对象，因为要按照key进行排序：自然排序、定制排序 Collections工具类Collections工具类作用操作Collection和map的工具类 常用的方法reverse(List)：反转 List 中元素的顺序shuffle(List)：对 List 集合元素进行随机排序sort(List)：根据元素的自然顺序对指定 List 集合元素升序排序sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素Object min(Collection)Object min(Collection，Comparator)int frequency(Collection，Object)：返回指定集合中指定元素的出现次数void copy(List dest,List src)：将src中的内容复制到dest中boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所旧值 说明：ArrayList和HashMap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程的。使用synchronizedList(List list） 和 synchronizedMap(Map map）"},{"title":"枚举类和注解","date":"2020-11-20T16:00:00.000Z","url":"/2020/11/21/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3/","categories":[["Java","/categories/Java/"]],"content":"枚举类和注解枚举类的说明 枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类 当需要定义一组常量时，强烈建议使用枚举类 如果枚举类中只有一个对象，则可以作为单例模式的实现方式。 自定义枚举类步骤: jdk 5.0 新增使用enum定义枚举类步骤： 使用enum定义枚举类之后，枚举类常用方法：（继承于java.lang.Enum类） 使用enum定义枚举类之后，如何让枚举类对象分别实现接口 注解（Annotation）注解的理解jdk5.0新增功能 Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 框架 = 注解 + 反射机制 + 设计模式 注解的使用示例示例一：生成文档相关的注解 示例二：在编译时进行格式检查(JDK内置的个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的择 @SuppressWarnings: 抑制编译器警告 示例：跟踪代码依赖性，实现替代配置文件功能 如何自定义注解：参照@SuppressWarnings定义 注解声明为：@interface 内部定义成员，通常使用value表示 可以指定成员的默认值，使用default定义 如果自定义注解没成员，表明是一个标识作用 说明：如果注解有成员，在使用注解时，需要指明成员的值。自定义注解必须配上注解的信息处理流程(使用反射)才意义。自定义注解通过都会指明两个元注解：Retention、Target 代码举例： 元注解 ：对现有的注解进行解释说明的注解jdk 提供的4种元注解：Retention：指定所修饰的 Annotation 的生命周期：SOURCE\\CLASS（默认行为\\RUNTIME 只声明为RUNTIME生命周期的注解，才能通过反射获取。Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素——出现的频率较低——Documented:表示所修饰的注解在被javadoc解析时，保留下来。Inherited:被它修饰的 Annotation 将具继承性。 —&gt;类比：元数据的概念：String name = “Tom”; 如何获取注解信息:通过反射来进行获取、调用前提：要求此注解的元注解Retention中声明的生命周期状态为：RUNTIME. JDK8中注解的新特性：可重复注解、类型注解可重复注解： 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 类型注解： ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明） ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。 "},{"title":"Java常用类2","date":"2020-11-17T16:00:00.000Z","url":"/2020/11/18/Class2/","categories":[["Java","/categories/Java/"]],"content":"JDK8之前日期时间API获取系统当前时间：System类中的currentTimeMillis() java.util.Date类与java.sql.Date类java.util.Date 是 java.sql.Date 的父类java.util.Date是常用的表示时间的类，我们通常格式化或者得到当前时间都是用他 java.sql.Date在读写数据库的时候用他，因为PreparedStament的setDate()的第2参数和ResultSet的getDate()方法的第2个参数都是java.sql.Date 继承关系：java.lang.Object –》 java.util.Date –》 java.sql.Date 1.两个构造器的使用 构造器一：Date()：创建一个对应当前时间的Date对象 构造器二：创建指定毫秒数的Date对象 2.两个方法的使用 toString():显示当前的年、月、日、时、分、秒 getTime():获取当前Date对象对应的毫秒数。（时间戳） 3. java.sql.Date对应着数据库中的日期类型的变量 如何实例化 如何将java.util.Date对象转换为java.sql.Date对象 java.text.SimpleDataFormat类Java中怎么才能把日期转换成想要的格式呢，或把字符串转换成一定格式的日期，如把数据库中的日期或时间转换成自己想要的格式，JAVA中提供了SimpleDateFormat类可以实现。 SimpleDateFormat的实例化: new + 构造器 SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。 SimpleDateFormat 使得可以选择任何用户定义的日期-时间格式的模式。但是，仍然建议通过 DateFormat 中的 getTimeInstance、getDateInstance 或 getDateTimeInstance 来创建日期-时间格式器。每一个这样的类方法都能够返回一个以默认格式模式初始化的日期/时间格式器。 结果为： 公元2010年07月27日 09时19分29秒2010/07/27 09:192010-07-27 09:19:292010年07月27日 09时19分29秒 星期二2010/07/27 星期二一年中的第 208 天 ，第31个星期 ，一个月中第5个星期 ，9时 CST时区 SimpleDateFormat日期-时间格式模式参数字母 日期或时间元素 表示 示例G Era 标志符 Text ADy 年 Year 1996; 96M 年中的月份 Month July; Jul; 07w 年中的周数 Number 27W 月份中的周数 Number 2D 年中的天数 Number 189d 月份中的天数 Number 10F 月份中的星期 Number 2E 星期中的天数 Text Tuesday; Tue （我在部署的时候在本机oracle是返回星期是星期二，而在Oracle的服务器上是返回Tue.)a Am/pm 标记 Text PMH 一天中的小时数（0-23） Number 0k 一天中的小时数（1-24） Number 24K am/pm 中的小时数（0-11） Number 0h am/pm 中的小时数（1-12） Number 12m 小时中的分钟数 Number 30s 分钟中的秒数 Number 55S 毫秒数 Number 978z 时区 General time zone Pacific Standard Time; PST; GMT-08:00Z 时区 RFC 822 time zone -0800 Calendar类：日历类、抽象类实例化方式一：创建其子类GregorianCalendar的对象方式二：调用其静态方法getInstance() //Calendar calendar = Calendar.getInstance(); 常用方法： JDK8中新日期时间API日期时间API迭代第一代：jdk 1.0 Date类第二代：jdk 1.1 Calendar类，一定程度上替换Date类第三代：jdk 1.8 提出了新的一套API 前两代存在的问题举例可变性：像日期和时间这样的类应该是不可变的。偏移性：Date中的年份是从1900开始的，而月份都从0开始。格式化：格式化只对Date用，Calendar则不行。此外，它们也不是线程安全的；不能处理闰秒等。 java 8 中新的日期时间API涉及到的包 本地日期、本地时间、本地日期时间的使用：LocalDate / LocalTime / LocalDateTime说明： 分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。 LocalDateTime相较于LocalDate、LocalTime，使用频率要高 类似于Calendar 常用方法： 时间点：Instant说明： 时间线上的一个瞬时点。 概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC开始的秒数。） 类似于 java.util.Date类 常用方法： 日期时间格式化类：DateTimeFormatter说明： 格式化或解析日期、时间 类似于SimpleDateFormat 常用方法： 实例化方式： 预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) 特别的：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)重点：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”) 格式化 格式化String str4 = formatter3.format(LocalDateTime.now());System.out.println(str4);//2019-02-18 03:52:09 解析 带时区的日期时间：ZonedDateTime / ZoneId举例： 时间间隔：Duration–用于计算两个“时间”间隔，以秒和纳秒为基准举例： 日期间隔：Period –用于计算两个“日期”间隔，以年、月、日衡量 举例： 日期时间校正器：TemporalAdjuster举例： Java比较器Java比较器的使用背景Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。如何实现？使用两个接口中的任何一个：Comparable 或 Comparator 自然排序：使用Comparable接口说明： 像String、包装类等实现了comparable接口，重写了compareTo(obj)方法，给出了两个比较对象大小的方式。 像String、包装类重写compareTo()方法以后，进行了从小到大的排列 重写compareTo(obj)的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。 对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。在compareTo(obj)方法中指明如何排序 自定义类代码举例： 定制排序：使用Comparator接口说明： 背景：当元素的类型没实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序 重写compare(Object o1,Object o2)方法，比较o1和o2的大小： 如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。 代码举例： 使用：Arrays.sort(goods,com);Collections.sort(coll,com);new TreeSet(com); 两种排序方式对比Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。Comparator接口属于临时性的比较。 其他类System类 System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。 方法：native long currentTimeMillis()void exit(int status)void gc()String getProperty(String key) Math类java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。 BigInteger、BigDecimal类说明： java.math包的BigInteger可以表示不可变的任意精度的整数。 要求数字精度比较高，用到java.math.BigDecimal类代码举例： "},{"title":"Java常用类1","date":"2020-11-15T16:00:00.000Z","url":"/2020/11/16/Class1/","categories":[["Java","/categories/Java/"]],"content":"String类java.lang.String类的使用概述String：字符串，使用一对“”引起来表示。 String声明为final，不可被继承 String实现了Serializable接口：表示字符串是支持序列化的 实现了Comparable接口：表示String可以比较大小 String内部定义了final char[] value用于储存字符串数据 通过字面量的方式（区别于new给一个字符串赋值，此时的字符串声明在字符串常量池中） 字符串常量池中不会储存相同内容（使用String类的equals()比较，返回true）的字符串。 String的不可变性说明 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 当对现有字符串进行连续操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 例如： 图示 String实例化的不同方式方式说明*方式一：通过字面量定义的方式 方式二：通过new+构造器的方式 例如： String s = new String(“abc”);方式创建对象，在内存中创建了几个对象？两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc” 图示： 字符串拼接方式赋值的对比对比说明 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。 只要其中一个是变量，结果就在堆中。 如果拼接的结果调用intern()方法，返回值就在常量池中 举例 常用方法int length()：返回字符串的长度：return value.length char charAt(int index)：返回某索引处的字符return value[index] boolean isEmpty()：判断是否是空的字符串：return value.length ==0 String tolowerCase()：使用默认语言环境，将String中的所有字符转换为小写 String toUpperCase()：使用默认语言环境·，将String中的所有字符转换为大写 String trim()：返回字符串的副本，忽略前导空白和尾部空白 boolean equals(Object obj)：比较字符串的内容是否相同 boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写 String concat(String str)：将指定字符串链接到此字符串的结尾，等价于用“+” int compareTo(String anotherString)：比较两个字符串的大小 String subString(int beginIndex)：返回一个新的字符串，它是此字符串从beginIndex开始截取到最后的·一个子字符串。 String subString(int beginIndex,int endIndex)：返回一个新字符串，它是此字符串beginIndex开始截取到endIndex(不包含)的一个子字符串 boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束 boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始 boolean startsWith(String prefix，int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始 boolean contains(CharSequence s)：当且仅当此字符串包含指定的char值返回序列时，返回true int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引 int indexOf(String str，int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始 int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引 int lastIndexOf(String str，int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索 注：indexOf和lastIndexOf如果未找到都是返回-1 替换： String replace(char oldChar，char newChar)：返回一个新的字符串，它是通过用newChar替换此字符串中出现的所有oldChar得到的。 String repalce(CharSequence target,CharSequence replacement)：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串 String replaceAll(String regex,String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的子字符串 String replaceFirst(String regex,String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串 匹配： boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式 切片： String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串 String[] split(String regex,int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后的元素中 String与其他结构的转换与基本数据类型、包装类之间的转换String——&gt;基本数据类型、包装类：调用包装类的静态方法：parseXxx(str) 基本数据类型、包装类——&gt;String：调用String重载的valueOf(xxx) 与字符数组之间的转换编码：Stirng——&gt;byte[]：调用String的getBytes() 解码：byte[]——&gt;String：diaoyongString的构造器 编码：字符串——&gt;字节（看得懂——&gt;看不懂的二进制数据） 解码：编码的逆过程，字节——&gt;字符串（看不懂的二进制数据——&gt;看得懂） 说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。 与StringBuffer、StringBuilder之间的转换String——&gt;StringBuffer、StringBuilder：调用StringBuffer、StringBuilder构造器 StringBuffer、StringBuilder –&gt;String： 1.调用String构造器 2.StringBuffer、StringBuilder的toString() JVM中字符串常量池存放位置说明jdk1.6：字符串常量池储存在方法区(永久区) jdk1.7：字符串常量池储存在堆空间 jdk1.8：字符串常量池储存在方法区(元空间) 算法题目考查1.模拟一个trim方法，去除字符串两端的空格。 2.将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg” 3.获取一个字符串在另一个字符串中出现的次数。 比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数 4.获取两个字符串中最大相同子串。比如： str1 = “abcwerthelloyuiodef“;str2 = “cvhellobnm” 提示：将短的那个串进行长度依次递减的子串与较长的串比较。 5.对字符串中字符进行自然顺序排序。 提示： 1字符串变成字符数组。 2对数组排序，择，冒泡，Arrays.sort(); 3将排序后的数组变成字符串。 String、StringBuffer、StringBuilder三者对比 String:不可变的字符序列;底层使用char[]储存。 StringBuffer:可变的字符序列；线程安全，效率低；底层使用char[]存储。 StringBuilder:可变的字符序列；jdk5.0新增，线程不安全，效率高；底层使用char[]存储。 StringBuffer和StringBuilder的内存解析例如StringBuffer： 开发中建议使用：StringBuffer(int capacity) 或 StringBuilder(int capacity) 对比String、StringBuffer、StringBuilder三者的执行效率从高到低排列：StringBuilder &gt; StringBuffer &gt; String StringBuffer、StringBuilder中的常用方法增：append(xxx) 删：delete(int start,int end) 改：setCharAt(int n,char ch) /replace(int start,int end,String str) 查：charAt(int n) 插入：insert(int offset,xxx) 长度：length() 遍历：for()+charAt()/toString()"},{"title":"多线程","date":"2020-11-14T16:00:00.000Z","url":"/2020/11/15/Thread/","tags":[["synchronized","/tags/synchronized/"],["lock","/tags/lock/"],["Callable","/tags/Callable/"],["线程池","/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"]],"categories":[["Java","/categories/Java/"]],"content":"程序、进程、线程程序（program)：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。 进程（process)：程序的一次执行过程，或是正在运行的一个程序。 线程（thread)：进程可进一步细化为一个或多个线程，是一个程序内部的一条执行路径。 说明： 线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc），线程切换的开销小。 每个线程，拥有自己独立的：栈、程序计数器。 多个线程，共享同一个进程中的结构：方法区、堆。 一个Java应用程序Java.exe，其实至少三个线程:main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 并行和并发并行：同一时刻，多个任务同时执行。多核CPU可以实现 并发：同一个时刻，多个任务交替执行，造成一种“貌似同时”的错觉。单核CPU实现的多任务就是并发 创建线程方式方式一：继承Thread类的方式 创建一个继承于Thread类的子类 重写Thread类的run() ——&gt;将此线程执行的操作声明在run()中 创建Thread类的子类的对象 通过此对象调用的start():1.启动当前线程2.调用当前线程的run() 说明： 1：我们启动一个线程，必须调用start()，不能调用run()的方式启动线程。 2：如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start()。 方式二：实现Runnable接口的方式 创建一个实现Runnable接口的类 实现类去实现Runnable中的抽象方法：run() 创建实现类的对象 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 通过Thread类的对象调用start() 两种方式对比： 开发中：优先选择：实现Runnable接口的方式 原因：1.实现的方式没有类的单继承性的局限性。 2.实现的方式更适合来处理多个线程共享数据的情况。 相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中。 ​ 目前两种方式，想要启动线程，都是调用的Thread类中的start()。 Thread类中的常用方法 方法 说明 start() 启动当前线程：调用当前线程的run() run() 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 currentThread() 静态方法，返回执行当前代码的线程 getName() 获取当前线程的名字 setName() 设置当前线程的名字 yield() 释放当前CPU的执行权 join() 在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完后，线程a才结束阻塞状态 stop() （已过时）当执行此方法时，强行结束当前线程 sleep(long millitime) 让当前线程“睡眠”指定的毫秒（millitime）。在指定的millitime毫秒时间内，当前线程是阻塞状态 isAlive() 判断当前线程是否存活 线程的优先级 MAX_PRIORITY: 10 MIN_PRIORITY: 1 NORM_PRIORITY: 5——&gt;默认优先级 如何获取和设置当前线程的优先级： getPriority():获取线程的优先级 setPriority(int p):设置线程的优先级 说明：高优先级的线程要抢占低优先级的线程CPU的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。 线程通信：wait()/notify()/notifyAll()：此三个方法定义在Object()类中的。 补充：线程的分类 一种是守护线程，一种是用户线程。 线程的生命周期 JDK 中用 Thread.State 枚举表示了线程的几种状态 NEW：尚未启动的线程处于此状态 RUNNABLE：在Java虚拟机中的线程处于此状态 BLOCKED：被阻塞等待监视器锁定的线程处于此状态 WAITING：正在等待另一个线程执行特定动作的线程处于此状态 TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态 TERMINATED：已退出的线程处于此状态 线程的同步机制例：创建个窗口卖票，总票数为100张，使用实现Runnable接口的方式问题：卖票过程中，出现了重票、错票——&gt;出现了线程的安全问题问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。解决问题：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。 Java解决方案：同步机制同步代码块 说明： 操作共享数据的代码，即为需要被同步的代码。——&gt;不能包含代码多了，也不能包含代码少了。 共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。 要求：多个线程必须要共用同一把锁。 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 同步方法如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 总结： 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 非静态的同步方法，同步监视器是：this 静态的同步方法，同步监视器是：当前类本身 Lock锁 （JDK5.0新增)Lock类实际上是一个接口，我们在实例化的时候实际上是实例化实现了该接口的类Lock lock = new ReentrantLock();。用synchronized的时候，synchronized可以修饰方法，或者对一段代码块进行同步处理。 自定义线程类： 测试类： synchronized 与 Lock的异同？ 相同：二者都可以解决线程安全问题 不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器 Lock需要手动的启动同步（lock()。同时，结束同步也需要手动的实现（unlock()） 使用的优先顺序： Lock —&gt; 同步代码块（已经进入了方法体，分配了相应资源 ) —&gt;同步方法（在方法体之外) 利弊：同步的方式，解决了线程的安全问题。—好处操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 线程安全的单例模式使用同步机制将单例模式中的懒汉式改写为线程安全的。 死锁问题不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 说明： 死锁出现后，不会出现异常，不会出现提示，只是所有线程都处于阻塞状态，无法继续 使用同步时，要避免出现死锁 例如： 线程通信线程通信涉及到的三个方法：wait(): 一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。notify(): 一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。notifyAll(): 一旦执行此方法，就会唤醒所有被wait的线程。 说明：1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。面试题：sleep() 和 wait()的异同？相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。不同点： 两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait() 调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 释放锁的操作 不会释放锁的操作 JDK5.0新增线程创建的方式新增方式一：实现Callable接口。 （JDK 5.0新增） 说明：如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？ call()可以返回值的。 call()可以抛出异常，被外面的操作捕获，获取异常的信息 Callable是支持泛型的 新增方式二：使用线程池 说明：好处：1.提高响应速度（减少了创建新线程的时间）2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）3.便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没任务时最多保持多长时间后会终止"},{"title":"Java异常处理机制","date":"2020-11-11T16:00:00.000Z","url":"/2020/11/12/Exception/","categories":[["Java","/categories/Java/"]],"content":"Java异常处理机制Java异常机制用到的几个关键字try用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。 catch用来捕获异常，catch用来捕获try语句块中发生的异常。 throw用来抛出异常 throws用在方法签名中，用于声明该方法可能抛出的异常。主方法上也可能使用throws抛出。如果在主方法上使用了throws抛出，就表示在主方法里面可以不用强制性进行异常处理，如果出现了异常，就交给JVNM进行默认处理，则此时会导致程序中断运行。 finallyfinally语句块总是会被执行。像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等中止方法的语句，则就不会跳回执行，直接停止。 三种类型的异常 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。 异常方法： 方法 public String getMessage() 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 public Throwable getCause() 返回一个Throwable 对象代表异常原因。 public String toString() 使用getMessage()的结果返回类的串级名字。 public void printStack Trace() 打印toString()结果和栈层次到System.err，即错误输出流。 public Stack TraceElement [] getStack Trace() 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 public Throwable filllnStack Trace() 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 异常的使用及执行流程异常的处理方案1 try…catch try…catch…finally try…finally 说明： 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配。 一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没写finally的情况。继续执行其后的代码。 catch中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓。catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 在try结构中声明的变量，再出了try结构以后，就不能再被调用。 try-catch-finally结构可以嵌套。 异常的处理方案2 “throws + 异常类型“写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。 一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！ 对比两种处理方式： try-catch-finally:真正的将异常给处理掉了。 throws的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。 开发中应该如何选择两种处理方式？ 如果父类中被重写的方法没throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理。 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。 补充： 方法重写的规则之一： 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 手动抛出异常对象 说明：在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。 throw 和 throws区别： throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。 throws 属于异常处理的一种方式，声明在方法的声明处。 例如： 自定义异常类 如何自定义异常类？ 继承于现的异常结构：RuntimeException 、Exception 提供全局常量：serialVersionUID 提供重载的构造器 例如： "},{"title":"设计模式：单例模式","date":"2020-11-11T16:00:00.000Z","url":"/2020/11/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","categories":[["Java","/categories/Java/"]],"content":"设计模式：单例模式所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。 而如何保证类在内存中只有一个对象？平时在实例化类的对象时，基本都是通过new 的方式来实例化一个对象，其实说白了，就是调用了需要实例化类的默认的构造方法，所以为了保证类只有一个对象，我们需要将类的对象设置为private。 1）控制类的创建，不让其他类创建本类的对象，即需要设置private属性 2）在本类中定义一个本类的对象 测试结果为true，可见s1,s2用的是同一个地址值。 但是，在执行main方法的时候，若突然有个进程插了进来，将Singleton中的s变成了null（多线程中，很常见），这时就相当于引用了两个地址，即不符合了单例的定义 所以，除了使用private设置构造函数还不够，还需要提供公共的访问方式 先将Sinleton类中的实例化私有（private），使得外界不能调用，然后创建要给get方法，返回一个实例s，这样，就保证了在外类中不能更改s的值，即保证了单例的实现 其实上述的方式 就是单例模式中的饿汉式。 这是比较常见的写法，在类加载的时候就完成了实例化，避免了多线程的同步问题。当然缺点也是有的，因为类加载时就实例化了，没有达到Lazy Loading (懒加载) 的效果，如果该实例没被使用，内存就浪费了。 而对于懒汉式，就是在需要的时候再创建类的实例化 普通懒汉式（线程不安全，不可用） 这是懒汉式中最简单的一种写法，只有在方法第一次被访问时才会实例化，达到了懒加载的效果。但是这种写法有个致命的问题，就是多线程的安全问题。假设对象还没被实例化，然后有两个线程同时访问，那么就可能出现多次实例化的结果，所以这种写法不可采用。 同步方法的懒汉式 这种写法是对getInstance()加了锁的处理，保证了同一时刻只能有一个线程访问并获得实例，但是缺点也很明显，因为synchronized是修饰整个方法，每个线程访问都要进行同步，而其实这个方法只执行一次实例化代码就够了，每次都同步方法显然效率低下，为了改进这种写法，就有了下面的双重检查懒汉式。 双重检查懒汉式 (可用，推荐) 这种写法用了两个if判断，也就是Double-Check，并且同步的不是方法，而是代码块，效率较高，是对第三种写法的改进。为什么要做两次判断呢？这是为了线程安全考虑，还是那个场景，对象还没实例化，两个线程A和B同时访问静态方法并同时运行到第一个if判断语句，这时线程A先进入同步代码块中实例化对象，结束之后线程B也进入同步代码块，如果没有第二个if判断语句，那么线程B也同样会执行实例化对象的操作了。 静态内部类 (可用，推荐) 这种写法在《Effective JAVA》中大为推崇，它可以解决两个问题： 1）线程安全问题。因为Java虚拟机在加载枚举类的时候会使用ClassLoader的方法，这个方法使用了同步代码块来保证线程安全。 2）避免反序列化破坏对象，因为枚举的反序列化并不通过反射实现。 ### 单例模式的优缺点 #### 优点 单例类只有一个实例，节省了内存资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能； 单例模式可以在系统设置全局的访问点，优化和共享数据，例如前面说的Web应用的页面计数器就可以用单例模式实现计数值的保存。 #### 缺点 单例模式一般没有接口，扩展的话除了修改代码基本上没有其他途径。 "},{"title":"每一天都要充实的度过！","date":"2020-11-09T16:00:00.000Z","url":"/2020/11/10/First/","categories":[["Java","/categories/Java/"]],"content":"此博客建立于2020年11月10日，目的为记录日常生活和学习。 希望能不断丰富这个博客的同时，也不断积累经验。 PS:偶尔也会偷懒~(才不)"}]