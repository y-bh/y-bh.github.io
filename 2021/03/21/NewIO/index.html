<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="">
  <title>NewIO | 青い栞</title>
  <meta name="author" content="FunnyLs" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="NewIO简介 Java NIO(New IO)是从java1.4版本开始引入的一个新的IO API，可以代替标准的Java IO API NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。  Java NIO和IO的主要区别   IO NIO    面向流（Stream Oriented） 面向缓冲区（Buffer Oriented）   阻塞IO（Bloc">
<meta property="og:type" content="article">
<meta property="og:title" content="NewIO">
<meta property="og:url" content="http://example.com/2021/03/21/NewIO/index.html">
<meta property="og:site_name" content="青い栞">
<meta property="og:description" content="NewIO简介 Java NIO(New IO)是从java1.4版本开始引入的一个新的IO API，可以代替标准的Java IO API NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。  Java NIO和IO的主要区别   IO NIO    面向流（Stream Oriented） 面向缓冲区（Buffer Oriented）   阻塞IO（Bloc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/null">
<meta property="article:published_time" content="2021-03-20T16:00:00.000Z">
<meta property="article:modified_time" content="2021-08-11T12:35:36.415Z">
<meta property="article:author" content="FunnyLs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/null">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-blue.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/qrcode_js@1.0.0/qrcode.min.js"></script>
  
<meta name="generator" content="Hexo 5.4.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"></a></li>
                                    
                                
                                    
                                        <li>
                                            <a><i class="fa fa-link"></i>链接</a>
                                            <ul class="sub-menu">
                                                
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://candinya.com">作者博客</a></li>
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://github.com/Candinya/Kratos-Rebirth">项目链接</a></li>
                                                    
                                                
                                            </ul>
                                        </li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">青い栞</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>青い栞</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">NewIO</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2021-03-21</li>
                <li><i class="fa fa-user"></i> 作者 FunnyLs</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~10.56K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                本文最后编辑于 <time datetime="1628685336415"></time> 前，其中的内容可能需要更新。
            </div>
            
                <div class="kratos-post-inner-toc">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#NewIO%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">NewIO简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-NIO%E5%92%8CIO%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">Java NIO和IO的主要区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA-Buffer-amp-%E9%80%9A%E9%81%93-Channel"><span class="toc-number">2.</span> <span class="toc-text">缓冲区(Buffer)&amp;通道(Channel)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88Buffer%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">缓冲区（Buffer）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E5%B8%B8%E7%94%A8%E5%AD%90%E7%B1%BB"><span class="toc-number">2.2.2.</span> <span class="toc-text">Buffer常用子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.3.</span> <span class="toc-text">Buffer中的重要概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.4.</span> <span class="toc-text">Buffer常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.5.</span> <span class="toc-text">Buffer的数据操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.6.</span> <span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.2.7.</span> <span class="toc-text">直接与非直接缓冲区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93-Channel"><span class="toc-number">2.3.</span> <span class="toc-text">通道(Channel)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">2.3.2.</span> <span class="toc-text">Channel实现类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Channel"><span class="toc-number">2.3.3.</span> <span class="toc-text">获取Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">2.3.4.</span> <span class="toc-text">Channel的数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86-Buffer-%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5-Channel"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">将 Buffer 中数据写入 Channel</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E-Channel-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%88%B0-Buffer"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">从 Channel 读取数据到 Buffer</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%95%A3-Scatter-%E5%92%8C%E8%81%9A%E9%9B%86-Gather"><span class="toc-number">2.3.5.</span> <span class="toc-text">分散(Scatter)和聚集(Gather)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%95%A3%E8%AF%BB%E5%8F%96%EF%BC%88Scattering-Reads%EF%BC%89"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">分散读取（Scattering Reads）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E5%86%99%E5%85%A5%EF%BC%88Gathering-Writes%EF%BC%89"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">聚集写入（Gathering Writes）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">2.3.6.</span> <span class="toc-text">通道之间的数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#transferFrom"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">transferFrom()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#transferTo"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">transferTo()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.7.</span> <span class="toc-text">FileChannel常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">3.</span> <span class="toc-text">NIO的非阻塞式网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">3.0.1.</span> <span class="toc-text">阻塞与非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%88Selector%EF%BC%89"><span class="toc-number">3.0.2.</span> <span class="toc-text">选择器（Selector）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.0.3.</span> <span class="toc-text">选择器的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.4.</span> <span class="toc-text">Selector常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel"><span class="toc-number">3.0.5.</span> <span class="toc-text">SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DatagramChannel"><span class="toc-number">3.0.6.</span> <span class="toc-text">DatagramChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%EF%BC%88Pipe%EF%BC%89"><span class="toc-number">3.0.7.</span> <span class="toc-text">管道（Pipe）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">3.0.7.1.</span> <span class="toc-text">读写操作</span></a></li></ol></li></ol></li></ol></li></ol>
                </div>
            
            <hr />
            <h2 id="NewIO简介"><a href="#NewIO简介" class="headerlink" title="NewIO简介"></a>NewIO简介</h2><ul>
<li>Java NIO(New IO)是从java1.4版本开始引入的一个新的IO API，可以代替标准的Java IO API</li>
<li>NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</li>
</ul>
<h3 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h3><table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>面向流（Stream Oriented）</td>
<td>面向缓冲区（Buffer Oriented）</td>
</tr>
<tr>
<td>阻塞IO（Blocking IO）</td>
<td>非阻塞IO（Non Blocking IO）</td>
</tr>
<tr>
<td>无</td>
<td>选择器（Selectors）</td>
</tr>
</tbody></table>
<h2 id="缓冲区-Buffer-amp-通道-Channel"><a href="#缓冲区-Buffer-amp-通道-Channel" class="headerlink" title="缓冲区(Buffer)&amp;通道(Channel)"></a>缓冲区(Buffer)&amp;通道(Channel)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>Java NIO系统的核心在于：通道(Channel)和缓冲区 (Buffer)。通道表示打开到 IO 设备(例如：文件、 套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</li>
</ul>
<h3 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul>
<li>缓冲区（Buffer）：一个用于特定基本数据类 型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。</li>
<li>Java NIO 中的 Buffer 主要用于与 NIO 通道<strong>进行 交互</strong>，数据是从通道读入缓冲区，从缓冲区写 入通道中的</li>
</ul>
<h4 id="Buffer常用子类"><a href="#Buffer常用子类" class="headerlink" title="Buffer常用子类"></a>Buffer常用子类</h4><p>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类</p>
<ul>
<li>ByteBuffer </li>
<li>CharBuffer </li>
<li>ShortBuffer </li>
<li>IntBuffer </li>
<li>LongBuffer </li>
<li>FloatBuffer </li>
<li>DoubleBuffer</li>
</ul>
<p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自 管理的数据类型不同而已。都是通过如下方法获取一个 Buffer  对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> XxxBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span> : 创建一个容量为 capacity 的 XxxBuffer 对象</span></span><br></pre></td></tr></table></figure>

<h4 id="Buffer中的重要概念"><a href="#Buffer中的重要概念" class="headerlink" title="Buffer中的重要概念"></a>Buffer中的重要概念</h4><ul>
<li><strong>容量 (capacity)</strong> ：表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改</li>
<li>**限制 (limit)**：第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量</li>
<li>**位置 (position)**：下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制</li>
<li>**标记 (mark)与重置 (reset)**：标记是一个索引，通过 Buffer 中的 mark() 方法 指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这 个 position.</li>
</ul>
<p>注意：标记、位置、限制、容量遵守以下不变式： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/64Oolt"><img src="https://z3.ax1x.com/2021/03/21/64Oolt.png" alt="64Oolt.png"></a></p>
<h4 id="Buffer常用方法"><a href="#Buffer常用方法" class="headerlink" title="Buffer常用方法"></a>Buffer常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Buffer clear()</td>
<td>清空缓冲区并返回对缓冲区的引用</td>
</tr>
<tr>
<td>Buffer flip()</td>
<td>将缓冲区的界限设置为当前位置，并将当前位置重置为0</td>
</tr>
<tr>
<td>int capacity()</td>
<td>返回Buffer的capacity大小</td>
</tr>
<tr>
<td>boolean hasRemaining()</td>
<td>判断缓冲区中是否还有元素</td>
</tr>
<tr>
<td>int limit()</td>
<td>返回Buffer的界限（limit）的位置</td>
</tr>
<tr>
<td>Buffer limit(int n)</td>
<td>将设置缓冲区界限为n，并返回修改后的buffer对象</td>
</tr>
<tr>
<td>Buffer mark()</td>
<td>对缓冲区设置标记</td>
</tr>
<tr>
<td>int position()</td>
<td>返回缓冲区的当前位置position</td>
</tr>
<tr>
<td>Buffer position(int n)</td>
<td>将设置缓冲区的当前位置为n,并返回修改后的Buffer对象</td>
</tr>
<tr>
<td>int remaining()</td>
<td>返回position和limit之间的元素个数</td>
</tr>
<tr>
<td>Buffer reset()</td>
<td>将位置position转到以前设置的mark所在的位置</td>
</tr>
<tr>
<td>Buffer rewind()</td>
<td>将位置设为0，取消设置的mark</td>
</tr>
</tbody></table>
<h4 id="Buffer的数据操作"><a href="#Buffer的数据操作" class="headerlink" title="Buffer的数据操作"></a>Buffer的数据操作</h4><p>使用Buffer读写数据一般遵循以下四个步骤:</p>
<ol>
<li>写入数据到Buffer</li>
<li>调用flip()方法</li>
<li>从Buffer中读取数据</li>
<li>调用clear()方法或者compact()方法</li>
</ol>
<p>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过<strong>flip()方法</strong>将Buffer从<strong>写模式切换到读模式</strong>。在读模式下，可以读取之前写入到buffer的所有数据。</p>
<p>一旦读完了所有的数据，就需要<strong>清空缓冲区</strong>，让它可以再次被写入。有两种方式能清空缓冲区：调用**clear()<strong>或</strong>compact()**方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</p>
<ul>
<li>Buffer 所有子类提供了两个用于数据操作的方法：get()  与 put() 方法<ul>
<li>获取 Buffer 中的数据<ul>
<li>get()：读取单个字节</li>
<li>get(byte[] dst)：批量读取多个字节到dst中</li>
<li>get(int index)：读取指定索引位置的字节（不会移动position）</li>
</ul>
</li>
<li>放入数据到 Buffer 中<ul>
<li>put(byte b)：将给定单个字节写入缓冲区的当前位置</li>
<li>put(byte[] src)：将src中的字节写入缓冲区的当前位置</li>
<li>put(int index,byte b)：将指定字节写入缓冲区的索引位置（不会移动position）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBuffer</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//分配直接缓冲区</span></span><br><span class="line">		ByteBuffer buf = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(buf.isDirect());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">		</span><br><span class="line">		buf.put(str.getBytes());</span><br><span class="line">		</span><br><span class="line">		buf.flip();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line">		buf.get(dst, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">		System.out.println(buf.position());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//mark() : 标记</span></span><br><span class="line">		buf.mark();</span><br><span class="line">		</span><br><span class="line">		buf.get(dst, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(dst, <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">		System.out.println(buf.position());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//reset() : 恢复到 mark 的位置</span></span><br><span class="line">		buf.reset();</span><br><span class="line">		System.out.println(buf.position());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//判断缓冲区中是否还有剩余数据</span></span><br><span class="line">		<span class="keyword">if</span>(buf.hasRemaining())&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//获取缓冲区中可以操作的数量</span></span><br><span class="line">			System.out.println(buf.remaining());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1. 分配一个指定大小的缓冲区</span></span><br><span class="line">		ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------allocate()----------------&quot;</span>);</span><br><span class="line">		System.out.println(buf.position());</span><br><span class="line">		System.out.println(buf.limit());</span><br><span class="line">		System.out.println(buf.capacity());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2. 利用 put() 存入数据到缓冲区中</span></span><br><span class="line">		buf.put(str.getBytes());</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------put()----------------&quot;</span>);</span><br><span class="line">		System.out.println(buf.position());</span><br><span class="line">		System.out.println(buf.limit());</span><br><span class="line">		System.out.println(buf.capacity());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3. 切换读取数据模式</span></span><br><span class="line">		buf.flip();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------flip()----------------&quot;</span>);</span><br><span class="line">		System.out.println(buf.position());</span><br><span class="line">		System.out.println(buf.limit());</span><br><span class="line">		System.out.println(buf.capacity());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4. 利用 get() 读取缓冲区中的数据</span></span><br><span class="line">		<span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line">		buf.get(dst);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, dst.length));</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------get()----------------&quot;</span>);</span><br><span class="line">		System.out.println(buf.position());</span><br><span class="line">		System.out.println(buf.limit());</span><br><span class="line">		System.out.println(buf.capacity());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5. rewind() : 可重复读</span></span><br><span class="line">		buf.rewind();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------rewind()----------------&quot;</span>);</span><br><span class="line">		System.out.println(buf.position());</span><br><span class="line">		System.out.println(buf.limit());</span><br><span class="line">		System.out.println(buf.capacity());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//6. clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态</span></span><br><span class="line">		buf.clear();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------clear()----------------&quot;</span>);</span><br><span class="line">		System.out.println(buf.position());</span><br><span class="line">		System.out.println(buf.limit());</span><br><span class="line">		System.out.println(buf.capacity());</span><br><span class="line">		</span><br><span class="line">		System.out.println((<span class="keyword">char</span>)buf.get());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="直接与非直接缓冲区"><a href="#直接与非直接缓冲区" class="headerlink" title="直接与非直接缓冲区"></a>直接与非直接缓冲区</h4><ul>
<li><p>非直接缓冲区：通过 allocate() 方法分配缓冲区，将<strong>缓冲区建立在 JVM 的内存中</strong>,遇到大文本的文件时 效率及其低下.</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/65S6OI"><img src="https://z3.ax1x.com/2021/03/21/65S6OI.png" alt="65S6OI.png"></a></p>
</li>
<li><p>直接缓冲区：通过 allocateDirect() 方法分配直接缓冲区，<strong>将缓冲区建立在物理内存中</strong>。可以提高效率</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/65SrSH"><img src="https://z3.ax1x.com/2021/03/21/65SrSH.png" alt="65SrSH.png"></a></p>
</li>
</ul>
<p>注意：其中传统的io和 nio的accocate()都是<strong>非直接缓冲区</strong>.</p>
<h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><ul>
<li>通道（Channel）：由 java.nio.channels 包定义的。Channel 表示 IO 源与目标打开的连接。 Channel 类似于传统的“流”。只不过 Channel  本身不能直接访问数据，Channel 只能与 Buffer 进行交互</li>
</ul>
<h4 id="Channel实现类"><a href="#Channel实现类" class="headerlink" title="Channel实现类"></a>Channel实现类</h4><ul>
<li>FileChannel：用于读取、写入、映射和操作文件的通道</li>
<li>DatagramChannel：通过UDP读写网络中的数据通道</li>
<li>SocketChannel：通过TCP读写网络中的数据</li>
<li>ServerSocketChannel：可以监听新进来的TCP连接，对每一个新进来的连接都会创建一个SocketChannel</li>
</ul>
<h4 id="获取Channel"><a href="#获取Channel" class="headerlink" title="获取Channel"></a>获取Channel</h4><p>获取通道的一种方式是对支持通道的对象调用 <strong>getChannel()</strong> 方法</p>
<p>支持通道的类：</p>
<ul>
<li>本地IO:<ul>
<li>FileInputStream </li>
<li>FileOutputStream </li>
<li>RandomAccessFile </li>
</ul>
</li>
<li>网络IO:<ul>
<li>DatagramSocket </li>
<li>Socket </li>
<li>ServerSocket</li>
</ul>
</li>
</ul>
<p>获取通道的其他方式是使用 <strong>Files 类的静态方法 newByteChannel()</strong> 获 取字节通道。或者通过通道的<strong>静态方法 open()</strong> 打开并返回指定通道</p>
<h4 id="Channel的数据传输"><a href="#Channel的数据传输" class="headerlink" title="Channel的数据传输"></a>Channel的数据传输</h4><h5 id="将-Buffer-中数据写入-Channel"><a href="#将-Buffer-中数据写入-Channel" class="headerlink" title="将 Buffer 中数据写入 Channel"></a>将 Buffer 中数据写入 Channel</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesWritten=inChannel.write(buf);</span><br></pre></td></tr></table></figure>

<h5 id="从-Channel-读取数据到-Buffer"><a href="#从-Channel-读取数据到-Buffer" class="headerlink" title="从 Channel 读取数据到 Buffer"></a>从 Channel 读取数据到 Buffer</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead=inChannel.read(buf); </span><br></pre></td></tr></table></figure>

<h4 id="分散-Scatter-和聚集-Gather"><a href="#分散-Scatter-和聚集-Gather" class="headerlink" title="分散(Scatter)和聚集(Gather)"></a>分散(Scatter)和聚集(Gather)</h4><h5 id="分散读取（Scattering-Reads）"><a href="#分散读取（Scattering-Reads）" class="headerlink" title="分散读取（Scattering Reads）"></a>分散读取（Scattering Reads）</h5><p>是指从 Channel 中读取的数据“分 散”到多个 Buffer 中。</p>
<p>注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满</p>
<h5 id="聚集写入（Gathering-Writes）"><a href="#聚集写入（Gathering-Writes）" class="headerlink" title="聚集写入（Gathering Writes）"></a>聚集写入（Gathering Writes）</h5><p>是指将多个 Buffer 中的数据“聚集” 到 Channel。</p>
<p>注意：按照缓冲区的顺序，写入 position 和 limit 之间的数据到 Channel 。</p>
<h4 id="通道之间的数据传输"><a href="#通道之间的数据传输" class="headerlink" title="通道之间的数据传输"></a>通道之间的数据传输</h4><h5 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h5><p>将数据从源通道传输到其他 Channel </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RandomAccesFile fromFile=<span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;文件路径&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="comment">//获取FileChannel</span></span><br><span class="line">FileChannel fromChannel=fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile=<span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;文件路径&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel toChannel=toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义传输位置</span></span><br><span class="line"><span class="keyword">long</span> position =<span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最多传输的字节数</span></span><br><span class="line"><span class="keyword">long</span>=count = fromChannel.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据从源通道传输到另一个通道</span></span><br><span class="line">toChannel.transferFrom(fromChannel,count,position);</span><br></pre></td></tr></table></figure>

<h5 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h5><p>将数据从源通道传输到其他Channel中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile=<span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;文件路径&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="comment">//获取FileChannel</span></span><br><span class="line">FileChannel fromChannel=fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile=<span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;文件路径&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel toChannel=toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义传输位置</span></span><br><span class="line"><span class="keyword">long</span> position =<span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最多传输的字节数</span></span><br><span class="line"><span class="keyword">long</span>=count = fromChannel.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据从源通道传输到另一个通道</span></span><br><span class="line">fromChannel.transferTo(position,count,toChannel);</span><br></pre></td></tr></table></figure>

<h4 id="FileChannel常用方法"><a href="#FileChannel常用方法" class="headerlink" title="FileChannel常用方法"></a>FileChannel常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int read(ByteBuffer dst)</td>
<td>从 Channel 中读取数据到 ByteBuffer</td>
</tr>
<tr>
<td>long read(ByteBuffer[] dsts)</td>
<td>将 Channel 中的数据“分散”到 ByteBuffer[]</td>
</tr>
<tr>
<td>int write(ByteBuffer src)</td>
<td>将 ByteBuffer 中的数据写入到 Channel</td>
</tr>
<tr>
<td>long write(ByteBuffer[] srcs)</td>
<td>将 ByteBuffer[] 中的数据“聚集”到 Channel</td>
</tr>
<tr>
<td>long position()</td>
<td>返回此通道的文件位置</td>
</tr>
<tr>
<td>FileChannel position(long p)</td>
<td>设置此通道的文件位置</td>
</tr>
<tr>
<td>long size()</td>
<td>返回此通道的文件的当前大小</td>
</tr>
<tr>
<td>FileChannel truncate(long s)</td>
<td>将此通道的文件截取为给定大小</td>
</tr>
<tr>
<td>void force(boolean metaData)</td>
<td>强制将所有对此通道的文件更新写入到存储设备中</td>
</tr>
</tbody></table>
<h2 id="NIO的非阻塞式网络通信"><a href="#NIO的非阻塞式网络通信" class="headerlink" title="NIO的非阻塞式网络通信"></a>NIO的非阻塞式网络通信</h2><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><ul>
<li><strong>传统的 IO 流</strong>都是<strong>阻塞式</strong>的。也就是说，当一个线程调用 read() 或 write()  时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行 IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理， 当服务器端需要处理大量客户端时，性能急剧下降</li>
<li>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO可以让服务器端使用一个或有限几个线程来同 时处理连接到服务器端的所有客户端</li>
</ul>
<h4 id="选择器（Selector）"><a href="#选择器（Selector）" class="headerlink" title="选择器（Selector）"></a>选择器（Selector）</h4><ul>
<li>选择器（Selector） 是 SelectableChannel 对象的多路复用器，Selector 可 以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector  可使一个单独的线程管理多个 Channel。Selector 是非阻塞 IO 的核心</li>
</ul>
<h4 id="选择器的应用"><a href="#选择器的应用" class="headerlink" title="选择器的应用"></a>选择器的应用</h4><p>创建 Selector</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过调用 Selector.open() 方法创建一个 Selector</span></span><br><span class="line">Selector selector=Selector.open();</span><br></pre></td></tr></table></figure>

<p>向选择器注册通道</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Socket关键字</span></span><br><span class="line">Socket socket=<span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9898</span>);</span><br><span class="line"><span class="comment">//获取SocketChannel</span></span><br><span class="line">SocketChannel channel=socket.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建选择器</span></span><br><span class="line">Selector selector=Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将SocketChannel切换到非阻塞模式</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向Selector注册Channel</span></span><br><span class="line">SelectionKey key=channel.register(selector,SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>

<ul>
<li>当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。</li>
<li>可以监听的事件类型（可使用 SelectionKey 的四个常量表示）<ul>
<li>读 : SelectionKey.OP_READ </li>
<li>写 : SelectionKey.OP_WRITE </li>
<li>连接 : SelectionKey.OP_CONNECT</li>
<li>接收 : SelectionKey.OP_ACCEPT </li>
</ul>
</li>
</ul>
<p>若注册时不止监听一个事件，则可以使用“<strong>位或</strong>”操作符连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册监听事件</span></span><br><span class="line"><span class="keyword">int</span> interestSet=SelectionKey.OP_READ|SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<p><strong>SelectionKey</strong>：表示 SelectableChannel 和 Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整 数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>int interestOps()</td>
<td>获取感兴趣事件集合</td>
</tr>
<tr>
<td>int readyOps()</td>
<td>获取通道已经准备就绪的操作的集合</td>
</tr>
<tr>
<td>SelectableChannel channel()</td>
<td>获取注册通道</td>
</tr>
<tr>
<td>Selector selector()</td>
<td>返回选择器</td>
</tr>
<tr>
<td>boolean isReadable()</td>
<td>检测Channel中读事件是否就绪</td>
</tr>
<tr>
<td>boolean isWritable()</td>
<td>检测Channel中写事件是否就绪</td>
</tr>
<tr>
<td>boolean isConnectable()</td>
<td>检测Channel中连接是否就绪</td>
</tr>
<tr>
<td>boolean isAcceptable()</td>
<td>检测Channel中接收是否就绪</td>
</tr>
</tbody></table>
<h4 id="Selector常用方法"><a href="#Selector常用方法" class="headerlink" title="Selector常用方法"></a>Selector常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Set&lt; SelectionKey &gt;  keys()</td>
<td>所有的 SelectionKey 集合。代表注册在该Selector上的Channel</td>
</tr>
<tr>
<td>selectedKeys()</td>
<td>被选择的 SelectionKey 集合。返回此Selector的已选择键集</td>
</tr>
<tr>
<td>int select()</td>
<td>监控所有注册的Channel，当它们中间有需要处理的 IO 操作时， 该方法返回，并将对应得的 SelectionKey 加入被选择的 SelectionKey 集合中，该方法返回这些 Channel 的数量。</td>
</tr>
<tr>
<td>int select(long timeout)</td>
<td>可以设置超时时长的 select() 操作</td>
</tr>
<tr>
<td>int selectNow();</td>
<td>执行一个立即返回的 select() 操作，该方法不会阻塞线程</td>
</tr>
<tr>
<td>Selector wakeup()</td>
<td>使一个还未返回的 select() 方法立即返回</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭该选择器</td>
</tr>
</tbody></table>
<h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道</p>
<ul>
<li>操作步骤：</li>
</ul>
<ol>
<li>打开 SocketChannel</li>
<li>读写数据</li>
<li>关闭 SocketChannel</li>
</ol>
<p>Java NIO中的 ServerSocketChannel 是一个可以 监听新进来的TCP连接的通道，就像标准IO中 的ServerSocket一样。</p>
<h4 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h4><ul>
<li>Java NIO中的DatagramChannel是一个能收发 UDP包的通道</li>
<li>操作步骤<ul>
<li>打开 DatagramChannel</li>
<li>接收/发送数据</li>
</ul>
</li>
</ul>
<h4 id="管道（Pipe）"><a href="#管道（Pipe）" class="headerlink" title="管道（Pipe）"></a>管道（Pipe）</h4><ul>
<li>Java NIO 管道是2个线程之间的<strong>单向数据连接</strong>。 Pipe有一个<strong>source</strong>通道和一个<strong>sink</strong>通道。数据会 被写到sink通道，从source通道读取。</li>
</ul>
<h5 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">		<span class="comment">//1. 获取管道</span></span><br><span class="line">		Pipe pipe = Pipe.open();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2. 将缓冲区中的数据写入管道</span></span><br><span class="line">		ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">		</span><br><span class="line">		Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">		buf.put(<span class="string">&quot;通过单向管道发送数据&quot;</span>.getBytes());</span><br><span class="line">		buf.flip();</span><br><span class="line">		sinkChannel.write(buf);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3. 读取缓冲区中的数据</span></span><br><span class="line">		Pipe.SourceChannel sourceChannel = pipe.source();</span><br><span class="line">		buf.flip();</span><br><span class="line">		<span class="keyword">int</span> len = sourceChannel.read(buf);</span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, len));</span><br><span class="line">		</span><br><span class="line">		sourceChannel.close();</span><br><span class="line">		sinkChannel.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2021/03/21/NewIO/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2021/03/21/NewIO/";
            const title         = "「NewIO」";
            const excerpt       = `NewIO简介
Java NIO(New IO)是从java1.4版本开始引入的一个新的IO API，可以代替标准的Java IO API
NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。

J...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    
                </div>
                <div class="pull-date">
                <span>最后编辑：2021-08-11</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" JUC" href="/2021/03/18/JUC/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" HTML&amp;CSS" href="/2021/03/22/HTML&CSS/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">不要走进那个温和的良宵。</p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#NewIO%E7%AE%80%E4%BB%8B"><span class="toc-text">NewIO简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-NIO%E5%92%8CIO%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-text">Java NIO和IO的主要区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA-Buffer-amp-%E9%80%9A%E9%81%93-Channel"><span class="toc-text">缓冲区(Buffer)&amp;通道(Channel)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88Buffer%EF%BC%89"><span class="toc-text">缓冲区（Buffer）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E5%B8%B8%E7%94%A8%E5%AD%90%E7%B1%BB"><span class="toc-text">Buffer常用子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-text">Buffer中的重要概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Buffer常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E7%9A%84%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="toc-text">Buffer的数据操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-text">直接与非直接缓冲区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93-Channel"><span class="toc-text">通道(Channel)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">Channel实现类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Channel"><span class="toc-text">获取Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-text">Channel的数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86-Buffer-%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5-Channel"><span class="toc-text">将 Buffer 中数据写入 Channel</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E-Channel-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%88%B0-Buffer"><span class="toc-text">从 Channel 读取数据到 Buffer</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%95%A3-Scatter-%E5%92%8C%E8%81%9A%E9%9B%86-Gather"><span class="toc-text">分散(Scatter)和聚集(Gather)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%95%A3%E8%AF%BB%E5%8F%96%EF%BC%88Scattering-Reads%EF%BC%89"><span class="toc-text">分散读取（Scattering Reads）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E5%86%99%E5%85%A5%EF%BC%88Gathering-Writes%EF%BC%89"><span class="toc-text">聚集写入（Gathering Writes）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-text">通道之间的数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#transferFrom"><span class="toc-text">transferFrom()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#transferTo"><span class="toc-text">transferTo()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">FileChannel常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-text">NIO的非阻塞式网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">阻塞与非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%88Selector%EF%BC%89"><span class="toc-text">选择器（Selector）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">选择器的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">Selector常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel"><span class="toc-text">SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DatagramChannel"><span class="toc-text">DatagramChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%EF%BC%88Pipe%EF%BC%89"><span class="toc-text">管道（Pipe）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-text">读写操作</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Error/">Error</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDBC/">JDBC</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">29</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Web/">Java Web</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MyBatis/">MyBatis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SSM/">SSM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/springmvc/">springmvc</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ssm/">ssm</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%91%E5%B9%B4%E3%81%AE%E6%97%A5%E5%B8%B8/">少年の日常</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">1</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/Callable/" style="font-size: 0.6em;">Callable</a> <a href="/tags/Date/" style="font-size: 0.6em;">Date</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 0.6em;">Java基础</a> <a href="/tags/Map/" style="font-size: 0.6em;">Map</a> <a href="/tags/NoSQL/" style="font-size: 0.6em;">NoSQL</a> <a href="/tags/OOP/" style="font-size: 0.6em;">OOP</a> <a href="/tags/Set/" style="font-size: 0.6em;">Set</a> <a href="/tags/Socket/" style="font-size: 0.6em;">Socket</a> <a href="/tags/String/" style="font-size: 0.6em;">String</a> <a href="/tags/TCP/" style="font-size: 0.6em;">TCP</a> <a href="/tags/UDP/" style="font-size: 0.6em;">UDP</a> <a href="/tags/lock/" style="font-size: 0.6em;">lock</a> <a href="/tags/mybatis/" style="font-size: 0.6em;">mybatis</a> <a href="/tags/redis/" style="font-size: 0.6em;">redis</a> <a href="/tags/springmvc/" style="font-size: 0.6em;">springmvc</a> <a href="/tags/ssm/" style="font-size: 0.6em;">ssm</a> <a href="/tags/synchronized/" style="font-size: 0.6em;">synchronized</a> <a href="/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/" style="font-size: 0.6em;">包装类</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2021/11/11/20211111-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"><i class="fa  fa-book"></i> 对象的实例化内存布局与访问定位</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/11/11/20211111-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E(%E6%9C%AA%E5%AE%8C)/"><i class="fa  fa-book"></i> 执行引擎</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/11/11/20211111-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/"><i class="fa  fa-book"></i> 直接内存</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/11/11/20211111-Java8%E6%96%B0%E7%89%B9%E6%80%A7/"><i class="fa  fa-book"></i> Java8新特性</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/11/10/20211110-JVM%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"><i class="fa  fa-book"></i> JVM常见面试题</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        <li><a href="mailto:1922856021@qq.com"><i class="fa fa-envelope"></i></a></li>
                        
                        
                        
                        
                        
                        
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2021 青い栞 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by FunnyLs.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>
<script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script>

    <div>
        <canvas id="snow"></canvas>
        <script async type="text/javascript" src="/js/snow.min.js"></script>
    </div>

<script async src="/js/candy.min.js"></script>

    <script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>