<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="">
  <title>面向对象编程(OOP) | 青い栞</title>
  <meta name="author" content="FunnyLs" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="Java基础, OOP" />
  
  <meta name="description" content="基本概念面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装。 优点：  易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护  缺点：  性能比面向过程差  三大特性 封装">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象编程(OOP)">
<meta property="og:url" content="http://example.com/2021/07/22/2021722-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(OOP)/index.html">
<meta property="og:site_name" content="青い栞">
<meta property="og:description" content="基本概念面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装。 优点：  易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护  缺点：  性能比面向过程差  三大特性 封装">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/null">
<meta property="article:published_time" content="2021-07-21T16:00:00.000Z">
<meta property="article:modified_time" content="2021-08-08T13:44:21.148Z">
<meta property="article:author" content="FunnyLs">
<meta property="article:tag" content="Java基础">
<meta property="article:tag" content="OOP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/null">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-blue.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/qrcode_js@1.0.0/qrcode.min.js"></script>
  
<meta name="generator" content="Hexo 5.4.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"></a></li>
                                    
                                
                                    
                                        <li>
                                            <a><i class="fa fa-link"></i>链接</a>
                                            <ul class="sub-menu">
                                                
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://candinya.com">作者博客</a></li>
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://github.com/Candinya/Kratos-Rebirth">项目链接</a></li>
                                                    
                                                
                                            </ul>
                                        </li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">青い栞</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>青い栞</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">面向对象编程(OOP)</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2021-07-22</li>
                <li><i class="fa fa-user"></i> 作者 FunnyLs</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~10.93K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                本文最后编辑于 <time datetime="1628430261148"></time> 前，其中的内容可能需要更新。
            </div>
            
                <div class="kratos-post-inner-toc">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">三大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">1.2.</span> <span class="toc-text">五大基本原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">访问属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">类和对象的内存分配机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">方法调用机制原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">3.1.1.</span> <span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">基本数据类型的传参机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">引用数据类型的传参机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92"><span class="toc-number">3.4.</span> <span class="toc-text">方法递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%EF%BC%88OverLoad%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">方法重载（OverLoad）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-1"><span class="toc-number">3.5.1.</span> <span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">3.6.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.6.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">3.6.3.</span> <span class="toc-text">注意事项和使用细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.7.</span> <span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-2"><span class="toc-number">3.7.1.</span> <span class="toc-text">使用细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">构造方法&#x2F;构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-number">4.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-3"><span class="toc-number">4.2.</span> <span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.3.</span> <span class="toc-text">对象创建流程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.4.</span> <span class="toc-text">this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-4"><span class="toc-number">4.4.1.</span> <span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.5.</span> <span class="toc-text">访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.5.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">5.</span> <span class="toc-text">面向对象编程三大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">5.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">5.2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.2.1.</span> <span class="toc-text">super关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#super-%E5%92%8C-this-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">super 和 this 的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">5.3.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BD%93%E7%8E%B0"><span class="toc-number">5.3.1.</span> <span class="toc-text">具体体现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">方法的多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">对象的多态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">5.3.2.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.3.</span> <span class="toc-text">动态绑定机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">5.3.4.</span> <span class="toc-text">多态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">5.3.5.</span> <span class="toc-text">多态参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-%E8%A6%86%E7%9B%96"><span class="toc-number">6.</span> <span class="toc-text">方法重写&#x2F;覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-5"><span class="toc-number">6.1.</span> <span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD"><span class="toc-number">6.2.</span> <span class="toc-text">重写与重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="toc-number">7.</span> <span class="toc-text">Object类详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95-amp"><span class="toc-number">7.1.</span> <span class="toc-text">equals方法&amp;&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashcode%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">hashcode方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">toString方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finalize%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.</span> <span class="toc-text">finalize方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">类变量和类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-number">8.1.</span> <span class="toc-text">类变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-6"><span class="toc-number">8.1.1.</span> <span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.2.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-7"><span class="toc-number">8.2.2.</span> <span class="toc-text">使用细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mian%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">mian方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">10.</span> <span class="toc-text">代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">10.1.</span> <span class="toc-text">格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3"><span class="toc-number">10.2.</span> <span class="toc-text">理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-8"><span class="toc-number">10.3.</span> <span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">11.</span> <span class="toc-text">final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-9"><span class="toc-number">11.1.</span> <span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-10"><span class="toc-number">12.1.</span> <span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-11"><span class="toc-number">13.1.</span> <span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">13.2.</span> <span class="toc-text">接口和继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.1.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.2.</span> <span class="toc-text">匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.3.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">14.4.</span> <span class="toc-text">静态内部类</span></a></li></ol></li></ol>
                </div>
            
            <hr />
            <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。面向对象的<strong>底层其实还是面向过程</strong>，把面向过程抽象成类，然后封装。</p>
<p>优点：</p>
<ul>
<li>易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能比面向过程差</li>
</ul>
<h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><ol>
<li><p>封装</p>
<p>隐藏对象的属性和实现细节，仅对外提供公共访问方式，将便于隔离，便于使用，提高复用性和安全性</p>
</li>
<li><p>继承</p>
<p>提高代码复用性；继承是多态的前提</p>
</li>
<li><p>多态</p>
<p>父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性</p>
</li>
</ol>
<h3 id="五大基本原则"><a href="#五大基本原则" class="headerlink" title="五大基本原则"></a>五大基本原则</h3><ol>
<li><p>单一职责原则SRP（Single Responsibility Principle）</p>
<p>类的功能要单一，不能包罗万象，跟杂货铺似的</p>
</li>
<li><p>开放封闭原则OCP(Open－Close Principle)</p>
<p>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意</p>
</li>
<li><p>里氏替换原则LSP(the Liskov Substitution Principle LSP)</p>
<p>子类可以替换父类出现在父类能够出现的任何地方</p>
</li>
<li><p>依赖倒置原则DIP(the Dependency Inversion Principle DIP)</p>
<p>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象</p>
</li>
<li><p>接口分离原则ISP(the Interface Segregation Principle ISP)</p>
<p>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好</p>
</li>
</ol>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p>对象名.属性名</p>
<h3 id="类和对象的内存分配机制"><a href="#类和对象的内存分配机制" class="headerlink" title="类和对象的内存分配机制"></a>类和对象的内存分配机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person P1=<span class="keyword">new</span> Person();</span><br><span class="line">p1.age=<span class="number">10</span>;</span><br><span class="line">p1.name=<span class="string">&quot;小明&quot;</span>;</span><br><span class="line">person P2=P1;<span class="comment">//把P1赋给了P2，让P2指向了P1</span></span><br><span class="line">System.out.println(P2.age);</span><br></pre></td></tr></table></figure>

<p>p2.age是多少？画出内存图</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/WB3onJ"><img src="https://z3.ax1x.com/2021/07/22/WB3onJ.png" alt="WB3onJ.png"></a></p>
<p>Java内存结构分析</p>
<ol>
<li>栈：一般存放基本数据类型（局部变量）</li>
<li>堆：存放对象(Cat cat，数组等)</li>
<li>方法区：常量池（常量，比如字符串），类加载信息</li>
<li>创建对象流程：<ol>
<li>先加载类信息（属性和方法信息，只会加载一次）</li>
<li>在堆中分配空间，进行默认初始化</li>
<li>把地址赋给对象名，对象名指向对象</li>
</ol>
</li>
</ol>
<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="方法调用机制原理"><a href="#方法调用机制原理" class="headerlink" title="方法调用机制原理"></a>方法调用机制原理</h3><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/WDWnne"><img src="https://z3.ax1x.com/2021/07/22/WDWnne.png" alt="WDWnne.png"></a></p>
<p>成员方法的好处：</p>
<ol>
<li>提高代码复用性</li>
<li>可以将实现的细节封装起来，然后供其他用户来调用</li>
</ol>
<h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><ol>
<li>调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数</li>
<li>方法不能嵌套定义</li>
<li>一个方法最多有一个返回值</li>
<li>返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)</li>
<li>如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值，而且要求返回值类型必须和 return 的值类型一致或兼容</li>
<li>如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return;</li>
</ol>
<h3 id="基本数据类型的传参机制"><a href="#基本数据类型的传参机制" class="headerlink" title="基本数据类型的传参机制"></a>基本数据类型的传参机制</h3><p>基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b=<span class="number">20</span>;</span><br><span class="line">    <span class="comment">//创建AA对象，名为obj</span></span><br><span class="line">    AA obj=<span class="keyword">new</span> AA();</span><br><span class="line">    obj.swap(a,b);<span class="comment">//调用swap</span></span><br><span class="line">    System.out.println(<span class="string">&quot;main方法a=&quot;</span>+a+<span class="string">&quot;b=&quot;</span>+b);<span class="comment">//a=10,b=20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;a和b交换前的值a=&quot;</span>+a+<span class="string">&quot;b=&quot;</span>+b);<span class="comment">//a=10,b=20</span></span><br><span class="line">        <span class="comment">//a和b交换</span></span><br><span class="line">        <span class="keyword">int</span> temp=a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=temp;</span><br><span class="line">        System.out.println(<span class="string">&quot;a和b交换后的值a=&quot;</span>+a+<span class="string">&quot;b=&quot;</span>+b);<span class="comment">//a=20,b=10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/WDIELT"><img src="https://z3.ax1x.com/2021/07/22/WDIELT.png" alt="WDIELT.png"></a></p>
<h3 id="引用数据类型的传参机制"><a href="#引用数据类型的传参机制" class="headerlink" title="引用数据类型的传参机制"></a>引用数据类型的传参机制</h3><p>引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参</p>
<h3 id="方法递归"><a href="#方法递归" class="headerlink" title="方法递归"></a>方法递归</h3><ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响，比如n变量</li>
<li>如果方法中使用的是引用类型变量(比如数组，对象)，就会共享该引用类型的数据</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError</li>
<li>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</li>
</ol>
<h3 id="方法重载（OverLoad）"><a href="#方法重载（OverLoad）" class="headerlink" title="方法重载（OverLoad）"></a>方法重载（OverLoad）</h3><p>java 中允许同一个类中，多个同名方法的存在，但要求形参列表不一致</p>
<p>好处：减轻起名、记名的麻烦</p>
<h4 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h4><ol>
<li>方法名：必须相同</li>
<li>形参列表：必须不同(形参类型或个数或顺序，至少有一样不同，参数名无要求)</li>
<li>返回类型：无要求</li>
</ol>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。 就可以通过可变参数实现</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>访问修饰符 返回类型 方法名(数据类型… 形参名) { }</p>
<h4 id="注意事项和使用细节"><a href="#注意事项和使用细节" class="headerlink" title="注意事项和使用细节"></a>注意事项和使用细节</h4><ol>
<li>可变参数的形参可以为0个或任意多个</li>
<li>可变参数的实参可以为数组</li>
<li>可变参数的本质就是数组</li>
<li>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</li>
<li>一个形参列表中只能出现一个可变参数</li>
</ol>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ol>
<li><p>在java编程中，主要的变量就是属性(成员变量)和局部变量</p>
</li>
<li><p>我们说的局部变量一般是指在成员方法中定义的变量</p>
</li>
<li><p>java中作用域的分类</p>
<p>全局变量：也就是属性，作用域为整个类体</p>
<p>局部变量：也就是除了属性之外的其他变量，作用域为定义他的代码块中</p>
</li>
<li><p>全局变量(属性)可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值。</p>
</li>
</ol>
<h4 id="使用细节-2"><a href="#使用细节-2" class="headerlink" title="使用细节"></a>使用细节</h4><ol>
<li><p>属性和局部变量可以重名，访问时遵循就近原则</p>
</li>
<li><p>在同一个作用域中，例如在同一个成员方法中，两个局部变量不能重名</p>
</li>
<li><p>属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中</p>
</li>
<li><p>作用域范围不同</p>
<p>全局变量/属性：可以被本类使用，或其他类使用(通过对象调用)</p>
<p>局部变量：只能在本类中对应的方法中使用</p>
</li>
<li><p>修饰符不同</p>
<p>全局变量/属性：可以被本类使用，或其他类使用(通过对象调用)</p>
<p>局部变量：只能在本类中对应的方法中使用</p>
</li>
<li><p>修饰符不同</p>
<p>全局变量/属性可以加修饰符</p>
<p>局部变量不可以加修饰符</p>
</li>
</ol>
<h2 id="构造方法-构造器"><a href="#构造方法-构造器" class="headerlink" title="构造方法/构造器"></a>构造方法/构造器</h2><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><p>[修饰符] 方法名(形参列表){ 方法体; }</p>
<h3 id="使用细节-3"><a href="#使用细节-3" class="headerlink" title="使用细节"></a>使用细节</h3><ol>
<li>构造器的修饰符没有限制</li>
<li>构造器没有返回值</li>
<li>方法名和类名字必须一样</li>
<li>参数列表和成员方法一样的规则</li>
<li>构造器的调用，由系统完成</li>
<li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化</li>
<li>一个类可以定义多个不同的构造器，即构造器重载</li>
<li>构造器是完成对象初始化，并不是创建对象</li>
<li>如果没有手动定义构造器，系统会自动生成一个默认无参构造器</li>
<li>一旦定义自己的构造器，默认构造器就会被覆盖，就不能再使用，除非显式定义一下。</li>
</ol>
<h3 id="对象创建流程分析"><a href="#对象创建流程分析" class="headerlink" title="对象创建流程分析"></a>对象创建流程分析</h3><ol>
<li>加载类信息，只会加载一次</li>
<li>在堆中分配空间(地址)</li>
<li>完成对象初始化<ul>
<li>默认初始化——&gt;显式初始化——&gt;构造器初始化</li>
</ul>
</li>
<li>把对象在堆中的地址，返回给p(p是对象名，也可以理解成是对象的引用)</li>
</ol>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>java虚拟机会给每个对象分配this，代表当前对象。</p>
<p>哪个对象调用，this就代表哪个对象</p>
<h4 id="使用细节-4"><a href="#使用细节-4" class="headerlink" title="使用细节"></a>使用细节</h4><ol>
<li>this 关键字可以用来访问本类的属性、方法、构造器</li>
<li>this 用于区分当前类的属性和局部变量</li>
<li>访问成员方法的语法：this.方法名(参数列表);</li>
<li>访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句)</li>
<li>this 不能在类定义的外部使用，只能在类定义的方法中使用</li>
</ol>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>同类</th>
<th>同包</th>
<th>子类</th>
<th>不同包</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>修饰符可以用来修饰类中的属性，成员方法以及类</li>
<li>只有默认的和public才能修饰类，并且遵循上述访问权限的特点</li>
<li>成员方法的访问规则和属性相同</li>
</ol>
<h2 id="面向对象编程三大特征"><a href="#面向对象编程三大特征" class="headerlink" title="面向对象编程三大特征"></a>面向对象编程三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作</p>
<p>优点</p>
<ol>
<li>隐藏实现细节：方法(连接数据库)⬅调用(传入参数)</li>
<li>可以对数据进行验证，保证安全合理</li>
</ol>
<p>步骤</p>
<ol>
<li>将属性进行私有化private[不能直接修改属性]</li>
<li>提供一个公共的set方法，用于对属性判断并赋值</li>
<li>提供一个公共的get方法，用于获取属性的值</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承可以解决代码复用.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来 声明继承父类即可</p>
<ol>
<li>子类会自动拥有父类定义的属性和方法</li>
<li>父类又叫超类，基类</li>
<li>子类又叫派生类</li>
</ol>
<p>优点</p>
<ol>
<li>代码的复用性提高了</li>
<li>代码的扩展性和维护性提高了</li>
</ol>
<p>细节问题</p>
<ol>
<li>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问</li>
<li>子类必须调用父类的构造器， 完成父类的初始化</li>
<li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无 参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</li>
<li>如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)</li>
<li>super 在使用时，必须放在构造器第一行(super 只能在构造器中使用)</li>
<li>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li>
<li>java 所有类都是 Object 类的子类, Object 是所有类的基类</li>
<li>父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类)</li>
<li>子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制</li>
<li>不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系</li>
</ol>
<h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><p>super 代表父类的引用，用于访问父类的属性、方法、构造器</p>
<ol>
<li>访问父类的属性，但不能访问父类的private属性：super.属性名</li>
<li>访问父类的方法，但不能访问父类的private方法：super.方法名</li>
<li>访问父类的构造器：super(参数列表)（只能放在构造器的第一句，只能出现一次）</li>
</ol>
<p>优点</p>
<ol>
<li>分工明确，父类属性由父类初始化，子类的属性由子类初始化</li>
<li>当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果</li>
<li>super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员，如果多个基类中都有同名的成员，使用super访问遵循就近原则。当然也要遵循访问权限的相关规则</li>
</ol>
<h5 id="super-和-this-的比较"><a href="#super-和-this-的比较" class="headerlink" title="super 和 this 的比较"></a>super 和 this 的比较</h5><table>
<thead>
<tr>
<th>No.</th>
<th>区别</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>访问属性</td>
<td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>
<td>从父类开始查找属性</td>
</tr>
<tr>
<td>2</td>
<td>调用方法</td>
<td>访问本类中的方法，如果本类没有此方法则从父类继续查找</td>
<td>从父类开始查找方法</td>
</tr>
<tr>
<td>3</td>
<td>调用构造器</td>
<td>调用本类构造器，必须放在构造器的首行</td>
<td>调用父类构造器，必须放在子类构造器的首行</td>
</tr>
<tr>
<td>4</td>
<td>特殊</td>
<td>表示当前对象</td>
<td>子类中访问父类对象</td>
</tr>
</tbody></table>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的</p>
<h4 id="具体体现"><a href="#具体体现" class="headerlink" title="具体体现"></a>具体体现</h4><h5 id="方法的多态"><a href="#方法的多态" class="headerlink" title="方法的多态"></a>方法的多态</h5><p>重载中传入不同的参数，就会调用不同sum方法。</p>
<p>重写中不同对象调用同一方法，就会执行不同的内容</p>
<h5 id="对象的多态"><a href="#对象的多态" class="headerlink" title="对象的多态"></a>对象的多态</h5><ol>
<li>一个对象的编译类型和运行类型可以不一致</li>
<li>编译类型在确认对象时，就确定了，不能改变</li>
<li>运行类型是可以变化的</li>
<li>编译类型看定义时=号的左边，运行类型看=号的右边</li>
</ol>
<p>例如</p>
<p>Animal是Dog的父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal=<span class="keyword">new</span> Dog();</span><br></pre></td></tr></table></figure>

<p>表示animal编译类型是Animal，运行类型是Dog</p>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>多态的前提是：两个对象存在继承关系</li>
<li>多态的向上转型<ol>
<li>本质：父类的引用指向了子类的对象</li>
<li>语法：父类类型 引用名=new 子类类型();</li>
<li>特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员(需遵守访问权限)，不能调用子类中特有成员（因为在编译阶段，能调用哪些成员，是由编译类型来决定的）；最终运行效果看子类的具体实现（即调用方法时，按照从子类(运行类型)开始查找方法）</li>
</ol>
</li>
<li>多态向下转型<ol>
<li>语法：子类类型 引用名=(子类类型) 父类引用;</li>
<li>只能强转父类的引用，不能强转父类的对象</li>
<li>要求父类的引用必须指向的是当前目标类型的对象</li>
<li>当向下转型后，可以调用子类类型中所有的成员</li>
</ol>
</li>
<li>属性不能重写，属性的值看编译类型</li>
<li>instanceOf 比较操作符：用于判断对象的运行类型是否为xx类型或xx类型的子类型</li>
</ol>
<h4 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h4><ol>
<li>当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定</li>
<li>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</li>
</ol>
<h4 id="多态数组"><a href="#多态数组" class="headerlink" title="多态数组"></a>多态数组</h4><p>数组的定义类型为父类类型，里面保存的实际元素类型为子类类型</p>
<h4 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h4><p>方法定义的形参类型为父类类型，实参类型允许为子类类型</p>
<h2 id="方法重写-覆盖"><a href="#方法重写-覆盖" class="headerlink" title="方法重写/覆盖"></a>方法重写/覆盖</h2><p>当子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么子类方法会覆盖父类方法</p>
<h3 id="使用细节-5"><a href="#使用细节-5" class="headerlink" title="使用细节"></a>使用细节</h3><ol>
<li>子类的形参列表、方法名称要和父类的完全一样</li>
<li>子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类</li>
<li>子类方法不能缩小父类方法的访问权限</li>
</ol>
<h3 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h3><table>
<thead>
<tr>
<th>名称</th>
<th>发生范围</th>
<th>方法名</th>
<th>形参列表</th>
<th>返回类型</th>
<th>修饰符</th>
</tr>
</thead>
<tbody><tr>
<td>重载(overload)</td>
<td>本类</td>
<td>必须一样</td>
<td>类型、个数、顺序至少有一个不同</td>
<td>无要求</td>
<td>无要求</td>
</tr>
<tr>
<td>重写(override)</td>
<td>子父类</td>
<td>必须一样</td>
<td>相同</td>
<td>子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类</td>
<td>子类方法不能缩小父类方法的访问范围</td>
</tr>
</tbody></table>
<h2 id="Object类详解"><a href="#Object类详解" class="headerlink" title="Object类详解"></a>Object类详解</h2><h3 id="equals方法-amp"><a href="#equals方法-amp" class="headerlink" title="equals方法&amp;=="></a>equals方法&amp;==</h3><p>==是一个比较运算符</p>
<ol>
<li>既可以判断基本类型，又可以判断引用类型</li>
<li>判断基本类型判断的实质的值是否相等</li>
<li>判断引用类型判断的是地址是否相等，即判定是不是同一个对象</li>
</ol>
<p>equals是Object类中的方法，只能判断引用类型。默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等，例如String、Integer</p>
<h3 id="hashcode方法"><a href="#hashcode方法" class="headerlink" title="hashcode方法"></a>hashcode方法</h3><ol>
<li>提高具有哈希结构的容器的效率</li>
<li>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的</li>
<li>两个引用，如果指向的是不同对象，则哈希值是不一样的</li>
<li>哈希值主要根据地址号来的，不能完全将哈希值等价于地址</li>
</ol>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><ol>
<li>默认返回：全类名+@+哈希值的16进制，子类往往重写toString方法，用于返回对象的属性信息</li>
<li>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式</li>
<li>当直接输出一个对象时，toString会被默认的调用</li>
</ol>
<h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h3><ol>
<li>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作</li>
<li>什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法</li>
<li>垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制</li>
</ol>
<h2 id="类变量和类方法"><a href="#类变量和类方法" class="headerlink" title="类变量和类方法"></a>类变量和类方法</h2><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><p>类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量</p>
<p>定义语法：</p>
<ol>
<li>访问修饰符 static 数据类型 变量名；</li>
<li>static 访问修饰符 数据类型 变量名；</li>
</ol>
<p>访问类变量：</p>
<p>类名.类变量名 或者 对象名.类变量名</p>
<h4 id="使用细节-6"><a href="#使用细节-6" class="headerlink" title="使用细节"></a>使用细节</h4><ol>
<li>当需要让类中的所有对象都共享同一个变量时，就可以考虑使用类变量</li>
<li>类变量与实例变量区别：类变量是该类的所有对象共享的，实例变量是每个对象独享的</li>
<li>实例变量不能通过 类名.类变量名 方式访问</li>
<li>类变量是在类加载时初始化，即使没有创建对象，只要类加载了，就可以使用类变量了</li>
<li>类变量的生命周期是随类的加载开始，随着类的消亡销毁</li>
</ol>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>类方法也叫静态方法</p>
<p>格式：</p>
<ol>
<li>访问修饰符 static 返回类型 方法名(){}</li>
<li>static 访问修饰符 返回类型 方法名(){}</li>
</ol>
<p>调用：</p>
<ol>
<li>类名.类方法名</li>
<li>对象名.类方法名</li>
</ol>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率</p>
<p>例如：工具类中的方法 utils(Math类、Arrays类)</p>
<h4 id="使用细节-7"><a href="#使用细节-7" class="headerlink" title="使用细节"></a>使用细节</h4><ol>
<li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区</li>
<li>类方法中无this参数，普通方法中隐含着this的参数</li>
<li>类方法可以通过类名调用，也可以通过对象名调用</li>
<li>普通方法和对象有关，需要通过对象名调用，不能通过类名调用</li>
<li>类方法中不能使用和对象有关的关键字比如this、super</li>
<li>类方法中只能访问静态变量或静态方法</li>
<li>普通成员方法既可以访问非静态成员，也可以访问静态成员</li>
</ol>
<h2 id="mian方法"><a href="#mian方法" class="headerlink" title="mian方法"></a>mian方法</h2><p>解释mian方法的形式：public static void main(String[] args){}</p>
<ol>
<li>main方法时虚拟机调用</li>
<li>java虚拟机调用类的mian()方法,所以该方法的访问权限必须是public</li>
<li>虚拟机在执行mian()方法时不必创建对象，所以该方法必须使static</li>
<li>该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</li>
</ol>
<p>注意：</p>
<ol>
<li>在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性</li>
<li>不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</li>
</ol>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块又称为初始化块，属于类中的成员[即，是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来</p>
<p>但和方法不同，没有方法名，没有返回值，没有参数，只有方法体，而且不用通过对象或类的显式调用，而是加载类时，或创建对象时隐式调用</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>[修饰符]{代码};</p>
<p>说明注意：</p>
<ol>
<li>修饰符可选，只能写static</li>
<li>代码块分为两类，使用static修饰的叫静态代码块，否则为普通代码块</li>
<li>逻辑语句可以为任何逻辑语句</li>
<li>;号可以写也可以省略</li>
</ol>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><ol>
<li>相当于另一种形式的构造器(对构造器的补充机制)，可以做初始化的操作</li>
<li>场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性</li>
</ol>
<h3 id="使用细节-8"><a href="#使用细节-8" class="headerlink" title="使用细节"></a>使用细节</h3><ol>
<li>static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行</li>
<li>类什么时候加载<ol>
<li>创建对象实例时(new)</li>
<li>创建子类对象实例，父类也会被加载</li>
<li>使用类的静态成员时(静态属性、静态方法)</li>
</ol>
</li>
<li>普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次。如果只是使用类的静态成员时，普通代码块并不会执行</li>
<li>创建一个对象时，在一个类的调用顺序：<ol>
<li>调用静态代码块和静态属性初始化</li>
<li>调用普通代码块和普通属性初始化</li>
<li>调用构造方法</li>
</ol>
</li>
<li>构造器的最前面其实隐含了super()和调用普通代码块</li>
</ol>
<p>当创建一个子类对象时(继承关系)，他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序</p>
<ol>
<li>父类的静态代码块和静态属性(优先级一样，按定义顺序执行)</li>
<li>子类的静态代码块和静态属性(优先级一样，按定义顺序执行)</li>
<li>父类的普通代码块和普通属性(优先级一样，按定义顺序执行)</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和普通属性(优先级一样，按定义顺序执行)</li>
<li>子类的构造方法</li>
</ol>
<p>静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任意成员</p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final可以修饰类、属性、方法和局部变量</p>
<p>使用final场合：</p>
<ol>
<li>当不希望类被继承时</li>
<li>当不希望父类的某个方法被子类覆盖/重写时</li>
<li>当不希望类的某个属性的值被修改</li>
<li>当不希望某个局部变量被修改</li>
</ol>
<h3 id="使用细节-9"><a href="#使用细节-9" class="headerlink" title="使用细节"></a>使用细节</h3><ol>
<li>final修饰的属性又叫常量，一般用XX_XX_XX来命名</li>
<li>final修饰的属性在定义时,必须赋初值，并且以后不能再修改，可以赋初值的位置：<ul>
<li>定义时</li>
<li>在构造器中</li>
<li>代码块中</li>
</ul>
</li>
<li>如果final修饰的属性是静态的，则初始化的位置只能是定义时或静态代码块中</li>
<li>final类不能继承，但是可以实例化对象</li>
<li>如果类不是final，但是含有final方法，则该方法虽然不能重写，但是可以被继承</li>
<li>一般来说，如果已经是final类，就没必要再将方法修饰成final方法</li>
<li>final不能修饰构造方法</li>
<li>final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理</li>
<li>包装类和String,都是final类</li>
</ol>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>当父类的某些方法需要声明，但又不确定如何实现的时候，可以将其声明为抽象方法，那么这个类就是抽象类</p>
<ol>
<li>用abstract关键字来修饰一个类的时候，这个类就叫做抽象类，修饰方法的时候就叫抽象方法</li>
<li>抽象类的价值更多作用是在于设计，是设计者设置好后，让子类继承并实现抽象类()</li>
</ol>
<h3 id="使用细节-10"><a href="#使用细节-10" class="headerlink" title="使用细节"></a>使用细节</h3><ol>
<li>抽象类不能被实例化</li>
<li>抽象类不一定要包含abstract方法</li>
<li>一旦类包含了abstract方法，那这个类必须声明为抽象类</li>
<li>abstract只能修饰类和方法，不能修饰属性和其他的</li>
<li>抽象类可以有任意成员[抽象类本质还是类]，比如：非抽象方法、构造器、静态属性等等</li>
<li>抽象方法不能有主体，即不能实现</li>
<li>如果一个类继承了抽象类，则必须实现所有抽象类的所有抽象方法，除非他自己也声明为abstract类</li>
<li>抽象方法不能使用private、final、static来修饰，因为这些关键词都是和重写相违背的</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法实现出来</p>
<p>interface 接口名{}</p>
<p>class 类名 implements 接口{必须实现接口的方法}</p>
<p>接口是更加抽象的抽象的类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体【jdk7】。接口体现了程序设计的多态和高内聚低耦合的设计思想</p>
<p>注意：jdk8后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现</p>
<h3 id="使用细节-11"><a href="#使用细节-11" class="headerlink" title="使用细节"></a>使用细节</h3><ol>
<li>接口不能被实例化</li>
<li>接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰</li>
<li>一个普通类实现接口，就必须将该接口的所有方法实现</li>
<li>抽象类实现接口，可以不用实现接口的方法</li>
<li>一个类可以实现多个接口</li>
<li>接口中的属性只能是final的，而且是public static final修饰符，必须初始化（比如：int a=1实际上是public static final int a=1）</li>
<li>接口中属性访问形式：接口名.属性名</li>
<li>接口不能继承其他的类，但是可以继承多个其他接口</li>
<li>接口的修饰符只能是public和默认，这点和类的修饰符是一样的</li>
</ol>
<h3 id="接口和继承"><a href="#接口和继承" class="headerlink" title="接口和继承"></a>接口和继承</h3><p>继承的价值在于：解决代码的复用性和可维护性</p>
<p>接口的价值主要在于：设计好各种规范(方法)，让其他类去实现这些方法。即，更加的灵活</p>
<p>接口比继承更加灵活，继承是满足is-a的关系，接口是满足like-a的关系</p>
<p>接口在一定程度上实现代码解耦【即：接口规范性+动态绑定机制】</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类被称为内部类，嵌套其他类的类称为外部类，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系</p>
<p>如果定义在局部位置(方法中/代码块):<strong>局部内部类</strong>（有类名）&amp;<strong>匿名内部类</strong>（没有类名）</p>
<p>定义在成员的位置:<strong>成员内部类</strong>（没用static修饰）&amp;<strong>静态内部类</strong>（使用static修饰）</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类是定义在外部类的局部位置，比如方法中，并且有类名。</p>
<ol>
<li>可以直接访问外部类的所有成员，包含私有的</li>
<li>不能添加访问修饰符，因为它是一个局部变量，局部变量是不能使用修饰符的。但是可以使用final修饰，因为局部变量可以使用final</li>
<li>作用域：仅仅在定义它的方法或代码块中</li>
<li>局部内部类访问外部类的成员[访问方式：直接访问]</li>
<li>外部类访问局部内部类的成员[访问方式：创建对象，再访问（注意：必须在作用域中）]</li>
<li>外部其他类不能访问局部内部类(因为局部内部类地位是一个局部变量)</li>
<li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员则可以使用（外部类名.this.成员）去访问</li>
</ol>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类既是一个类的定义，也是一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 引用名=<span class="keyword">new</span> 类名(参数类型 形参)&#123;实现接口、抽象类或父类的方法&#125;.方法名;</span><br></pre></td></tr></table></figure>

<p>匿名内部类只会加载一次，</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p>
<ol>
<li>可以直接访问外部类的所有成员，包含私有的</li>
<li>可以添加任意访问修饰符</li>
<li>作用域和外部其他成员一样，为整个类体</li>
<li>成员内部类访问外部类[直接访问]</li>
<li>外部类访问成员内部类[先创建对象，再访问]</li>
</ol>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类是定义在外部类的成员位置，并且有static修饰</p>
<ol>
<li>可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员</li>
<li>可以添加任意访问修饰符，因为他的地位就是一个成员</li>
<li>作用域：同其他成员，为整个类体</li>
<li>静态内部类访问外部类[直接访问所有静态成员]</li>
<li>外部类访问静态内部类[创建对象再访问]</li>
</ol>

        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2021/07/22/2021722-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(OOP)/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2021/07/22/2021722-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(OOP)/";
            const title         = "「面向对象编程(OOP)」";
            const excerpt       = `基本概念面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现。面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装。
优点：

易...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a>, <a class="tag-none-link" href="/tags/OOP/" rel="tag">OOP</a>
                </div>
                <div class="pull-date">
                <span>最后编辑：2021-08-08</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" 七大设计原则" href="/2021/07/15/2021715-七大设计原则/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" 常用类" href="/2021/07/30/2021730-常用类/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">不要走进那个温和的良宵。</p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">三大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-text">五大基本原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="toc-text">访问属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="toc-text">类和对象的内存分配机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">成员方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">方法调用机制原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="toc-text">基本数据类型的传参机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="toc-text">引用数据类型的传参机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92"><span class="toc-text">方法递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%EF%BC%88OverLoad%EF%BC%89"><span class="toc-text">方法重载（OverLoad）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-1"><span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-text">注意事项和使用细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-2"><span class="toc-text">使用细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">构造方法&#x2F;构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-3"><span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">对象创建流程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-4"><span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-text">面向对象编程三大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">super关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#super-%E5%92%8C-this-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">super 和 this 的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BD%93%E7%8E%B0"><span class="toc-text">具体体现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text">方法的多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text">对象的多态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-text">动态绑定机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">多态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-text">多态参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99-%E8%A6%86%E7%9B%96"><span class="toc-text">方法重写&#x2F;覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-5"><span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD"><span class="toc-text">重写与重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="toc-text">Object类详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95-amp"><span class="toc-text">equals方法&amp;&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashcode%E6%96%B9%E6%B3%95"><span class="toc-text">hashcode方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString%E6%96%B9%E6%B3%95"><span class="toc-text">toString方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finalize%E6%96%B9%E6%B3%95"><span class="toc-text">finalize方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">类变量和类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F"><span class="toc-text">类变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-6"><span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-7"><span class="toc-text">使用细节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mian%E6%96%B9%E6%B3%95"><span class="toc-text">mian方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-text">格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3"><span class="toc-text">理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-8"><span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-9"><span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-10"><span class="toc-text">使用细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82-11"><span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-text">接口和继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">静态内部类</span></a></li></ol></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Error/">Error</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDBC/">JDBC</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/">JVM-字节码与类的加载</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/">JVM-字节码与类的加载篇</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">30</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Web/">Java Web</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MyBatis/">MyBatis</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SSM/">SSM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/springmvc/">springmvc</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ssm/">ssm</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%91%E5%B9%B4%E3%81%AE%E6%97%A5%E5%B8%B8/">少年の日常</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">1</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/Callable/" style="font-size: 0.6em;">Callable</a> <a href="/tags/Date/" style="font-size: 0.6em;">Date</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 0.6em;">Java基础</a> <a href="/tags/Map/" style="font-size: 0.6em;">Map</a> <a href="/tags/NoSQL/" style="font-size: 0.6em;">NoSQL</a> <a href="/tags/OOP/" style="font-size: 0.6em;">OOP</a> <a href="/tags/Set/" style="font-size: 0.6em;">Set</a> <a href="/tags/Socket/" style="font-size: 0.6em;">Socket</a> <a href="/tags/String/" style="font-size: 0.6em;">String</a> <a href="/tags/TCP/" style="font-size: 0.6em;">TCP</a> <a href="/tags/UDP/" style="font-size: 0.6em;">UDP</a> <a href="/tags/lock/" style="font-size: 0.6em;">lock</a> <a href="/tags/mybatis/" style="font-size: 0.6em;">mybatis</a> <a href="/tags/redis/" style="font-size: 0.6em;">redis</a> <a href="/tags/springmvc/" style="font-size: 0.6em;">springmvc</a> <a href="/tags/ssm/" style="font-size: 0.6em;">ssm</a> <a href="/tags/synchronized/" style="font-size: 0.6em;">synchronized</a> <a href="/tags/%E5%8C%85%E8%A3%85%E7%B1%BB/" style="font-size: 0.6em;">包装类</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2021/11/30/20211130-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"><i class="fa  fa-book"></i> 类的加载过程</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/11/23/20211123-Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"><i class="fa  fa-book"></i> Class文件结构</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/11/22/20211122-MyBatis-Plus%E9%A3%9F%E7%94%A8%E8%AF%B4%E6%98%8E/"><i class="fa  fa-book"></i> MyBatis-Plus食用说明(持续更新)</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/11/22/20211122-%E6%AF%8F%E6%97%A5%E7%9F%A5%E8%AF%86%E7%82%B9/"><i class="fa  fa-book"></i> 反正算是知识点但因为不知道怎么分类就随便起个名字吧</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/11/19/20211119-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"><i class="fa  fa-book"></i> 垃圾回收器</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        <li><a href="mailto:1922856021@qq.com"><i class="fa fa-envelope"></i></a></li>
                        
                        
                        
                        
                        
                        
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2021 青い栞 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by FunnyLs.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>
<script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script>

    <div>
        <canvas id="snow"></canvas>
        <script async type="text/javascript" src="/js/snow.min.js"></script>
    </div>

<script async src="/js/candy.min.js"></script>

    <script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>