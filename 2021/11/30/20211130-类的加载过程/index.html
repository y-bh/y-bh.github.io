<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="">
  <title>类的加载过程 | 青い栞</title>
  <meta name="author" content="FunnyLs" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="" />
  
  <meta name="description" content="概述在Java中数据类型分为基本数据类型和引用数据类型。 基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载 按照Java虚拟机规范，从Class文件到加载到内存中的类，到类卸载出内存为止，整个生命周期为：  加载→链接{验证→准备→解析}→初始化→使用→卸载  加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中 Loading（加载）阶段加载就是将Java类的字节码文件加">
<meta property="og:type" content="article">
<meta property="og:title" content="类的加载过程">
<meta property="og:url" content="http://example.com/2021/11/30/20211130-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="青い栞">
<meta property="og:description" content="概述在Java中数据类型分为基本数据类型和引用数据类型。 基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载 按照Java虚拟机规范，从Class文件到加载到内存中的类，到类卸载出内存为止，整个生命周期为：  加载→链接{验证→准备→解析}→初始化→使用→卸载  加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中 Loading（加载）阶段加载就是将Java类的字节码文件加">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/null">
<meta property="article:published_time" content="2021-11-29T16:00:00.000Z">
<meta property="article:modified_time" content="2021-12-12T14:26:51.489Z">
<meta property="article:author" content="FunnyLs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/null">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-blue.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"></a></li>
                                    
                                
                                    
                                        <li>
                                            <a><i class="fa fa-link"></i>链接</a>
                                            <ul class="sub-menu">
                                                
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://candinya.com">作者博客</a></li>
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://github.com/Candinya/Kratos-Rebirth">项目链接</a></li>
                                                    
                                                
                                            </ul>
                                        </li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">青い栞</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>青い栞</h2> <br />
                        <span></span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article>
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center">类的加载过程</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><i class="fa fa-calendar"></i> 2021-11-30</li>
                <li><i class="fa fa-user"></i> 作者 FunnyLs</li>
                <li>
                    <i class="fa fa-edit"></i> 
                    
                    
                        ~15.94K
                    
                    字
                </li>
                
            </ul>
        </header>
        <div class="kratos-post-content">
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                本文最后编辑于 <time datetime="1639319211489"></time> 前，其中的内容可能需要更新。
            </div>
            
                <div class="kratos-post-inner-toc">
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loading%EF%BC%88%E5%8A%A0%E8%BD%BD%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="toc-number">2.</span> <span class="toc-text">Loading（加载）阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">加载完成操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">二进制流的获取方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8EClass%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.4.</span> <span class="toc-text">类模板与Class实例的位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.4.1.</span> <span class="toc-text">类模板的位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.4.2.</span> <span class="toc-text">Class实例的位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.5.</span> <span class="toc-text">数组类的加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linking%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="toc-number">3.</span> <span class="toc-text">Linking（链接）阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Verification%EF%BC%88%E9%AA%8C%E8%AF%81%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">Verification（验证）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E9%AA%8C%E8%AF%81"><span class="toc-number">3.1.1.</span> <span class="toc-text">格式验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E6%A3%80%E6%9F%A5"><span class="toc-number">3.1.2.</span> <span class="toc-text">语义检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E9%AA%8C%E8%AF%81"><span class="toc-number">3.1.3.</span> <span class="toc-text">字节码验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E9%AA%8C%E8%AF%81"><span class="toc-number">3.1.4.</span> <span class="toc-text">符号引用验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Preparation%EF%BC%88%E5%87%86%E5%A4%87%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">Preparation（准备）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Resolution%EF%BC%88%E8%A7%A3%E6%9E%90%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">Resolution（解析）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Initialization%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="toc-number">4.</span> <span class="toc-text">Initialization（初始化）阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E4%B8%8Efinal%E7%9A%84%E6%90%AD%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">static与final的搭配问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E7%9A%84%E5%87%86%E5%A4%87%E7%8E%AF%E8%8A%82%E8%B5%8B%E5%80%BC"><span class="toc-number">4.1.1.</span> <span class="toc-text">在链接阶段的准备环节赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5-lt-clinit-gt-%E8%B5%8B%E5%80%BC"><span class="toc-number">4.1.2.</span> <span class="toc-text">在初始化阶段&lt; clinit &gt;()赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">4.1.3.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-clinit-gt-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">&lt; clinit &gt;()的线程安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8-amp-%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">类的初始化情况：主动使用&amp;被动使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">主动使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text">被动使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8-using"><span class="toc-number">5.</span> <span class="toc-text">类的使用(using)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD-Unloading"><span class="toc-number">6.</span> <span class="toc-text">类的卸载(Unloading)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E3%80%81%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">6.1.</span> <span class="toc-text">类、类加载器、类的实例之间的引用关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.2.</span> <span class="toc-text">类的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">类的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">7.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.1.1.</span> <span class="toc-text">类加载器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">显式加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">隐式加载</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">7.1.2.</span> <span class="toc-text">类加载器的必要性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">7.1.3.</span> <span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">类的唯一性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%A6%82%E8%BF%B0"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">命名空间概述</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">7.1.4.</span> <span class="toc-text">类加载器的基本特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB-1"><span class="toc-number">7.2.</span> <span class="toc-text">类加载器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Bootstrap-ClassLoader"><span class="toc-number">7.2.1.</span> <span class="toc-text">引导类加载器(Bootstrap ClassLoader)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Extension-ClassLoader"><span class="toc-number">7.2.2.</span> <span class="toc-text">扩展类加载器(Extension ClassLoader)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Application-ClassLoader"><span class="toc-number">7.2.3.</span> <span class="toc-text">系统类加载器(Application ClassLoader)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">7.2.4.</span> <span class="toc-text">用户自定义类加载器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">8.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">8.1.1.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A3%E5%8A%BF"><span class="toc-number">8.1.2.</span> <span class="toc-text">劣势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">8.2.</span> <span class="toc-text">破坏双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1"><span class="toc-number">8.2.1.</span> <span class="toc-text">第一次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1"><span class="toc-number">8.2.2.</span> <span class="toc-text">第二次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1"><span class="toc-number">8.2.3.</span> <span class="toc-text">第三次</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E6%9B%BF%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.3.</span> <span class="toc-text">热替换的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">沙箱安全机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-0%E6%97%B6%E6%9C%9F"><span class="toc-number">9.1.</span> <span class="toc-text">JDK1.0时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-1%E6%97%B6%E6%9C%9F"><span class="toc-number">9.2.</span> <span class="toc-text">JDK1.1时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-2%E6%97%B6%E6%9C%9F"><span class="toc-number">9.3.</span> <span class="toc-text">JDK1.2时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-6%E6%97%B6%E6%9C%9F"><span class="toc-number">9.4.</span> <span class="toc-text">JDK1.6时期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">自定义类的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%BD%9C%E7%94%A8"><span class="toc-number">10.1.</span> <span class="toc-text">自定义类加载器作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E5%8A%A0%E8%BD%BD%E7%B1%BB"><span class="toc-number">10.1.1.</span> <span class="toc-text">隔离加载类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">10.1.2.</span> <span class="toc-text">修改类加载的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">10.1.3.</span> <span class="toc-text">扩展加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2"><span class="toc-number">10.1.4.</span> <span class="toc-text">防止源码泄露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.1.5.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">10.2.1.</span> <span class="toc-text">对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">10.2.2.</span> <span class="toc-text">说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java9%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">11.</span> <span class="toc-text">Java9新特性</span></a></li></ol>
                </div>
            
            <hr />
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中数据类型分为基本数据类型和引用数据类型。</p>
<p>基本数据类型由虚拟机预先定义，引用数据类型则需要进行<strong>类的加载</strong></p>
<p>按照Java虚拟机规范，从Class文件到加载到内存中的类，到类卸载出内存为止，整个<strong>生命周期</strong>为：</p>
<blockquote>
<p>加载→链接{验证→准备→解析}→初始化→使用→卸载</p>
</blockquote>
<p>加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中</p>
<h2 id="Loading（加载）阶段"><a href="#Loading（加载）阶段" class="headerlink" title="Loading（加载）阶段"></a>Loading（加载）阶段</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>就是将Java类的字节码文件加载到机器内存中，并构建出Java类的原型–类模板对象。</p>
<p><strong>类模板对象</strong>：Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出常量池、类字段、类方法等信息存到类模板中，这样JVM在<strong>运行期</strong>即可通过类模板获取Java类中任意信息，对Java类中的成员进行遍历或方法调用。反射机制就是基于这一基础。</p>
<h3 id="加载完成操作"><a href="#加载完成操作" class="headerlink" title="加载完成操作"></a>加载完成操作</h3><p><strong>查找并加载类的二进制数据，生成Class实例</strong>。</p>
<p>在加载类时JVM必须完成3件事</p>
<ol>
<li>通过类的全名，获取类的二进制数据流</li>
<li>解析类的二进制数据流为方法区内的数据结构(Java类模板)</li>
<li>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li>
</ol>
<h3 id="二进制流的获取方式"><a href="#二进制流的获取方式" class="headerlink" title="二进制流的获取方式"></a>二进制流的获取方式</h3><ul>
<li>虚拟机可能通过文件系统读入一个class后缀的文件</li>
<li>读入jar、zip等归档数据包、提取类文件</li>
<li>事先存放在数据库中的类的二进制数据</li>
<li>使用类似于Http之类的协议通过网络进行加载</li>
<li>在运行时生成一段Class的二进制信息等</li>
</ul>
<p>收到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个java.lang.Class的实例</p>
<p>如果输入的数据不是ClassFile结构，就会抛出ClassFormatError错误</p>
<h3 id="类模板与Class实例的位置"><a href="#类模板与Class实例的位置" class="headerlink" title="类模板与Class实例的位置"></a>类模板与Class实例的位置</h3><h4 id="类模板的位置"><a href="#类模板的位置" class="headerlink" title="类模板的位置"></a>类模板的位置</h4><p>加载的类在JVM中创建相应的类结构，类结构会存储在方法区(JDK8之前:永久代，JDK8之后:元空间)</p>
<h4 id="Class实例的位置"><a href="#Class实例的位置" class="headerlink" title="Class实例的位置"></a>Class实例的位置</h4><p>类将.Class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象</p>
<p>说明：</p>
<p>Class类的构造方法是私有的，只有JVM能够创建</p>
<p>Java.lang.Class实例是访问类型元数据的接口，也是反射的关键数据、入口。通过Class类提供的接口，可以获得目标类所关联的.Class文件中具体的数据结构：方法、字段等信息</p>
<h3 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h3><p>数组类本身并不是由类加载器负责创建，而是JVM在运行时根据需要直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。</p>
<p>创建数组类的过程：</p>
<ol>
<li>如果数组的元素类型为引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型</li>
<li>JVM使用指定的元素类型和数组维度来创建新的数组类</li>
</ol>
<p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public</p>
<h2 id="Linking（链接）阶段"><a href="#Linking（链接）阶段" class="headerlink" title="Linking（链接）阶段"></a>Linking（链接）阶段</h2><h3 id="Verification（验证）"><a href="#Verification（验证）" class="headerlink" title="Verification（验证）"></a>Verification（验证）</h3><p>验证是链接操作的第一步，目的是保证加载的字节码是合法、合理并符合规范的</p>
<p>验证步骤大体为：</p>
<blockquote>
<p>格式检查→语义检查→字节码验证→符号引用验证</p>
</blockquote>
<p>其中，格式检查和加载阶段一起执行。验证通过，类加载器才会成功将类的二进制数据信息加载到方法区中。</p>
<p>格式检查之外的验证操作将在方法区中进行。</p>
<h4 id="格式验证"><a href="#格式验证" class="headerlink" title="格式验证"></a>格式验证</h4><p>魔数检查：是否以魔数<code>0XCAFEBABE</code>开头</p>
<p>版本检查：主版本和副版本号是否在当前Java虚拟机的支持范围内</p>
<p>长度检查：数据中每一个项是否都拥有正确的长度等。</p>
<h4 id="语义检查"><a href="#语义检查" class="headerlink" title="语义检查"></a>语义检查</h4><p>Java虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。如：</p>
<ul>
<li><p>是否所有的类都有父类的存在（在Java里，除了object外，其他类都应该有父类）</p>
</li>
<li><p>是否一些被定义为final的方法或者类被重写或继承了</p>
</li>
<li><p>非抽象类是否实现了所有抽象方法或者接口方法</p>
</li>
</ul>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>字节码验证是验证过程中最为复杂的一个过程，试图通过对字节码流的分析，判断字节码是否可以被正确地执行。如：</p>
<ul>
<li><p>在字节码的执行过程中，是否会跳转到一条不存在的指令</p>
</li>
<li><p>函数的调用是否传递了正确类型的参数</p>
</li>
<li><p>变量的赋值是不是给了正确的数据类型等</p>
</li>
</ul>
<p>栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但并不是100%准确判断，只能尽可能地检查出可以预知的明显问题。</p>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>校验器还将进符号引用的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<strong>虚拟机会检查这些类或者方法确实是存在的</strong>，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出<code>NoClassDefFoundError</code>，如果一个方法无法被找到，则会抛出<code>NoSuchMethodError</code>。此阶段在解析环节才会执行。</p>
<h3 id="Preparation（准备）"><a href="#Preparation（准备）" class="headerlink" title="Preparation（准备）"></a>Preparation（准备）</h3><p>为类的静态变量分配内存，并将其初始化为默认值</p>
<p>当一个类验证通过时，虚拟机就会进入准备阶段。会为该类分配内存空间，并设置默认值</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>Java并不支持boolean类型，对于boolean类型，内部实现是int，由于int的默认值是0，故对应的，boolean默认值为false</p>
<p>注意：</p>
<p>上述并不包含基本数据类型的字段用<code>static final</code>修饰的情况，<code>final</code>修饰的在编译的时候就会分配，准备阶段就会显式赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般情况：static final修饰的基本数据类型、字符串类型字面量会在准备阶段赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="comment">// 特殊情况：static final修饰的引用类型不会在准备阶段赋值，而是在初始化阶段赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="keyword">new</span> String(<span class="string">&quot;Hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 </p>
<p>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。 </p>
<h3 id="Resolution（解析）"><a href="#Resolution（解析）" class="headerlink" title="Resolution（解析）"></a>Resolution（解析）</h3><p>将类、接口、字段和方法的<strong>符号引用转为直接引用</strong>。</p>
<p>符号引用：就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。</p>
<p>以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。</p>
<p>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用</p>
<h2 id="Initialization（初始化）阶段"><a href="#Initialization（初始化）阶段" class="headerlink" title="Initialization（初始化）阶段"></a>Initialization（初始化）阶段</h2><p>为类的静态变量赋予正确的初始值</p>
<p>初始化阶段的重要工作是执行类的初始化方法:<code>&lt;clinit&gt;()</code>方法</p>
<ul>
<li>此方法仅能由Java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法</li>
<li>由静态类成员的赋值语句以及static语句块合并产生的</li>
</ul>
<p>补充：</p>
<p>父类的<code>&lt;clinit&gt;()</code>方法总是在子类的<code>&lt;clinit&gt;()</code>方法之前执行，也就是说父类的static块优先级高于子类</p>
<blockquote>
<p>由父及子，静态先行</p>
</blockquote>
<p>Java编译器不是为所有的类都能产生<code>&lt;clinit&gt;()</code>方法，当以下类编译为字节码文件时，字节码文件中不会包含<code>&lt;clinit&gt;()</code>方法</p>
<ol>
<li><p>一个类中并没有声明任何的类变量，也没有静态代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> num=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num1;</span><br></pre></td></tr></table></figure></li>
<li><p>一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num2=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="static与final的搭配问题"><a href="#static与final的搭配问题" class="headerlink" title="static与final的搭配问题"></a>static与final的搭配问题</h3><h4 id="在链接阶段的准备环节赋值"><a href="#在链接阶段的准备环节赋值" class="headerlink" title="在链接阶段的准备环节赋值"></a>在链接阶段的准备环节赋值</h4><ul>
<li>对于基本数据类型来说，如果使用static final修饰，则在此环节显式赋值(直接赋常量，而非调用方法)</li>
<li>对于引用类型来说，使用字面量的方式赋值，使用static final修饰，则在此环节赋值</li>
</ul>
<h4 id="在初始化阶段-lt-clinit-gt-赋值"><a href="#在初始化阶段-lt-clinit-gt-赋值" class="headerlink" title="在初始化阶段&lt; clinit &gt;()赋值"></a>在初始化阶段&lt; clinit &gt;()赋值</h4><p>除了在链接阶段的准备环节赋值的情况外，其余的情况</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>使用static+final修饰，并且进行显示赋值（定义的时候后面就已经附了初始值），还不涉及到方法或者构造器调用的基本数据类型或者String类型字面量(“XXX”这种形式，而不是new String(“XXX”)这种形式)的字段，将在准备中的链接阶段进行显示赋值，其他已经进行显示赋值的静态常量（包括引用类型，尤其是new String(“XXX”)这种类型的，还有调用其他方法获得的值，比如new Random().nextInt(10)等）或者静态变量（这是肯定在初始化方法中显示赋值）都将在初始化中的方法中进行显示赋值</p>
<p>对于准备阶段就完成赋值的，其字段下面的有属性ConstantValue，否则是没有属性ConstantValue</p>
<h3 id="lt-clinit-gt-的线程安全性"><a href="#lt-clinit-gt-的线程安全性" class="headerlink" title="&lt; clinit &gt;()的线程安全性"></a>&lt; clinit &gt;()的线程安全性</h3><p>虚拟机会在内部确保其多线程环境中的安全性。</p>
<p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境下被正确的加锁、同步。当多个线程去执行同一个初始化方法时，只会有一个线程去执行该方法，其他线程都需要阻塞等待，直到活动线程执行初始化方法完成。</p>
<p>同时，因为函数<code>&lt;clinit&gt;()</code>是线程安全的，所以，如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个线程堵塞，引发死锁。此类死锁较难发现，它们看起来并没有可用的锁信息。</p>
<p>初始化方法只会加载一次，当其他类需要使用时，虚拟机会直接返回给它已经准备好的信息。</p>
<h3 id="类的初始化情况：主动使用-amp-被动使用"><a href="#类的初始化情况：主动使用-amp-被动使用" class="headerlink" title="类的初始化情况：主动使用&amp;被动使用"></a>类的初始化情况：主动使用&amp;被动使用</h3><h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><p>Class在首次使用时会被装载，虚拟机不会无条件地装载Class类型。Java虚拟机规定一个类或接口在初次使用前，必须要进行初始化。这个“使用”指的就是主动使用。</p>
<p>主动使用情况：</p>
<ol>
<li>实例化：当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。  </li>
<li>静态方法：当调用类的静态方法时，即当使用了字节码invokestatic指令。 </li>
<li>静态字段：当使用类、接口的静态字段时（final修饰特殊考虑），比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）  </li>
<li>反射：当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”) </li>
<li>继承：当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>default方法：如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。 </li>
<li>main方法：当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。  </li>
<li>MethodHandle：当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF getStatic、REF_putStatic、REF invokeStatic方法句柄对应的类） </li>
</ol>
<p>出现上述情况时，会对类进行初始化。初始化之前的加载、验证、准备、解析已经完成</p>
<p>补充：</p>
<p>5：当Java虚拟机初始化一个类的时候，要求他的所有父类都已经被初始化，但是这条规则并不适用于接口：</p>
<ul>
<li>初始化一个类时，并不会先初始化它所实现的接口</li>
<li>初始化一个接口时，并不会先初始化它的父接口</li>
</ul>
<p>因此，一个父接口不会因为它的子接口或实现类的初始化而初始化。只有当程序第一次使用特定接口的静态字段时，会导致该接口的初始化。</p>
<p>7：JVM启动的时候通过引导类加载器加载一个初始类。这个类调用public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p>
<h4 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h4><p>除了主动使用的8种情况外，其余均为被动使用。</p>
<p>被动使用不会影响类的初始化。或者说，并不是在代码中出现的类，就一定会被加载或初始化。如果不符合主动使用的条件的话，类就不会初始化。</p>
<ol>
<li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化<ul>
<li>当通过子类引用父类的静态变量，子类加载但不会导致子类初始化</li>
</ul>
</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类接口的初始化。因为常量在链接阶段就已经被显式赋值了</li>
<li>调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</li>
</ol>
<h2 id="类的使用-using"><a href="#类的使用-using" class="headerlink" title="类的使用(using)"></a>类的使用(using)</h2><p>任何一个类在加载、链接和初始化3个类加载步骤结束后，即可被直接使用。</p>
<p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用new关键字为其创建对象实例。</p>
<h2 id="类的卸载-Unloading"><a href="#类的卸载-Unloading" class="headerlink" title="类的卸载(Unloading)"></a>类的卸载(Unloading)</h2><h3 id="类、类加载器、类的实例之间的引用关系"><a href="#类、类加载器、类的实例之间的引用关系" class="headerlink" title="类、类加载器、类的实例之间的引用关系"></a>类、类加载器、类的实例之间的引用关系</h3><p>类加载器的内部实现中，使用一个Java集合来存放所加载类的引用。一个Class对象总会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。因此，一个类的类加载器与Class实例为<strong>双向关联关系</strong></p>
<p>一个类的实例总是引用它的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有Java类都有一个静态属性class，它引用这个类的Class对象</p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>当一个类被加载、链接、初始化后，它的生命周期就开始了。当代表此类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，该类在方法区内的数据也会被卸载，结束该类的生命周期。</p>
<p><strong>一个类结束生命周期的时间，取决于它的Class对象何时结束生命周期</strong></p>
<h2 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>类加载器时JVM执行类加载机制的前提</p>
<h4 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h4><p>Jvm加载class文件到内存的方式</p>
<h5 id="显式加载"><a href="#显式加载" class="headerlink" title="显式加载"></a>显式加载</h5><p>显示加载指的是在代码中通过调用classLoader加载class对象，如直接调用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象</p>
<h5 id="隐式加载"><a href="#隐式加载" class="headerlink" title="隐式加载"></a>隐式加载</h5><p>隐式加载是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件的时候，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中</p>
<h4 id="类加载器的必要性"><a href="#类加载器的必要性" class="headerlink" title="类加载器的必要性"></a>类加载器的必要性</h4><ol>
<li>避免在开发中遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，只有了解类加载器的加载机制才能够在出现异常时快速地根据错误异常日志定位问题和解决问题</li>
<li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作</li>
<li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的逻辑处理</li>
</ol>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><h5 id="类的唯一性"><a href="#类的唯一性" class="headerlink" title="类的唯一性"></a>类的唯一性</h5><p><strong>对于任意一个类，都需要由加载它的类加载器和类本身一同确认其在Java虚拟机中的唯一性</strong>。每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<h5 id="命名空间概述"><a href="#命名空间概述" class="headerlink" title="命名空间概述"></a>命名空间概述</h5><ul>
<li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li>
<li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li>
<li>在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类</li>
</ul>
<h4 id="类加载器的基本特征"><a href="#类加载器的基本特征" class="headerlink" title="类加载器的基本特征"></a>类加载器的基本特征</h4><p>通常有三个基本特征</p>
<ul>
<li><strong>双亲委派模型</strong>。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>
<li><strong>可见性</strong>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>
<li><strong>单一性</strong>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li>
</ul>
<h3 id="类加载器的分类-1"><a href="#类加载器的分类-1" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分</p>
<p>启动类加载器通过C/C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器</p>
<h4 id="引导类加载器-Bootstrap-ClassLoader"><a href="#引导类加载器-Bootstrap-ClassLoader" class="headerlink" title="引导类加载器(Bootstrap ClassLoader)"></a>引导类加载器(Bootstrap ClassLoader)</h4><ul>
<li><p>这个类加载使用C/C++语言实现的，嵌套在JVM内部。 </p>
</li>
<li><p>它用来加载Java的核心库（JAVAHOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。 </p>
</li>
<li><p> 并不继承自java.lang.ClassLoader，没有父加载器。 </p>
</li>
<li><p> 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 </p>
</li>
<li><p> 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
</li>
</ul>
<p>使用<code>-XX:+TraceClassLoading</code>参数得到打印信息</p>
<h4 id="扩展类加载器-Extension-ClassLoader"><a href="#扩展类加载器-Extension-ClassLoader" class="headerlink" title="扩展类加载器(Extension ClassLoader)"></a>扩展类加载器(Extension ClassLoader)</h4><ul>
<li><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。 </p>
</li>
<li><p> 继承于ClassLoader类 </p>
</li>
<li><p> 父类加载器为启动类加载器 </p>
</li>
<li><p> 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p>
</li>
</ul>
<h4 id="系统类加载器-Application-ClassLoader"><a href="#系统类加载器-Application-ClassLoader" class="headerlink" title="系统类加载器(Application ClassLoader)"></a>系统类加载器(Application ClassLoader)</h4><p>应用程序类加载器（系统类加载器，AppClassLoader）</p>
<ul>
<li><p>java语言编写，由sun.misc.Launcher$AppClassLoader实现</p>
</li>
<li><p>继承于ClassLoader类</p>
</li>
<li><p>父类加载器为扩展类加载器</p>
</li>
<li><p>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</p>
</li>
<li><p>应用程序中的类加载器默认是系统类加载器</p>
</li>
<li><p>它是用户自定义类加载器的默认父加载器</p>
</li>
<li><p>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</p>
</li>
</ul>
<h4 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h4><ul>
<li><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
</li>
<li><p>体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</p>
</li>
<li><p>通过类加载器可以实现绝妙的插件机制，例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</p>
</li>
<li><p>同时，自定义加载器都能够实现应用隔离，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</p>
</li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oaaG28"><img src="https://z3.ax1x.com/2021/12/03/oaaG28.md.png" alt="oaaG28.md.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oaacMF"><img src="https://z3.ax1x.com/2021/12/03/oaacMF.png" alt="oaacMF.png"></a></p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>避免类的重复加载，确保一个类的全局唯一性。（Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层次关系可以避免类的重复加载，当父类加载过该类时，子类不会重复加载。）</p>
<p>保护程序安全，防止核心API被随意篡改</p>
<p>双亲委派机制在java.lang.ClassLoader.loadClass(String，boolean)接口中体现。该接口的逻辑如下：</p>
<ol>
<li>先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li>
<li>判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。</li>
<li>反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassorNull(name)接口，让引导类加载器进行加载。</li>
<li>如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</li>
</ol>
<p>双亲委派的模型就隐藏在这第2和第3步中。</p>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>java虚拟机并没有规定一定要使用双亲委派模型，只是建议采用。比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Serylet规范推荐的一种做法。</p>
<h3 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h3><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<h4 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h4><p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，<strong>为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</strong>，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h4 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h4><p>双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题。但当基础类型又要回调用户代码时(JNDI服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码)，启动类加载器并不认识这些代码。此时设计团队设计了<strong>线程上下文加载器</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<h4 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h4><p>由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p>
<p>IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p>
<p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索</p>
<ol>
<li>将以java.*开头的类，委派给父类加载器加载</li>
<li>否则，将委派列表名单的类，委派给父类加载器加载</li>
<li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bund1e的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
<p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p>
<h3 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h3><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。</p>
<p>热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p>
<p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/oa2mMn"><img src="https://z3.ax1x.com/2021/12/03/oa2mMn.md.png" alt="oa2mMn.md.png"></a></p>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><ol>
<li>保证程序安全</li>
<li>保护Java原生的JDK代码</li>
</ol>
<p>Java安全模式的核心就是Java沙箱(sandbox)。沙箱是一个限制程序运行的环境。</p>
<p>沙箱机制就是将Java代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问。保证对代码的有限隔离，防止对本地系统造成破坏。</p>
<p>沙箱主要限制系统资源访问。系统资源包括CPU、内存、文件系统、网络等。不同级别的沙箱对这些资源的访问限制也不一样。</p>
<p>所有的Java程序运行都可以指定沙箱，可以制定安全策略</p>
<h3 id="JDK1-0时期"><a href="#JDK1-0时期" class="headerlink" title="JDK1.0时期"></a>JDK1.0时期</h3><p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于<strong>沙箱（Sandbox）机制</strong>。</p>
<h3 id="JDK1-1时期"><a href="#JDK1-1时期" class="headerlink" title="JDK1.1时期"></a>JDK1.1时期</h3><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p>
<p>因此在后续的Java1.1版本中，针对安全机制做了改进，增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。</p>
<h3 id="JDK1-2时期"><a href="#JDK1-2时期" class="headerlink" title="JDK1.2时期"></a>JDK1.2时期</h3><p>在Java1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。</p>
<h3 id="JDK1-6时期"><a href="#JDK1-6时期" class="headerlink" title="JDK1.6时期"></a>JDK1.6时期</h3><p>当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。</p>
<p>虚拟机会把所有代码加载到不同的系统域和应用域。<strong>系统域部分专门负责与关键资源进行交互</strong>，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限。</p>
<h2 id="自定义类的加载器"><a href="#自定义类的加载器" class="headerlink" title="自定义类的加载器"></a>自定义类的加载器</h2><h3 id="自定义类加载器作用"><a href="#自定义类加载器作用" class="headerlink" title="自定义类加载器作用"></a>自定义类加载器作用</h3><h4 id="隔离加载类"><a href="#隔离加载类" class="headerlink" title="隔离加载类"></a>隔离加载类</h4><p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如:阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如:Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。 </p>
<h4 id="修改类加载的方式"><a href="#修改类加载的方式" class="headerlink" title="修改类加载的方式"></a>修改类加载的方式</h4><p>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载 </p>
<h4 id="扩展加载器"><a href="#扩展加载器" class="headerlink" title="扩展加载器"></a>扩展加载器</h4><p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p>
<h4 id="防止源码泄露"><a href="#防止源码泄露" class="headerlink" title="防止源码泄露"></a>防止源码泄露</h4><p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是JavaEE和OSGI、JPMS等框架。</p>
</li>
<li><p>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</p>
</li>
</ul>
<p>注意：一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<p>在自定义ClassLoader的子类时候，我们常见的会有两种做法:</p>
<ul>
<li><p>方式一:重写<code>loadClass()</code>方法</p>
</li>
<li><p>方式二:重写<code>findclass()</code>方法</p>
</li>
</ul>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>本质上差不多，loadClass()也会调用findClass()。但从逻辑上讲最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</p>
<p>loadclass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此最好在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委派的重复代码，从代码复用性上来说，不直接修改这个方法始终是比较好的选择</p>
<p>当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作</p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li><p>其父类加载器是系统类加载器</p>
</li>
<li><p>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</p>
</li>
</ul>
<h2 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h2><p>为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>
<ol>
<li><p>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(platform class loader)。可以通过classLoader的新方法getPlatformClassLoader()来获取。<br>JDK9时基于模块化进行构建(原来的rt.jar和tools.jar被拆分成数十个JMOD文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<JAVA_HOME>\lib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。 </p>
</li>
<li><p>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。<br>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。 </p>
</li>
</ol>
<p>   <a target="_blank" rel="noopener" href="https://imgtu.com/i/o6fe4H"><img src="https://s4.ax1x.com/2021/12/07/o6fe4H.png" alt="o6fe4H.png"></a></p>
<blockquote>
<p>​    如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。</p>
</blockquote>
<ol start="3">
<li>在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li>
<li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li>
<li>类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/o6fsVU"><img src="https://s4.ax1x.com/2021/12/07/o6fsVU.md.png" alt="o6fsVU.md.png"></a></p>
<p>在Java模块化系统明确规定了三个类加载器负责各自加载的模块</p>
<p><strong>启动类加载器负责加载的模块</strong></p>
<blockquote>
<p>java.base<br>java.security.sasl<br>java.datatransfer<br>java.xml<br>java.desktop<br>jdk.httpserver<br>java.instrument<br>jdk.internal.vm.ci<br>java.logging<br>jdk.management<br>java.management<br>jdk.management.agent<br>java.management.rmi<br>jdk.naming.rmi<br>java.naming<br>jdk.net<br>java.prefs<br>jdk.sctp<br>java.rmi<br>jdk. unsupported</p>
</blockquote>
<p><strong>平台类加载器负责加载的模块</strong></p>
<blockquote>
<p>java.activation*<br>jdk.accessibility<br>java.compiler*<br>jdk.charsets<br>java.corba*<br>jdk.crypto.cryptoki<br>java.scripting<br>jdk.crypto.ec<br>java.se<br>jdk.dynalink<br>java. se.ee<br>jdk.incubator.httpclient<br>java.security.jgss<br>jdk.internal.vm.compiler*<br>java.smartcardio<br>jdk .jsobject<br>java.sql<br>jdk . localedata<br>java.sql.rowset<br>jdk.naming.dns<br>java.transaction*<br>jdk.scripting.nashorn<br>java.xml.bind*<br>jdk.security.auth<br>java.xml.crypto<br>jdk.security.jgss<br>java.xml.ws*<br>jdk .xml.dom<br>java.xml.ws.annotation*<br>jdk.zipfs</p>
</blockquote>
<p><strong>应用程序类加载器负责加载的模块</strong></p>
<blockquote>
<p>jdk.aot<br>jdk.jdeps<br>jdk.attach<br>jdk.jdi<br>jdk.compiler<br>jdk.jdwp.agent</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());</span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">        <span class="comment">//获取平台类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getPlatformClassLoader());</span><br><span class="line">        <span class="comment">//获取类的加载器的名称</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "http://example.com/2021/11/30/20211130-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "http://example.com/2021/11/30/20211130-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/";
            const title         = "「类的加载过程」";
            const excerpt       = `概述在Java中数据类型分为基本数据类型和引用数据类型。
基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载
按照Java虚拟机规范，从Class文件到加载到内存中的类，到类卸载出内存为止，整个生命周期为：

加载→链接{验...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    
                </div>
                <div class="pull-date">
                <span>最后编辑：2021-12-12</span>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" Class文件结构" href="/2021/11/23/20211123-Class文件结构/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" RabbitMq食用说明" href="/2021/12/09/2021129-RabbitMq食用说明/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="/images/avatar.webp" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">可以畏惧，但绝不停滞不前</p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loading%EF%BC%88%E5%8A%A0%E8%BD%BD%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="toc-text">Loading（加载）阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90%E6%93%8D%E4%BD%9C"><span class="toc-text">加载完成操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-text">二进制流的获取方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8EClass%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">类模板与Class实例的位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">类模板的位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Class%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">Class实例的位置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">数组类的加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linking%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="toc-text">Linking（链接）阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Verification%EF%BC%88%E9%AA%8C%E8%AF%81%EF%BC%89"><span class="toc-text">Verification（验证）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E9%AA%8C%E8%AF%81"><span class="toc-text">格式验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E4%B9%89%E6%A3%80%E6%9F%A5"><span class="toc-text">语义检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E9%AA%8C%E8%AF%81"><span class="toc-text">字节码验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E9%AA%8C%E8%AF%81"><span class="toc-text">符号引用验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Preparation%EF%BC%88%E5%87%86%E5%A4%87%EF%BC%89"><span class="toc-text">Preparation（准备）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Resolution%EF%BC%88%E8%A7%A3%E6%9E%90%EF%BC%89"><span class="toc-text">Resolution（解析）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Initialization%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="toc-text">Initialization（初始化）阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E4%B8%8Efinal%E7%9A%84%E6%90%AD%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-text">static与final的搭配问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5%E7%9A%84%E5%87%86%E5%A4%87%E7%8E%AF%E8%8A%82%E8%B5%8B%E5%80%BC"><span class="toc-text">在链接阶段的准备环节赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5-lt-clinit-gt-%E8%B5%8B%E5%80%BC"><span class="toc-text">在初始化阶段&lt; clinit &gt;()赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-clinit-gt-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text">&lt; clinit &gt;()的线程安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%83%85%E5%86%B5%EF%BC%9A%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8-amp-%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-text">类的初始化情况：主动使用&amp;被动使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-text">主动使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-text">被动使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8-using"><span class="toc-text">类的使用(using)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD-Unloading"><span class="toc-text">类的卸载(Unloading)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E3%80%81%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-text">类、类加载器、类的实例之间的引用关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">类的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">类的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">类加载器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%8A%A0%E8%BD%BD"><span class="toc-text">显式加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E5%8A%A0%E8%BD%BD"><span class="toc-text">隐式加载</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-text">类加载器的必要性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-text">类的唯一性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%A6%82%E8%BF%B0"><span class="toc-text">命名空间概述</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-text">类加载器的基本特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB-1"><span class="toc-text">类加载器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Bootstrap-ClassLoader"><span class="toc-text">引导类加载器(Bootstrap ClassLoader)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Extension-ClassLoader"><span class="toc-text">扩展类加载器(Extension ClassLoader)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-Application-ClassLoader"><span class="toc-text">系统类加载器(Application ClassLoader)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">用户自定义类加载器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A3%E5%8A%BF"><span class="toc-text">劣势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">破坏双亲委派机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1"><span class="toc-text">第一次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1"><span class="toc-text">第二次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1"><span class="toc-text">第三次</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E6%9B%BF%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">热替换的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">沙箱安全机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-0%E6%97%B6%E6%9C%9F"><span class="toc-text">JDK1.0时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-1%E6%97%B6%E6%9C%9F"><span class="toc-text">JDK1.1时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-2%E6%97%B6%E6%9C%9F"><span class="toc-text">JDK1.2时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-6%E6%97%B6%E6%9C%9F"><span class="toc-text">JDK1.6时期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">自定义类的加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%BD%9C%E7%94%A8"><span class="toc-text">自定义类加载器作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E5%8A%A0%E8%BD%BD%E7%B1%BB"><span class="toc-text">隔离加载类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">修改类加载的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">扩展加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2"><span class="toc-text">防止源码泄露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-text">说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java9%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">Java9新特性</span></a></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Error/">Error</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDBC/">JDBC</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">JVM-垃圾回收</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/">JVM-字节码与类的加载</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">29</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java-Web/">Java Web</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MyBatis/">MyBatis</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SSM/">SSM</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringCloud/">SpringCloud</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/springcloud/">springcloud</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B0%91%E5%B9%B4%E3%81%AE%E6%97%A5%E5%B8%B8/">少年の日常</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">1</span></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/Callable/" style="font-size: 0.6em;">Callable</a> <a href="/tags/Date/" style="font-size: 0.6em;">Date</a> <a href="/tags/GateWay/" style="font-size: 0.6em;">GateWay</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 0.6em;">Java基础</a> <a href="/tags/Map/" style="font-size: 0.6em;">Map</a> <a href="/tags/NoSQL/" style="font-size: 0.6em;">NoSQL</a> <a href="/tags/OOP/" style="font-size: 0.6em;">OOP</a> <a href="/tags/Ribbin/" style="font-size: 0.6em;">Ribbin</a> <a href="/tags/Set/" style="font-size: 0.6em;">Set</a> <a href="/tags/Socket/" style="font-size: 0.6em;">Socket</a> <a href="/tags/String/" style="font-size: 0.6em;">String</a> <a href="/tags/TCP/" style="font-size: 0.6em;">TCP</a> <a href="/tags/UDP/" style="font-size: 0.6em;">UDP</a> <a href="/tags/lock/" style="font-size: 0.6em;">lock</a> <a href="/tags/mybatis/" style="font-size: 0.6em;">mybatis</a> <a href="/tags/redis/" style="font-size: 0.6em;">redis</a> <a href="/tags/springmvc/" style="font-size: 0.6em;">springmvc</a> <a href="/tags/ssm/" style="font-size: 0.6em;">ssm</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2022/01/10/2022110-%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8(Stream)/"><i class="fa  fa-book"></i> 消息驱动</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/01/06/202216-%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83&%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF/"><i class="fa  fa-book"></i> 分布式配置中心&消息总线</a>
            
          
        
          
          
            <a class="list-group-item" href="/2022/01/04/202214-%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"><i class="fa  fa-book"></i> 服务网关</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/12/30/20211230-%E6%96%AD%E8%B7%AF%E5%99%A8/"><i class="fa  fa-book"></i> 断路器</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/12/23/20211223-%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/"><i class="fa  fa-book"></i> 服务调用</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        <li><a href="mailto:1922856021@qq.com"><i class="fa fa-envelope"></i></a></li>
                        
                        
                        
                        
                        
                        
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2022 青い栞 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by FunnyLs.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>

    <div>
        <canvas id="snow"></canvas>
        <script async type="text/javascript" src="/js/snow.min.js"></script>
    </div>




    <script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>